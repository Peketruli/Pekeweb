<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vampire Survival — Atributos + HUD</title>
<style>
  :root{ --hud-bg: rgba(0,0,0,0.55); --hud-fg: #fff; --accent: #f6c941;}
  html,body{height:100%; margin:0; font-family:Inter,system-ui,Arial; background:#111;}
  canvas{display:block; background:linear-gradient(#0b0b0f,#101014); }
  #ui {
    position: absolute; top: 8px; left: 8px; right: 8px; pointer-events:none;
    display:flex; justify-content:space-between; gap:12px;
  }
  .hud {
    pointer-events:auto;
    background:var(--hud-bg); color:var(--hud-fg); padding:10px; border-radius:10px;
    min-width:200px; max-width:360px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    font-size:13px;
  }
  .hud h3{margin:0 0 6px 0; font-size:14px;}
  .left-hud .weapons-list{display:flex; flex-direction:column; gap:6px;}
  .weapon{background:rgba(255,255,255,0.03); padding:6px; border-radius:6px;}
  .right-hud .attr{display:flex; justify-content:space-between; margin:4px 0;}
  #levelUp {
    position: absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    background:rgba(0,0,0,0.85); padding:18px; border-radius:12px; color:white;
    display:none; z-index:30; width:560px; pointer-events:auto;
  }
  .choices{display:flex; gap:10px; margin-top:12px;}
  .choice{flex:1; background:#111; border:1px solid rgba(255,255,255,0.06); padding:12px; border-radius:8px; cursor:pointer;}
  .choice:hover{border-color:var(--accent); transform:translateY(-4px); transition:all .15s ease;}
  #charSelect{position:absolute; right:8px; bottom:8px; background:var(--hud-bg); padding:8px;border-radius:8px;}
  .small{font-size:12px; color:#ddd}
  #debug{position:absolute; left:50%; bottom:8px; transform:translateX(-50%); background:rgba(0,0,0,0.6); padding:6px 10px; border-radius:6px; color:#ccc; font-size:12px;}
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="ui">
  <div class="hud left-hud">
    <h3>Armas</h3>
    <div class="weapons-list" id="weaponsList">
      <div class="weapon"><strong>Pistola</strong><div class="small">Daño: 5 | Cadencia: 300ms</div></div>
      <div class="weapon"><strong>Solar</strong><div class="small">Daño: 8 | Área: pequeña</div></div>
    </div>
    <div style="margin-top:8px" class="small">WASD mover • Click disparar • Subir nivel = ventanas</div>
  </div>

  <div class="hud right-hud" id="attrHUD">
    <h3>Atributos</h3>
    <!-- atributos se llenan dinámicamente -->
    <div id="attrs"></div>
    <div style="height:6px"></div>
    <div class="small" id="hpbar">HP: — / —</div>
    <div class="small" id="xpbar">XP: — / —</div>
  </div>
</div>

<div id="levelUp" >
  <h2>¡Subiste de nivel!</h2>
  <div class="small">Elige una mejora</div>
  <div class="choices" id="choices"></div>
  <div style="margin-top:10px" class="small">Si no te gusta puedes usar Reroll (si lo tienes)</div>
</div>

<div id="charSelect" class="small">
  Personaje:
  <select id="charSel">
    <option value="warrior">Guerrero</option>
    <option value="hunter">Cazador</option>
    <option value="mystic">Místico</option>
  </select>
  <button id="applyChar">Aplicar</button>
</div>

<div id="debug">Nivel: <span id="dbgLv">1</span> • Monedas: <span id="dbgGold">0</span></div>

<script>
// ---------- Canvas y utilidades ----------
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener('resize', resize);
resize();

function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

// ---------- Atributos base y personajes ----------
const ATTRIBUTE_KEYS = [
  'maxHealth','recovery','armor','moveSpeed','might','projSpeed','duration','area','cooldown','amount',
  'revival','magnet','luck','growth','greed','curse','reroll','skip','banish'
];

const CHARACTERS = {
  warrior: {
    name:'Guerrero', maxHealth:140, recovery:0.05, armor:2, moveSpeed:1.0, might:1.1, magnet:1.0, growth:1.0, greed:1.0,
    luck:1.0, cooldown:1.0, amount:1, projSpeed:1.0
  },
  hunter: {
    name:'Cazador', maxHealth:100, recovery:0.03, armor:0, moveSpeed:1.25, might:1.0, magnet:1.2, growth:1.1, greed:1.0,
    luck:1.1, cooldown:0.9, amount:1, projSpeed:1.2
  },
  mystic: {
    name:'Místico', maxHealth:90, recovery:0.08, armor:0, moveSpeed:1.05, might:1.25, magnet:1.0, growth:1.2, greed:1.0,
    luck:1.05, cooldown:1.2, amount:1, projSpeed:0.9
  }
};

// ---------- Estado global ----------
let state = {
  player: null,
  bullets: [],
  enemies: [],
  orbs: [],
  coins: 0,
  time: 0,
  lastEnemySpawn: 0,
  enemySpawnInterval: 2000,
};

// ---------- Player creación ----------
function createPlayer(characterKey){
  const base = CHARACTERS[characterKey];
  const stats = {};
  // initialize all attributes (default 1 or 0 depending)
  ATTRIBUTE_KEYS.forEach(k=>{
    stats[k] = (base[k] !== undefined) ? base[k] : (['maxHealth','recovery','armor','moveSpeed','might','projSpeed','duration','area','cooldown','amount','magnet','luck','growth','greed','curse'].includes(k) ? (k==='maxHealth'?100:1.0) : 0);
  });
  // extra tracking
  stats.currentHealth = stats.maxHealth;
  stats.xp = 0;
  stats.level = 1;
  stats.xpToNext = 15;
  stats.lastRegen = 0;
  stats.lastShot = 0;
  stats.position = {x:canvas.width/2, y:canvas.height/2};
  stats.velocity = {x:0,y:0};
  stats.direction = 0;
  stats.revivalUses = stats.revival || 0;
  return stats;
}

// start default
state.player = createPlayer('warrior');
document.getElementById('charSel').value = 'warrior';

// ---------- Input ----------
const keys = {};
addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);
let mouse = {x:0,y:0,down:false};
canvas.addEventListener('mousemove', e=>{
  mouse.x = e.clientX; mouse.y = e.clientY;
});
canvas.addEventListener('mousedown', e=> mouse.down = true);
canvas.addEventListener('mouseup', e=> mouse.down = false);

// ---------- Gameplay: bullets, enemies, orbs ----------
function spawnEnemy(){
  const side = Math.floor(rand(0,4));
  let ex = rand(0,canvas.width), ey = rand(0,canvas.height);
  if(side===0){ ex = -30; ey = rand(0,canvas.height); }
  if(side===1){ ex = canvas.width+30; ey = rand(0,canvas.height); }
  if(side===2){ ex = rand(0,canvas.width); ey = -30; }
  if(side===3){ ex = rand(0,canvas.width); ey = canvas.height+30; }
  state.enemies.push({
    x: ex, y: ey, r: 14 + Math.random()*10, speed: rand(0.4,1.2)*(1 + (state.player.curse||0)*0.2),
    hp: 8 + Math.floor(rand(0,6)) * (1 + (state.player.curse||0))
  });
}

function spawnOrb(x,y, amount=5){
  state.orbs.push({x,y, vx: rand(-0.5,0.5), vy: rand(-0.5,0.5), val: amount});
}

// ---------- Update loop ----------
function update(dt){
  const p = state.player;
  state.time += dt;

  // movement WASD
  let mvx=0,mvy=0;
  if(keys['w']) mvy -= 1; if(keys['s']) mvy +=1;
  if(keys['a']) mvx -=1; if(keys['d']) mvx +=1;
  const mag = Math.hypot(mvx,mvy) || 1;
  const speed = 160 * (p.moveSpeed || 1);
  p.velocity.x = (mvx/mag)*speed;
  p.velocity.y = (mvy/mag)*speed;
  p.position.x += p.velocity.x * (dt/1000);
  p.position.y += p.velocity.y * (dt/1000);
  p.position.x = clamp(p.position.x, 20, canvas.width-20);
  p.position.y = clamp(p.position.y, 20, canvas.height-20);

  // regen health
  p.lastRegen += dt;
  if(p.lastRegen > 500){ // tick every 0.5s
    p.currentHealth = Math.min(p.maxHealth, p.currentHealth + (p.recovery || 0) * (p.maxHealth) * 0.5);
    p.lastRegen = 0;
  }

  // shooting (simple auto cooldown)
  if(mouse.down){
    const cd = (p.cooldown || 1.0) * 300; // base 300ms
    if(state.time - p.lastShot > cd){
      shootBullet(p.position.x, p.position.y, mouse.x, mouse.y, p.might || 1, p.projSpeed || 1);
      p.lastShot = state.time;
    }
  }

  // bullets movement & hit detection
  for(let i = state.bullets.length-1; i>=0; i--){
    const b = state.bullets[i];
    b.x += b.vx * (dt/16);
    b.y += b.vy * (dt/16);
    // remove out of bounds
    if(b.x < -50 || b.x > canvas.width+50 || b.y < -50 || b.y > canvas.height+50){ state.bullets.splice(i,1); continue; }
    // collision with enemies
    for(let j = state.enemies.length-1; j>=0; j--){
      const e = state.enemies[j];
      if(Math.hypot(b.x-e.x, b.y-e.y) < e.r){
        e.hp -= b.damage;
        state.bullets.splice(i,1);
        if(e.hp <= 0){
          // spawn orbs and occasional coin
          const orbCount = Math.ceil(rand(2,6) * (p.growth || 1));
          spawnOrb(e.x, e.y, orbCount);
          if(Math.random() < 0.25 * (p.luck || 1)){
            state.coins += Math.ceil(rand(1,4) * (p.greed || 1));
          }
          state.enemies.splice(j,1);
        }
        break;
      }
    }
  }

  // enemies movement & contact damage
  for(let i = state.enemies.length-1; i>=0; i--){
    const e = state.enemies[i];
    const dx = p.position.x - e.x;
    const dy = p.position.y - e.y;
    const d = Math.hypot(dx,dy);
    e.x += (dx/d) * e.speed * (dt/16);
    e.y += (dy/d) * e.speed * (dt/16);
    // touch damage
    if(d < e.r + 10){
      // damage application with armor reduction
      const baseDamage = 8;
      const effective = Math.max(0, baseDamage - (p.armor || 0));
      // small cooldown on damage invuln (simple)
      if(!p._hitCooldown || state.time - p._hitCooldown > 500){
        p.currentHealth -= effective;
        p._hitCooldown = state.time;
        if(p.currentHealth <= 0){
          // revival check
          if(p.revival > 0){
            p.revival--;
            p.currentHealth = p.maxHealth * 0.5;
          } else {
            // die => respawn with partial health and lose some coins/xp
            p.currentHealth = Math.max(10, Math.floor(p.maxHealth*0.4));
            state.coins = Math.max(0, Math.floor(state.coins * 0.6));
          }
        }
      }
    }
  }

  // orbs movement (attracted by magnet)
  for(let i = state.orbs.length-1; i>=0; i--){
    const o = state.orbs[i];
    // drift
    o.x += o.vx * (dt/16);
    o.y += o.vy * (dt/16);
    // apply magnet if within magnet radius
    const magnetRadius = 40 + (p.magnet || 1) * 30;
    const d = Math.hypot(p.position.x - o.x, p.position.y - o.y);
    if(d < magnetRadius){
      // accelerate towards player
      const dirx = (p.position.x - o.x)/d || 0;
      const diry = (p.position.y - o.y)/d || 0;
      o.x += dirx * (120 * (p.magnet || 1)) * (dt/1000);
      o.y += diry * (120 * (p.magnet || 1)) * (dt/1000);
    }
    // pickup if very close
    if(Math.hypot(o.x - p.position.x, o.y - p.position.y) < 14){
      // XP gained scaled by growth
      const xpGain = Math.ceil(o.val * (p.growth || 1));
      gainXP(xpGain);
      state.orbs.splice(i,1);
    }
  }

  // spawn enemies over time (curse increases spawn)
  if(state.time - state.lastEnemySpawn > state.enemySpawnInterval / (1 + (p.curse||0)*0.15)){
    spawnEnemy();
    state.lastEnemySpawn = state.time;
  }

  // level cap & UI updates
  updateHUD();
}

// ---------- Shooting ----------
function shootBullet(sx,sy,tx,ty, power=1, projSpeed=1){
  const ang = Math.atan2(ty-sy, tx-sx);
  const speed = 8 * (projSpeed||1);
  state.bullets.push({x:sx, y:sy, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, damage: Math.round(5 * (power||1))});
}

// ---------- XP / Leveling ----------
function gainXP(amount){
  const p = state.player;
  p.xp += amount;
  // check level
  while(p.xp >= p.xpToNext){
    p.xp -= p.xpToNext;
    p.level++;
    p.xpToNext = Math.floor(p.xpToNext * 1.3 + 5);
    showLevelUpChoices();
  }
}

// ---------- Level up choices ----------
const ALL_ATTRS = [
  {key:'might', label:'Poder', type:'mul', amount:0.12},
  {key:'moveSpeed', label:'Velocidad movimiento', type:'mul', amount:0.08},
  {key:'maxHealth', label:'Salud Máx', type:'add', amount:20},
  {key:'recovery', label:'Recuperación', type:'add', amount:0.02},
  {key:'armor', label:'Armadura', type:'add', amount:1},
  {key:'magnet', label:'Imán', type:'mul', amount:0.15},
  {key:'growth', label:'Crecimiento (XP)', type:'mul', amount:0.15},
  {key:'greed', label:'Avaricia (monedas)', type:'mul', amount:0.15},
  {key:'luck', label:'Suerte', type:'mul', amount:0.12},
  {key:'cooldown', label:'Recarga (reducir)', type:'mul', amount:0.9} // multiply cd by 0.9 => faster
];

function randomChoices(count=3){
  const out = [];
  const copy = [...ALL_ATTRS];
  while(out.length < count && copy.length){
    const idx = Math.floor(rand(0,copy.length));
    out.push(copy.splice(idx,1)[0]);
  }
  return out;
}

function showLevelUpChoices(){
  const lvlDiv = document.getElementById('levelUp');
  const choicesDiv = document.getElementById('choices');
  choicesDiv.innerHTML = '';
  const choices = randomChoices(3);
  choices.forEach((c, i)=>{
    const btn = document.createElement('div');
    btn.className = 'choice';
    const sign = (c.type === 'mul' ? (c.amount>1?'+':'x') : '+');
    const text = `${c.label} ${c.type==='mul' ? (c.amount>1 ? `+${Math.round((c.amount-1)*100)}%` : `x${c.amount}`) : `+${c.amount}`}`;
    btn.innerHTML = `<strong>${text}</strong><div class="small">Aplicar</div>`;
    btn.onclick = ()=>{
      applyUpgrade(c);
      lvlDiv.style.display = 'none';
    };
    choicesDiv.appendChild(btn);
  });
  lvlDiv.style.display = 'block';
}

function applyUpgrade(up){
  const p = state.player;
  if(up.type === 'add'){
    p[up.key] = (p[up.key] || 0) + up.amount;
    if(up.key === 'maxHealth') p.currentHealth += up.amount;
  } else if(up.type === 'mul'){
    if(up.key === 'cooldown'){
      // special: multiply cooldown factor
      p.cooldown = (p.cooldown || 1) * up.amount;
    } else {
      p[up.key] = (p[up.key] || 1) + up.amount;
    }
  }
  // update debug
  document.getElementById('dbgLv').innerText = p.level;
  // immediate visual feedback: spawn some orbs as reward
  spawnOrb(p.position.x + rand(-20,20), p.position.y + rand(-20,20), 3);
}

// ---------- HUD rendering ----------
function updateHUD(){
  const p = state.player;
  // attrs list
  const attrsDiv = document.getElementById('attrs');
  attrsDiv.innerHTML = '';
  // show some selected attributes neatly
  const displayOrder = ['maxHealth','recovery','armor','moveSpeed','might','magnet','growth','greed','luck','cooldown'];
  displayOrder.forEach(key=>{
    const val = p[key];
    if(val === undefined) return;
    let txt = '';
    if(key === 'maxHealth') txt = `${Math.round(val)} HP`;
    else if(key === 'recovery') txt = `${(val*100).toFixed(1)}% /tick`;
    else if(key === 'armor') txt = `${Math.round(val)}`;
    else if(key === 'moveSpeed') txt = `${(val*100).toFixed(0)}%`;
    else if(key === 'might') txt = `${(val*100).toFixed(0)}%`;
    else if(key === 'magnet') txt = `r=${Math.round(40 + val*30)}px`;
    else if(key === 'growth') txt = `${(val*100).toFixed(0)}%`;
    else if(key === 'greed') txt = `${(val*100).toFixed(0)}%`;
    else if(key === 'luck') txt = `${(val*100).toFixed(0)}%`;
    else if(key === 'cooldown') txt = `${(val).toFixed(2)}x`;
    const el = document.createElement('div');
    el.className = 'attr';
    el.innerHTML = `<div style="color:#ddd">${translateAttr(key)}</div><div style="color:var(--accent)">${txt}</div>`;
    attrsDiv.appendChild(el);
  });
  document.getElementById('hpbar').innerText = `HP: ${Math.round(p.currentHealth)} / ${Math.round(p.maxHealth)}`;
  document.getElementById('xpbar').innerText = `XP: ${p.xp} / ${p.xpToNext} (Lv ${p.level})`;
  document.getElementById('dbgGold').innerText = state.coins;
}

function translateAttr(k){
  const map = {
    maxHealth:'Salud Máx', recovery:'Recuperación', armor:'Armadura', moveSpeed:'Velocidad',
    might:'Poder', magnet:'Imán', growth:'Crecimiento', greed:'Avaricia', luck:'Suerte', cooldown:'Recarga'
  };
  return map[k] || k;
}

// ---------- Draw ----------
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw orbs
  for(const o of state.orbs){
    ctx.beginPath();
    ctx.fillStyle = '#7ee6ff'; ctx.globalAlpha = 0.95;
    ctx.arc(o.x, o.y, 6, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
  }

  // draw enemies
  for(const e of state.enemies){
    ctx.beginPath();
    ctx.fillStyle = '#ff6b6b';
    ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = '11px Arial';
    ctx.fillText(e.hp, e.x-6, e.y+4);
  }

  // draw bullets
  for(const b of state.bullets){
    ctx.beginPath();
    ctx.fillStyle = '#ffd7a6';
    ctx.arc(b.x, b.y, 3, 0, Math.PI*2);
    ctx.fill();
  }

  // player
  const p = state.player;
  // magnet radius
  ctx.beginPath();
  ctx.strokeStyle = 'rgba(126,230,255,0.12)';
  ctx.lineWidth = 2;
  ctx.arc(p.position.x, p.position.y, 40 + (p.magnet || 1)*30, 0, Math.PI*2);
  ctx.stroke();

  // player body
  ctx.beginPath();
  ctx.fillStyle = '#9ad76b';
  ctx.arc(p.position.x, p.position.y, 12, 0, Math.PI*2);
  ctx.fill();

  // draw HUD text overlay near player
  ctx.fillStyle = '#fff';
  ctx.font = '12px Arial';
  ctx.fillText(CHARACTERS[document.getElementById('charSel').value].name, p.position.x-24, p.position.y-18);

  // crosshair
  ctx.beginPath();
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.moveTo(mouse.x-8, mouse.y); ctx.lineTo(mouse.x+8, mouse.y);
  ctx.moveTo(mouse.x, mouse.y-8); ctx.lineTo(mouse.x, mouse.y+8);
  ctx.stroke();

  // bottom-left mini info
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.fillRect(8, canvas.height-72, 220, 64);
  ctx.fillStyle = '#fff';
  ctx.font = '12px Arial';
  ctx.fillText(`Nivel ${p.level} • XP ${p.xp}/${p.xpToNext}`, 16, canvas.height-48);
  ctx.fillText(`Monedas: ${state.coins}`, 16, canvas.height-30);
}

// ---------- Main loop ----------
let last = performance.now();
function frame(t){
  const dt = t - last; last = t;
  update(dt);
  draw();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

// ---------- character switching ----------
document.getElementById('applyChar').onclick = ()=>{
  const key = document.getElementById('charSel').value;
  // keep level/xp/coins but replace base attributes
  const cur = state.player;
  const newp = createPlayer(key);
  // preserve level/xp/coins and current position
  newp.level = cur.level;
  newp.xp = cur.xp;
  newp.xpToNext = cur.xpToNext;
  newp.currentHealth = Math.min(newp.maxHealth, cur.currentHealth);
  newp.position = cur.position;
  newp.revival = cur.revival || newp.revival;
  state.player = newp;
  updateHUD();
};

// initial enemy spawns
for(let i=0;i<3;i++) spawnEnemy();
updateHUD();

// Hide level up if clicking outside
addEventListener('click', e=>{
  // prevent accidental clicks closing the menu - keep only inside choices handled
});

// Prevent context menu
addEventListener('contextmenu', e=> e.preventDefault());
</script>
</body>
</html>
