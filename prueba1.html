<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vampire Survival — Imán + Boss rebalanceado</title>
<style>
  :root{--hud-bg:rgba(0,0,0,0.55);--accent:#f1c40f;--muted:#999}
  html,body{height:100%;margin:0;background:#080808;color:#eee;font-family:Inter,Arial,Helvetica,sans-serif;overflow:hidden}
  canvas{display:block;background:linear-gradient(#111,#040404);width:100vw;height:100vh}

  /* TOP HUD */
  #topHUD{position:fixed;top:10px;left:50%;transform:translateX(-50%);width:760px;max-width:85vw;z-index:30}
  .row{display:flex;gap:10px;align-items:center}
  .box{background:var(--hud-bg);padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.06)}
  #bars{flex:1}
  .bar{height:18px;background:#222;border-radius:8px;overflow:hidden;position:relative;border:1px solid rgba(255,255,255,0.05)}
  .fill{height:100%;transition:width .18s linear}
  .hpFill{background:linear-gradient(90deg,#2ecc71,#27ae60)}
  .xpFill{background:linear-gradient(90deg,#f39c12,#e67e22)}

  /* Left HUD */
  #leftHUD{position:fixed;left:10px;top:50%;transform:translateY(-50%);z-index:35;display:flex;flex-direction:column;gap:8px}
  .weaponSlot{width:160px;background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);font-size:13px;display:flex;align-items:center;gap:8px}
  .weaponIcon{width:36px;height:36px;border-radius:6px;background:rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;font-weight:700;color:var(--muted)}
  .weaponInfo{flex:1}
  .weaponName{font-size:13px}
  .weaponLvl{font-size:12px;color:var(--muted)}

  /* Timer */
  #timer{position:fixed;top:12px;right:12px;background:var(--hud-bg);padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);z-index:40;font-size:14px}

  /* Level up & Death */
  #levelMenu,#deathPanel{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#111;padding:18px;border:2px solid #fff;border-radius:10px;z-index:50;display:none;min-width:320px}
  #levelMenu h2,#deathPanel h2{margin:0 0 8px}
  #levelMenu .choices{display:flex;flex-direction:column;gap:8px;margin-top:8px}
  button.choice{padding:10px;border-radius:8px;border:none;background:#222;color:#fff;cursor:pointer}
  button.choice:hover{background:#333}
  #deathPanel button{margin-top:10px;padding:8px 12px;border-radius:8px;border:none;background:#c0392b;color:white;cursor:pointer}

  /* Chest popup */
  #chestPopup{position:fixed;left:50%;top:20%;transform:translateX(-50%);z-index:60;background:linear-gradient(90deg,#222,#111);padding:12px 16px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);display:none}
  @keyframes chestGlow {0%{box-shadow:0 0 0 rgba(255,215,0,0)}50%{box-shadow:0 0 20px rgba(255,215,0,0.7)}100%{box-shadow:0 0 0 rgba(255,215,0,0)}}
  .chestAnim{animation: chestGlow 1s ease-in-out;}

  /* Debug */
  #debug{position:fixed;right:10px;bottom:10px;color:#999;font-size:12px;z-index:40}

  /* === MAIN MENU === */
  #mainMenu{
    position:fixed;
    top:0;left:0;width:100%;height:100%;
    background:rgba(0,0,0,0.65);
    z-index:100;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start;
    padding-top:60px;
    text-align:center;
  }
  #mainMenu h1{
    font-size:40px;
    letter-spacing:2px;
    margin-bottom:20px;
  }
  #btnStart{
    padding:10px 20px;
    font-size:16px;
    border:none;
    border-radius:8px;
    background:#222;
    color:#fff;
    cursor:pointer;
  }
  #btnStart:hover{background:#333}
</style>
</head>
<body>

<canvas id="c"></canvas>

<!-- Menú Principal -->
<div id="mainMenu">
  <h1>Vampire Survival</h1>
  <button class="menuButton" id="playBtn">Jugar</button>
  <button class="menuButton" id="infoBtn">Información</button>
</div>

<!-- Panel de Información -->
<div id="infoPanel" style="display:none;">
  <h2>Información del juego</h2>
  <p>Sobrevive a los vampiros y mejora tu personaje.</p>
  <button class="menuButton" id="backBtn">Volver</button>
</div>

<!-- Selección de personaje -->
<div id="characterSelect" style="display:none;">
  <h2>Selecciona tu personaje</h2>
  <button class="menuButton characterBtn" data-char="1">Personaje 1</button>
  <button class="menuButton characterBtn" data-char="2">Personaje 2</button>
</div>

<!-- Left HUD -->
<div id="leftHUD" aria-hidden="true"></div>

<!-- Top HUD -->
<div id="topHUD">
  <div class="row">
    <div class="box" style="min-width:220px">
      <div style="font-size:14px"><strong id="scoreText">Puntos: 0</strong></div>
      <div style="font-size:13px">Nivel <span id="levelText">1</span></div>
    </div>
    <div id="bars" class="box" style="display:flex;flex-direction:column;gap:6px">
      <div style="display:flex;gap:8px;align-items:center">
        <div style="width:80px">Vida</div>
        <div class="bar" style="flex:1"><div id="hpFill" class="fill hpFill" style="width:100%"></div></div>
        <div style="width:70px;text-align:right" id="hpText">100/100</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <div style="width:80px">XP</div>
        <div class="bar" style="flex:1"><div id="xpFill" class="fill xpFill" style="width:0%"></div></div>
        <div style="width:70px;text-align:right" id="xpText">0/15</div>
      </div>
    </div>
  </div>
</div>

<!-- Timer -->
<div id="timer">00:00</div>

<!-- Level Menu -->
<div id="levelMenu">
  <h2>¡Subiste de nivel!</h2>
  <div style="font-size:13px;color:#ccc">Elige una opción</div>
  <div class="choices" id="levelChoices"></div>
</div>

<!-- Death Panel -->
<div id="deathPanel">
  <h2>Has muerto</h2>
  <div id="deathScore"></div>
  <button id="btnRestart">Reiniciar</button>
</div>

<!-- Chest Popup -->
<div id="chestPopup"></div>

<div id="debug"></div>

<script>

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width=innerWidth; canvas.height=innerHeight; }
addEventListener('resize', resize);
resize();

/* ---------- Estado global ---------- */
let time = 0;           // ms desde inicio (juego)
let score = 0;
let xp = 0;
let level = 1;
let xpToNext = 15;
let gamePaused = false;
let dead = false;
let inMenu = true; // Pausar el juego mientras estás en el menú
let selectedCharacter = null;
  
/* ---------- Timer (display) ---------- */
let gameStartTimestamp = performance.now();
function formatTime(ms){
  const total = Math.floor(ms/1000);
  const mins = Math.floor(total/60);
  const secs = total % 60;
  return String(mins).padStart(2,'0') + ':' + String(secs).padStart(2,'0');
}

/* ---------- Player ---------- */
const player = {
  x: canvas.width/2,
  y: canvas.height/2,
  size: 18,
  speed: 3.2,
  hp: 100,
  maxHp: 100
};

/* ---------- Input ---------- */
const keys = {};
addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

/* ---------- Entities ---------- */
let bullets = [];
let enemies = [];
let orbs = [];
let meleeAttacks = [];
let boss = null;
let chests = [];
let lastSpawnTime = performance.now();
let lastBossSpawn = performance.now();

/* ---------- Boss schedule ---------- */
const BOSS_INTERVAL = 150000; // 150s => 2.5 minutes

/* ---------- Balance constants ---------- */
const BASE_SPAWN_INTERVAL = 1200; // ms between spawns
let spawnInterval = BASE_SPAWN_INTERVAL;

/* ---------- Utils ---------- */
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

const mainMenu = document.getElementById('mainMenu');
const infoPanel = document.getElementById('infoPanel');
const characterSelect = document.getElementById('characterSelect');

document.getElementById('playBtn').addEventListener('click', () => {
  mainMenu.style.display = 'none';
  characterSelect.style.display = 'flex';
});

document.getElementById('infoBtn').addEventListener('click', () => {
  mainMenu.style.display = 'none';
  infoPanel.style.display = 'flex';
});

document.getElementById('backBtn').addEventListener('click', () => {
  infoPanel.style.display = 'none';
  mainMenu.style.display = 'flex';
});

document.querySelectorAll('.characterBtn').forEach(btn => {
  btn.addEventListener('click', () => {
    selectedCharacter = btn.getAttribute('data-char');
    characterSelect.style.display = 'none';
    inMenu = false; // Comienza el juego
    startGame();
  });
});

/* ---------- Game loop ---------- */
let lastFrame = performance.now();

function gameLoop(now){
  const dt = now - lastFrame;
  lastFrame = now;

  // Solo actualizamos el juego si NO estamos en pausa, NO muertos y NO en menú
  if(!gamePaused && !dead && !inMenu){
    time += dt;

    // Update timer display
    timerEl.textContent = formatTime(performance.now() - gameStartTimestamp);

    // Spawn control
    spawnInterval = Math.max(400, BASE_SPAWN_INTERVAL - Math.floor(time/10000)*20);
    if(now - lastSpawnTime > spawnInterval){
      lastSpawnTime = now;
      if(enemies.length < 30) spawnEnemy();
    }

    // Boss spawn logic
    if(!boss && (now - lastBossSpawn > BOSS_INTERVAL)){
      spawnBoss();
      lastBossSpawn = now;
    }

    // Player movement
    updatePlayer(dt);

    // Weapons auto actions
    if(weaponsState.pistol.level) weaponsLib.pistol.shoot(weaponsState.pistol);
    if(weaponsState.sword.level) weaponsLib.sword.attack(weaponsState.sword);
    if(weaponsState.staff.level) weaponsLib.staff.shoot(weaponsState.staff);
    if(weaponsState.fireball.level) weaponsLib.fireball.shoot(weaponsState.fireball);
    if(weaponsState.bible.level) weaponsLib.bible.update(weaponsState.bible, dt);
    if(weaponsState.potion.level) weaponsLib.potion.tick(weaponsState.potion);
    if(weaponsState.magnet.level) weaponsLib.magnet.update(weaponsState.magnet, dt);

    // Update entities
    updateBullets(dt);
    updateMelee(dt);
    updateEnemies(dt);
    updateSolar(now);
    updateOrbs();
    updateChests();

    // Boss behavior
    if(boss) updateBoss(dt);
  }

  // Render always (para que se vea el menú)
  render();
  updateHUD();

  requestAnimationFrame(gameLoop);
}

// Start the loop
requestAnimationFrame(gameLoop);


function updateGame() {
  // Aquí va la lógica del juego
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // --- Solar areas ---
  if (weaponsState.solar.level) {
    const s = weaponsLib.solar.statsForLevel(weaponsState.solar.level);
    ctx.fillStyle = 'rgba(255,200,50,0.06)';
    weaponsState.solar.areas.forEach(a => {
      ctx.beginPath();
      ctx.arc(a.x, a.y, s.radius, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  // --- Orbs ---
  for (const o of orbs) {
    ctx.fillStyle = '#f1c40f';
    ctx.beginPath();
    ctx.arc(o.x, o.y, 6, 0, Math.PI * 2);
    ctx.fill();
  }

  // --- Chests ---
  for (const c of chests) {
    ctx.save();
    ctx.translate(c.x, c.y);
    const wob = Math.sin((performance.now() + c.offset) / 200) * 4;
    ctx.fillStyle = '#7f5f3f';
    ctx.beginPath();
    ctx.rect(-14, -10 + wob, 28, 20);
    ctx.fill();
    ctx.fillStyle = '#b88a3b';
    ctx.beginPath();
    ctx.rect(-14, -16 + wob, 28, 8);
    ctx.fill();
    ctx.restore();
  }

  // --- Enemies ---
  for (const e of enemies) {
    ctx.fillStyle = e.color || '#c0392b';
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = '11px sans-serif';
    ctx.fillText(Math.max(0, Math.round(e.hp)), e.x - 8, e.y - e.size - 4);
  }

  // --- Bullets ---
  for (const b of bullets) {
    if (b.type === 'pistol') ctx.fillStyle = '#fff59d';
    else if (b.type === 'staff') ctx.fillStyle = '#9b59b6';
    else if (b.type === 'fireball') ctx.fillStyle = '#ff6b6b';
    else ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size || 4, 0, Math.PI * 2);
    ctx.fill();
  }

  // --- Bible orbiters ---
  if (weaponsState.bible.level) {
    const s = weaponsLib.bible.statsForLevel(weaponsState.bible.level);
    const state = weaponsState.bible;
    for (const o of state.orbiters || []) {
      const ox = player.x + Math.cos(o.angle) * s.radius;
      const oy = player.y + Math.sin(o.angle) * s.radius;
      ctx.fillStyle = 'rgba(200,230,255,0.95)';
      ctx.beginPath();
      ctx.arc(ox, oy, 6, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // --- Melee arcs ---
  for (const m of meleeAttacks) {
    ctx.beginPath();
    ctx.moveTo(m.x, m.y);
    ctx.arc(m.x, m.y, m.range, m.angle - m.arc / 2, m.angle + m.arc / 2);
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fill();
  }

  // --- Boss ---
  if (boss) {
    ctx.fillStyle = boss.color || '#8e44ad';
    ctx.beginPath();
    ctx.arc(boss.x, boss.y, boss.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = '14px sans-serif';
    ctx.fillText(Math.max(0, Math.round(boss.hp)), boss.x - 14, boss.y - boss.size - 6);
  }

  // --- Player ---
  ctx.fillStyle = '#3498db';
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.stroke();
}


function startGame() {
  console.log("Juego iniciado con personaje:", selectedCharacter);
  // Reiniciar estado global
  dead = false;
  gamePaused = false;
  inMenu = false;
  time = 0;
  score = 0;
  xp = 0;
  level = 1;
  xpToNext = 15;
  bullets = [];
  enemies = [];
  orbs = [];
  meleeAttacks = [];
  chests = [];
  boss = null;
  gameStartTimestamp = performance.now();
  
  // Reiniciar armas
  for(const id in weaponsState){
    weaponsState[id].level = id === 'pistol' ? 1 : 0;
    if(id === 'bible') weaponsState.bible.orbiters = [];
    if(id === 'sword') weaponsState.sword.lastAttack = 0;
    if(id === 'staff') weaponsState.staff.lastShot = 0;
    if(id === 'fireball') weaponsState.fireball.lastShot = 0;
    if(id === 'potion') weaponsState.potion.lastHeal = 0;
    if(id === 'pistol') weaponsState.pistol.lastShot = 0;
    if(id === 'magnet') weaponsState.magnet.level = 0;
    if(id === 'solar') weaponsState.solar.areas = [];
  }

  updateHUD();
}

  
/* ---------- Weapons library (add magnet) ---------- */
const weaponsLib = {};
/* PISTOLA */
weaponsLib.pistol = {
  id: 'pistol', name: 'Pistola', maxLevel: 10,
  statsForLevel(level){
    const baseInterval = 500;
    const interval = Math.max(120, Math.round(baseInterval - (level-1)*40));
    const bulletsCount = 1 + Math.floor((level-1)/3);
    const damage = 2 + Math.floor((level-1)/4);
    const speed = 5 + (level-1)*0.3;
    const size = 3 + Math.floor((level-1)/6);
    return { interval, bulletsCount, damage, speed, size };
  },
  shoot(state){
    if(gamePaused || !state.level) return;
    const now = performance.now();
    const s = weaponsLib.pistol.statsForLevel(state.level);
    if(now - (state.lastShot||0) < s.interval) return;
    state.lastShot = now;
    if(!enemies.length && !boss) return;
    const pool = boss ? enemies.concat([boss]) : enemies;
    const target = pool.reduce((a,b)=> dist(a,player) < dist(b,player) ? a : b);
    const ang = Math.atan2(target.y - player.y, target.x - player.x);
    const total = s.bulletsCount;
    const spread = (total > 1) ? 0.18 : 0;
    const step = total > 1 ? spread/(total-1) : 0;
    const start = ang - spread/2;
    for(let i=0;i<total;i++){
      const a = start + step*i;
      bullets.push({
        x: player.x, y: player.y,
        dx: Math.cos(a)*s.speed, dy: Math.sin(a)*s.speed,
        damage: s.damage, size: s.size, life: 3000, friendly:true, type:'pistol'
      });
    }
  }
};
/* SOLAR */
weaponsLib.solar = {
  id:'solar', name:'Área Solar', maxLevel:10,
  statsForLevel(level){
    const radius = Math.round(40 + (level-1)*12);
    const damage = 3 + Math.floor((level-1)*1.2);
    const tick = Math.max(180, Math.round(420 - (level-1)*24));
    return { radius, damage, tick };
  }
};
/* SWORD */
weaponsLib.sword = {
  id:'sword', name:'Espada', maxLevel:10,
  statsForLevel(level){
    const arc = Math.PI/3 - (level-1)*0.02;
    const range = 36 + Math.floor((level-1)*3);
    const damage = 6 + Math.floor((level-1)*1.2);
    const interval = Math.max(250, 450 - (level-1)*20);
    return { arc, range, damage, interval };
  },
  attack(state){
    if(gamePaused || !state.level) return;
    const now = performance.now();
    const s = weaponsLib.sword.statsForLevel(state.level);
    if(now - (state.lastAttack||0) < s.interval) return;
    state.lastAttack = now;
    if(enemies.length === 0 && !boss){
      meleeAttacks.push({ x:player.x, y:player.y, angle:0, arc:s.arc, range:s.range, damage:s.damage, life:120 });
      return;
    }
    const pool = boss ? enemies.concat([boss]) : enemies;
    const target = pool.reduce((a,b)=> dist(a,player) < dist(b,player) ? a : b);
    const ang = Math.atan2(target.y - player.y, target.x - player.x);
    meleeAttacks.push({ x:player.x, y:player.y, angle:ang, arc:s.arc, range:s.range, damage:s.damage, life:120 });
  }
};
/* STAFF */
weaponsLib.staff = {
  id:'staff', name:'Bastón', maxLevel:10,
  statsForLevel(level){
    const interval = Math.max(600, 1400 - (level-1)*90);
    const damage = 12 + Math.floor((level-1)*2.2);
    const speed = 2.2 + (level-1)*0.15;
    const size = 6 + Math.floor((level-1)/3);
    return { interval, damage, speed, size };
  },
  shoot(state){
    if(gamePaused || !state.level) return;
    const now = performance.now();
    const s = weaponsLib.staff.statsForLevel(state.level);
    if(now - (state.lastShot||0) < s.interval) return;
    state.lastShot = now;
    if(!enemies.length && !boss) return;
    const pool = boss ? enemies.concat([boss]) : enemies;
    const target = pool.reduce((a,b)=> dist(a,player) < dist(b,player) ? a : b);
    const ang = Math.atan2(target.y - player.y, target.x - player.x);
    bullets.push({
      x: player.x, y: player.y,
      dx: Math.cos(ang)*s.speed, dy: Math.sin(ang)*s.speed,
      damage: s.damage, size: s.size, life: 4000, friendly:true, type:'staff'
    });
  }
};
/* FIREBALL */
weaponsLib.fireball = {
  id:'fireball', name:'Bolas de Fuego', maxLevel:10,
  statsForLevel(level){
    const interval = Math.max(1100, 2500 - (level-1)*140);
    const damage = 8 + Math.floor((level-1)*1.6);
    const speed = 3.2 + (level-1)*0.18;
    const size = 5 + Math.floor((level-1)/4);
    const homingStrength = 0.12 + (level-1)*0.01;
    return { interval, damage, speed, size, homingStrength };
  },
  shoot(state){
    if(gamePaused || !state.level) return;
    const now = performance.now();
    const s = weaponsLib.fireball.statsForLevel(state.level);
    if(now - (state.lastShot||0) < s.interval) return;
    state.lastShot = now;
    bullets.push({
      x: player.x, y: player.y,
      dx: 0, dy: -s.speed,
      damage: s.damage, size: s.size, life: 5000, friendly:true,
      homing: true, homingStrength: s.homingStrength, speed: s.speed, type:'fireball'
    });
  }
};
/* BIBLE */
weaponsLib.bible = {
  id:'bible', name:'Biblia', maxLevel:10,
  statsForLevel(level){
    const count = 2 + Math.floor((level-1)/2);
    const radius = 36 + Math.floor((level-1)*3);
    const damage = 4 + Math.floor((level-1)*1.1);
    const speed = 0.02 + (level-1)*0.0025;
    return { count, radius, damage, speed };
  },
  ensureOrbiters(state){
    if(!state.level) return;
    const s = weaponsLib.bible.statsForLevel(state.level);
    state.orbiters = state.orbiters || [];
    while(state.orbiters.length < s.count) state.orbiters.push({ angle: Math.random()*Math.PI*2 });
  },
  update(state, dt){
    if(!state.level) return;
    state.orbiters = state.orbiters || [];
    const s = weaponsLib.bible.statsForLevel(state.level);
    while(state.orbiters.length < s.count) state.orbiters.push({ angle: Math.random()*Math.PI*2 });
    for(const o of state.orbiters){
      o.angle += s.speed * dt;
      const ox = player.x + Math.cos(o.angle) * s.radius;
      const oy = player.y + Math.sin(o.angle) * s.radius;
      for(let i=enemies.length-1;i>=0;i--){
        const e = enemies[i];
        if(Math.hypot(e.x-ox,e.y-oy) < e.size + 8){
          e.hp -= s.damage;
          if(e.hp <= 0){
            spawnOrbAt(e.x,e.y);
            enemies.splice(i,1);
            score += 1;
          }
        }
      }
      // also hit boss
      if(boss){
        if(Math.hypot(boss.x-ox, boss.y-oy) < boss.size + 8){
          boss.hp -= s.damage;
          if(boss.hp <= 0) killBoss();
        }
      }
    }
  }
};
/* POTION */
weaponsLib.potion = {
  id:'potion', name:'Pociones', maxLevel:10,
  statsForLevel(level){
    const healAmount = 6 + Math.floor((level-1)*1.6);
    const interval = Math.max(3500, 9000 - (level-1)*500);
    return { healAmount, interval };
  },
  tick(state){
    if(!state.level) return;
    const now = performance.now();
    const s = weaponsLib.potion.statsForLevel(state.level);
    if(now - (state.lastHeal||0) < s.interval) return;
    state.lastHeal = now;
    player.hp = Math.min(player.maxHp, player.hp + s.healAmount);
  }
};
/* MAGNET (nueva habilidad) - invisible efecto */
weaponsLib.magnet = {
  id:'magnet', name:'Imán', maxLevel:10,
  statsForLevel(level){
    // radius grows with level; pullStrength controls how fast orbs move toward player
    const radius = 90 + (level-1)*26; // lvl1=90, lvl5=194, lvl10=324
    const pullStrength = 0.025 + (level-1)*0.01; // per frame factor (scaled by dt)
    return { radius, pullStrength };
  },
  update(state, dt){
    if(!state.level) return;
    const s = weaponsLib.magnet.statsForLevel(state.level);
    // attract orbs within radius
    for(const o of orbs){
      const d = Math.hypot(o.x - player.x, o.y - player.y);
      if(d <= s.radius){
        // move orb towards player; stronger as it is closer
        const k = s.pullStrength * (dt/16);
        o.x += (player.x - o.x) * k * 1.2;
        o.y += (player.y - o.y) * k * 1.2;
      }
    }
  }
};

/* ---------- Weapons state (add magnet) ---------- */
const weaponsState = {
  pistol: { level: 1, lastShot: 0 },
  solar: { level: 0, lastTick: 0, areas: [] },
  sword: { level: 0, lastAttack: 0 },
  staff: { level: 0, lastShot: 0 },
  fireball: { level: 0, lastShot: 0 },
  bible: { level: 0, orbiters: [] },
  potion: { level: 0, lastHeal: 0 },
  magnet: { level: 0 } // nueva habilidad
};

/* ---------- Spawning enemies & orbs ---------- */
function spawnEnemy(){
  const edge = Math.floor(Math.random()*4);
  let x = edge===0 ? -20 : edge===1 ? canvas.width+20 : Math.random()*canvas.width;
  let y = edge===2 ? -20 : edge===3 ? canvas.height+20 : Math.random()*canvas.height;
  const easyWindow = 120000;
  let hp = time < easyWindow ? 3 : 3 + Math.floor(time/90000);
  const speed = 0.6 + Math.random()*1.0 + Math.min(1.2, time/120000);
  const size = 10 + Math.random()*10;
  enemies.push({ x,y, hp, speed, size, color:'#c0392b' });
}
function spawnOrbAt(x,y){
  const value = 1 + Math.floor(Math.random()*2);
  orbs.push({ x,y, value });
}

/* ---------- Level menu (include magnet in candidates) ---------- */
function openLevelMenu(){
  gamePaused = true;
  const menu = document.getElementById('levelMenu');
  const choicesDiv = document.getElementById('levelChoices');
  choicesDiv.innerHTML = '';
  const candidates = [];
  for(const id in weaponsLib){
    const curLevel = weaponsState[id].level || 0;
    if(curLevel < weaponsLib[id].maxLevel) candidates.push({ type:'weapon', id });
  }
  const genericBonuses = [
    { type:'bonus', id:'hpUp', name:'Más vida (+10)' },
    { type:'bonus', id:'speed', name:'Velocidad +0.3' },
    { type:'bonus', id:'xpBoost', name:'Más XP (orb +1)' }
  ];
  const pool = [...candidates];
  while(pool.length < 6) pool.push(randChoice(genericBonuses));
  const picks = [];
  while(picks.length < 3){
    const p = randChoice(pool);
    if(!picks.find(x=>x.type===p.type && x.id===p.id)) picks.push(p);
  }
  picks.forEach(p=>{
    const btn = document.createElement('button');
    btn.className = 'choice';
    if(p.type === 'weapon'){
      const lvl = weaponsState[p.id].level || 0;
      btn.textContent = `${weaponsLib[p.id].name} ${lvl?('(Lv '+lvl+')'):''}`;
      btn.onclick = ()=>{
        weaponsState[p.id].level = Math.min(weaponsLib[p.id].maxLevel, (weaponsState[p.id].level||0) + 1);
        applyWeaponLevelEffects(p.id);
        closeLevelMenu();
      };
    } else {
      btn.textContent = p.name;
      btn.onclick = ()=>{
        applyGenericBonus(p.id);
        closeLevelMenu();
      };
    }
    choicesDiv.appendChild(btn);
  });
  menu.style.display = 'block';
}
function closeLevelMenu(){
  document.getElementById('levelMenu').style.display = 'none';
  gamePaused = false;
  updateHUD();
}

/* ---------- Apply weapon-level immediate effects ---------- */
function applyWeaponLevelEffects(id){
  if(id === 'solar'){
    if(weaponsState.solar.level === 1){
      weaponsState.solar.areas.push({ x: player.x, y: player.y, since: performance.now() });
    }
  }
  if(id === 'bible'){
    weaponsLib.bible.ensureOrbiters(weaponsState.bible);
  }
  // magnet has no visual immediate effect (invisible) — behavior is in update loop
}

/* ---------- Generic bonuses ---------- */
function applyGenericBonus(id){
  if(id === 'hpUp'){ player.maxHp += 10; player.hp = player.maxHp; }
  if(id === 'speed'){ player.speed += 0.3; }
  if(id === 'xpBoost'){ weaponsState.__xpBoost = (weaponsState.__xpBoost||0) + 5; }
}

/* ---------- HUD updates (left column and top) ---------- */
const hpFill = document.getElementById('hpFill');
const xpFill = document.getElementById('xpFill');
const xpText = document.getElementById('xpText');
const hpText = document.getElementById('hpText');
const levelText = document.getElementById('levelText');
const scoreText = document.getElementById('scoreText');
const leftHUD = document.getElementById('leftHUD');
const timerEl = document.getElementById('timer');
const chestPopup = document.getElementById('chestPopup');

function updateHUD(){
  const pct = Math.max(0, Math.min(1, player.hp / player.maxHp));
  hpFill.style.width = (pct*100)+'%';
  hpText.textContent = Math.round(player.hp)+' / '+player.maxHp;
  xpFill.style.width = Math.min(100, (xp/xpToNext)*100)+'%';
  xpText.textContent = Math.floor(xp)+' / '+xpToNext;
  levelText.textContent = level;
  scoreText.textContent = 'Puntos: '+score;
  renderLeftHUD();
}
function renderLeftHUD(){
  leftHUD.innerHTML = '';
  // order: pistol, sword, staff, fireball, bible, potion, magnet, solar
  const order = ['pistol','sword','staff','fireball','bible','potion','magnet','solar'];
  for(const id of order){
    const lvl = weaponsState[id].level || 0;
    const slot = document.createElement('div');
    slot.className = 'weaponSlot';
    slot.style.opacity = lvl?1:0.4;
    const icon = document.createElement('div');
    icon.className = 'weaponIcon';
    icon.textContent = id.charAt(0).toUpperCase();
    const info = document.createElement('div');
    info.className = 'weaponInfo';
    const name = document.createElement('div');
    name.className = 'weaponName';
    name.textContent = weaponsLib[id].name;
    const lvldiv = document.createElement('div');
    lvldiv.className = 'weaponLvl';
    lvldiv.textContent = lvl ? `Lv ${lvl}` : 'No equipado';
    info.appendChild(name);
    info.appendChild(lvldiv);
    slot.appendChild(icon);
    slot.appendChild(info);
    leftHUD.appendChild(slot);
  }
}

/* ---------- Game loop ---------- */
let lastFrame = performance.now();
function gameLoop(now){
  const dt = now - lastFrame;
  lastFrame = now;
  if(!gamePaused && !dead){
    time += dt;
    // update timer display
    timerEl.textContent = formatTime(performance.now() - gameStartTimestamp);
    // spawn control
    spawnInterval = Math.max(400, BASE_SPAWN_INTERVAL - Math.floor(time/10000)*20);
    if(now - lastSpawnTime > spawnInterval){
      lastSpawnTime = now;
      if(enemies.length < 30) spawnEnemy();
    }
    // boss spawn logic
    if(!boss && (now - lastBossSpawn > BOSS_INTERVAL)){
      spawnBoss();
      lastBossSpawn = now;
    }
    // movement
    updatePlayer(dt);
    // weapons auto actions
    if(weaponsState.pistol.level) weaponsLib.pistol.shoot(weaponsState.pistol);
    if(weaponsState.sword.level) weaponsLib.sword.attack(weaponsState.sword);
    if(weaponsState.staff.level) weaponsLib.staff.shoot(weaponsState.staff);
    if(weaponsState.fireball.level) weaponsLib.fireball.shoot(weaponsState.fireball);
    if(weaponsState.bible.level) weaponsLib.bible.update(weaponsState.bible, dt);
    if(weaponsState.potion.level) weaponsLib.potion.tick(weaponsState.potion);
    if(weaponsState.magnet.level) weaponsLib.magnet.update(weaponsState.magnet, dt);
    // bullets
    updateBullets(dt);
    // melee
    updateMelee(dt);
    // enemies
    updateEnemies(dt);
    // solar
    updateSolar(now);
    // orbs & chests pickup
    updateOrbs();
    updateChests();
    // boss behavior
    if(boss) updateBoss(dt);
  }
  render();
  updateHUD();
  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

/* ---------- Updates (detailed) ---------- */

function updatePlayer(dt){
  if(keys['w'] || keys['arrowup']) player.y -= player.speed;
  if(keys['s'] || keys['arrowdown']) player.y += player.speed;
  if(keys['a'] || keys['arrowleft']) player.x -= player.speed;
  if(keys['d'] || keys['arrowright']) player.x += player.speed;
  player.x = clamp(player.x, 0, canvas.width);
  player.y = clamp(player.y, 0, canvas.height);
  if(weaponsState.solar.level){
    weaponsState.solar.areas.forEach(a => { a.x = player.x; a.y = player.y; });
  }
}

function updateBullets(dt){
  for(let i = bullets.length-1; i>=0; i--){
    const b = bullets[i];
    if(b.homing){
      if(enemies.length || boss){
        const pool = boss ? enemies.concat([boss]) : enemies;
        const target = pool.reduce((a,b2)=> dist(a,b) < dist(b2,b) ? a : b2);
        const angTo = Math.atan2(target.y - b.y, target.x - b.x);
        const curAng = Math.atan2(b.dy, b.dx);
        let newAng = curAng + ( (angTo - curAng) * (b.homingStrength || 0.12) );
        b.dx = Math.cos(newAng) * b.speed;
        b.dy = Math.sin(newAng) * b.speed;
      }
    }
    b.x += b.dx * (dt/16);
    b.y += b.dy * (dt/16);
    b.life -= dt;
    if(b.life <= 0 || b.x < -60 || b.x > canvas.width+60 || b.y < -60 || b.y > canvas.height+60){ bullets.splice(i,1); continue; }
    // collide with enemies
    for(let j = enemies.length-1; j>=0; j--){
      const e = enemies[j];
      if(Math.hypot(b.x - e.x, b.y - e.y) < e.size + (b.size||4)){
        e.hp -= b.damage;
        bullets.splice(i,1);
        if(e.hp <= 0){
          spawnOrbAt(e.x, e.y);
          enemies.splice(j,1);
          score += 1;
        }
        break;
      }
    }
    // collide with boss
    if(boss && Math.hypot(b.x - boss.x, b.y - boss.y) < boss.size + (b.size||4)){
      boss.hp -= b.damage;
      bullets.splice(i,1);
      if(boss.hp <= 0) killBoss();
      continue;
    }
  }
}

function updateMelee(dt){
  for(let i = meleeAttacks.length-1; i>=0; i--){
    const m = meleeAttacks[i];
    m.life -= dt;
    for(let j = enemies.length-1; j>=0; j--){
      const e = enemies[j];
      const angToE = Math.atan2(e.y - m.y, e.x - m.x);
      let diff = Math.abs(((angToE - m.angle + Math.PI) % (2*Math.PI)) - Math.PI);
      if(diff <= m.arc/2 && dist(e,m) <= m.range + e.size){
        e.hp -= m.damage;
        e.x += Math.cos(angToE)*6;
        e.y += Math.sin(angToE)*6;
        if(e.hp <= 0){
          spawnOrbAt(e.x, e.y);
          enemies.splice(j,1);
          score += 1;
        }
      }
    }
    // melee vs boss
    if(boss){
      const angToB = Math.atan2(boss.y - m.y, boss.x - m.x);
      let diffB = Math.abs(((angToB - m.angle + Math.PI) % (2*Math.PI)) - Math.PI);
      if(diffB <= m.arc/2 && dist(boss,m) <= m.range + boss.size){
        boss.hp -= m.damage;
        if(boss.hp <= 0) killBoss();
      }
    }
    if(m.life <= 0) meleeAttacks.splice(i,1);
  }
}

function updateEnemies(dt){
  for(let i = enemies.length-1; i>=0; i--){
    const e = enemies[i];
    const a = Math.atan2(player.y - e.y, player.x - e.x);
    e.x += Math.cos(a) * e.speed * (dt/16);
    e.y += Math.sin(a) * e.speed * (dt/16);
    if(dist(e,player) < player.size + e.size){
      player.hp -= 8 * (dt/16);
      if(player.hp <= 0) onDeath();
      spawnOrbAt(e.x, e.y);
      enemies.splice(i,1);
    }
  }
}

/* ---------- Solar ---------- */
function updateSolar(now){
  if(!weaponsState.solar.level) return;
  const lvl = weaponsState.solar.level;
  const s = weaponsLib.solar.statsForLevel(lvl);
  if(!weaponsState.solar.lastTick) weaponsState.solar.lastTick = 0;
  if(now - weaponsState.solar.lastTick < s.tick) return;
  weaponsState.solar.lastTick = now;
  weaponsState.solar.areas.forEach(area=>{
    for(let i = enemies.length-1; i>=0; i--){
      const e = enemies[i];
      if(dist(e, area) < s.radius){
        e.hp -= s.damage;
        if(e.hp <= 0){
          spawnOrbAt(e.x, e.y);
          enemies.splice(i,1);
          score += 1;
        }
      }
    }
    if(boss && dist(boss, area) < s.radius){
      boss.hp -= s.damage;
      if(boss.hp <= 0) killBoss();
    }
  });
}

/* ---------- Orbs & Chests ---------- */
function updateOrbs(){
  // orbs may be attracted by magnet (weaponsLib.magnet.update was already called before)
  for(let i = orbs.length-1; i>=0; i--){
    const o = orbs[i];
    // small idle movement toward ground? keep static unless magnet
    // pickup check
    if(dist(o, player) < player.size + 10){
      let gain = o.value;
      if(weaponsState.__xpBoost && weaponsState.__xpBoost > 0){ gain += 1; weaponsState.__xpBoost--; }
      xp += gain;
      orbs.splice(i,1);
      if(xp >= xpToNext) levelUp();
    } else {
      // subtle slow drift towards player if no magnet but close to player (makes pickup smoother)
      const d = Math.hypot(o.x - player.x, o.y - player.y);
      if(d < 32){
        o.x += (player.x - o.x) * 0.06;
        o.y += (player.y - o.y) * 0.06;
      }
    }
  }
}
function updateChests(){
  for(let i = chests.length-1; i>=0; i--){
    const c = chests[i];
    c.y -= Math.sin((performance.now()+c.offset)/300)*0.04;
    if(dist(c, player) < player.size + 18){
      applyChestReward(c);
      showChestPopup(`¡Cofre abierto! ${c.rewardText || ''}`);
      chests.splice(i,1);
      continue;
    }
    if(performance.now() - c.spawned > 30000) chests.splice(i,1);
  }
}

/* ---------- Boss logic (Tipo A: bruto, re-balanceado) ---------- */
function spawnBoss(){
  const side = Math.random() < 0.5 ? -1 : 1;
  const x = side === -1 ? -120 : canvas.width + 120;
  const y = Math.random()*canvas.height;
  const minutes = Math.floor((performance.now()-gameStartTimestamp)/60000);
  // ORIGINAL: baseHp 200 + minutes*60 -> reduce ~40%: multiply by 0.6
  const baseHp = Math.round((200 + minutes*60) * 0.6); // ~120 + minutes*36
  const baseSize = 48 + minutes*6;
  const speed = 0.35 + Math.random()*0.35;
  // reduced damage on contact: original 28 -> ~9
  boss = { x, y, hp: baseHp, maxHp: baseHp, size: baseSize, speed, color:'#8e44ad', spawned: performance.now(), contactDamage: 9 };
}
function updateBoss(dt){
  if(!boss) return;
  const ang = Math.atan2(player.y - boss.y, player.x - boss.x);
  boss.x += Math.cos(ang) * boss.speed * (dt/16);
  boss.y += Math.sin(ang) * boss.speed * (dt/16);
  if(dist(boss, player) < player.size + boss.size){
    // reduced damage, scaled with dt
    player.hp -= boss.contactDamage * (dt/16);
    if(player.hp <= 0) onDeath();
  }
}
function killBoss(){
  if(!boss) return;
  chests.push({ x: boss.x, y: boss.y, spawned: performance.now(), offset: Math.random()*9999 });
  boss = null;
}

/* Apply chest reward: level up random owned weapon (includes magnet) */
function applyChestReward(chest){
  const owned = Object.keys(weaponsState).filter(k => (weaponsState[k].level||0) > 0 && weaponsState[k].level < (weaponsLib[k].maxLevel||10));
  if(owned.length){
    const pick = randChoice(owned);
    weaponsState[pick].level = Math.min(weaponsLib[pick].maxLevel, weaponsState[pick].level + 1);
    applyWeaponLevelEffects(pick);
    chest.rewardText = `${weaponsLib[pick].name} +1 nivel`;
  } else {
    player.hp = Math.min(player.maxHp, player.hp + 25);
    chest.rewardText = `Vida +25 (fallback)`;
  }
}

/* UI popup for chest (simple) */
let chestPopupTimeout = null;
function showChestPopup(text){
  chestPopup.textContent = text;
  chestPopup.style.display = 'block';
  chestPopup.classList.add('chestAnim');
  if(chestPopupTimeout) clearTimeout(chestPopupTimeout);
  chestPopupTimeout = setTimeout(()=>{
    chestPopup.style.display = 'none';
    chestPopup.classList.remove('chestAnim');
  }, 2200);
}

/* ---------- Level up flow ---------- */
function levelUp(){
  level++;
  xp = xp - xpToNext;
  xpToNext = Math.max(5, Math.floor(xpToNext * 1.22));
  player.hp = Math.min(player.maxHp, player.hp + 10);
  openLevelMenu();
}

/* ---------- Death ---------- */
function onDeath(){
  dead = true;
  gamePaused = true;
  const dp = document.getElementById('deathPanel');
  dp.style.display = 'block';
  document.getElementById('deathScore').textContent = 'Puntos: '+score+' | Nivel alcanzado: '+level;
}
document.getElementById('btnRestart').onclick = ()=>{
  location.reload();
};

/* ---------- Rendering ---------- */
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // solar
  if(weaponsState.solar.level){
    const s = weaponsLib.solar.statsForLevel(weaponsState.solar.level);
    ctx.fillStyle = 'rgba(255,200,50,0.06)';
    weaponsState.solar.areas.forEach(a=>{
      ctx.beginPath(); ctx.arc(a.x, a.y, s.radius, 0, Math.PI*2); ctx.fill();
    });
  }
  // orbs
  for(const o of orbs){
    ctx.fillStyle = '#f1c40f';
    ctx.beginPath(); ctx.arc(o.x, o.y, 6, 0, Math.PI*2); ctx.fill();
  }
  // chests
  for(const c of chests){
    ctx.save();
    ctx.translate(c.x, c.y);
    const wob = Math.sin((performance.now()+c.offset)/200)*4;
    ctx.fillStyle = '#7f5f3f';
    ctx.beginPath(); ctx.rect(-14, -10 + wob, 28, 20); ctx.fill();
    ctx.fillStyle = '#b88a3b';
    ctx.beginPath(); ctx.rect(-14, -16 + wob, 28, 8); ctx.fill();
    ctx.restore();
  }
  // enemies
  for(const e of enemies){
    ctx.fillStyle = e.color || '#c0392b';
    ctx.beginPath(); ctx.arc(e.x, e.y, e.size, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font = '11px sans-serif'; ctx.fillText(Math.max(0,Math.round(e.hp)), e.x - 8, e.y - e.size - 4);
  }
  // bullets
  for(const b of bullets){
    if(b.type === 'pistol'){ ctx.fillStyle = '#fff59d'; }
    else if(b.type === 'staff') { ctx.fillStyle = '#9b59b6'; }
    else if(b.type === 'fireball'){ ctx.fillStyle = '#ff6b6b'; }
    else ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(b.x, b.y, b.size || 4, 0, Math.PI*2); ctx.fill();
  }
  // orbiters (bible)
  if(weaponsState.bible.level){
    const s = weaponsLib.bible.statsForLevel(weaponsState.bible.level);
    const state = weaponsState.bible;
    for(const o of state.orbiters || []){
      const ox = player.x + Math.cos(o.angle) * s.radius;
      const oy = player.y + Math.sin(o.angle) * s.radius;
      ctx.fillStyle = 'rgba(200,230,255,0.95)';
      ctx.beginPath(); ctx.arc(ox, oy, 6, 0, Math.PI*2); ctx.fill();
    }
  }
  // melee arcs
  for(const m of meleeAttacks){
    ctx.beginPath();
    ctx.moveTo(m.x, m.y);
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.arc(m.x, m.y, m.range, m.angle - m.arc/2, m.angle + m.arc/2);
    ctx.fill();
  }
  // boss (if any)
  if(boss){
    ctx.fillStyle = boss.color;
    ctx.beginPath(); ctx.arc(boss.x, boss.y, boss.size, 0, Math.PI*2); ctx.fill();
    const barW = boss.size*2;
    const pct = Math.max(0, boss.hp / boss.maxHp);
    ctx.fillStyle = '#111'; ctx.fillRect(boss.x - boss.size, boss.y - boss.size - 14, barW, 8);
    ctx.fillStyle = '#e74c3c'; ctx.fillRect(boss.x - boss.size, boss.y - boss.size - 14, barW * pct, 8);
    ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.strokeRect(boss.x - boss.size, boss.y - boss.size - 14, barW, 8);
  }
  // player
  ctx.fillStyle = '#3ddc84';
  ctx.beginPath(); ctx.arc(player.x, player.y, player.size, 0, Math.PI*2); ctx.fill();
}

/* ---------- Small debug ---------- */
const debugEl = document.getElementById('debug');
setInterval(()=> {
  debugEl.textContent = `Enemies:${enemies.length} Chests:${chests.length} Orbs:${orbs.length} Time:${Math.floor(time/1000)}s`;
}, 700);

/* ---------- Init ---------- */
weaponsState.pistol.level = 1;
weaponsState.solar.level = 0;
weaponsState.solar.areas = [];
for(let i=0;i<4;i++) spawnEnemy();
gameStartTimestamp = performance.now();
lastBossSpawn = performance.now() + 10000; // 10s grace before first boss
updateHUD();

window.__VS = { weaponsLib, weaponsState, player, enemies, orbs, bullets, chests, spawnEnemy, spawnBoss: () => { lastBossSpawn = 0; }, killBoss, levelUp };

</script>
</body>
</html>
