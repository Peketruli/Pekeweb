<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vampire Survival — Sistema Base (Pistola + Área Solar)</title>
<style>
  :root{--hud-bg:rgba(0,0,0,0.5);--accent:#f1c40f}
  html,body{height:100%;margin:0;background:#080808;color:#eee;font-family:Inter,Arial,Helvetica,sans-serif;overflow:hidden}
  canvas{display:block;background:linear-gradient(#111,#040404);width:100vw;height:100vh}
  /* HUD top */
  #hud{position:fixed;top:10px;left:50%;transform:translateX(-50%);width:900px;max-width:95vw;z-index:30}
  .row{display:flex;gap:10px;align-items:center}
  .box{background:var(--hud-bg);padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.06)}
  #bars{flex:1}
  .bar{height:18px;background:#222;border-radius:8px;overflow:hidden;position:relative;border:1px solid rgba(255,255,255,0.05)}
  .fill{height:100%;transition:width .18s linear}
  .hpFill{background:linear-gradient(90deg,#2ecc71,#27ae60)}
  .xpFill{background:linear-gradient(90deg,#f39c12,#e67e22)}
  #inv{display:flex;gap:8px}
  .slot{min-width:120px;background:rgba(255,255,255,0.03);padding:6px;border-radius:6px;text-align:left;font-size:13px}
  .slot b{display:block}
  #levelMenu,#deathPanel{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#111;padding:18px;border:2px solid #fff;border-radius:10px;z-index:50;display:none;min-width:320px}
  #levelMenu h2,#deathPanel h2{margin:0 0 8px}
  #levelMenu .choices{display:flex;flex-direction:column;gap:8px;margin-top:8px}
  button.choice{padding:10px;border-radius:8px;border:none;background:#222;color:#fff;cursor:pointer}
  button.choice:hover{background:#333}
  #deathPanel button{margin-top:10px;padding:8px 12px;border-radius:8px;border:none;background:#c0392b;color:white;cursor:pointer}
  #debug{position:fixed;right:10px;bottom:10px;color:#999;font-size:12px;z-index:40}
</style>
</head>
<body>

<canvas id="c"></canvas>

<!-- HUD -->
<div id="hud">
  <div class="row">
    <div class="box" style="min-width:220px">
      <div style="font-size:14px"><strong id="scoreText">Puntos: 0</strong></div>
      <div style="font-size:13px">Nivel <span id="levelText">1</span></div>
    </div>
    <div id="bars" class="box" style="display:flex;flex-direction:column;gap:6px">
      <div style="display:flex;gap:8px;align-items:center">
        <div style="width:80px">Vida</div>
        <div class="bar" style="flex:1"><div id="hpFill" class="fill hpFill" style="width:100%"></div></div>
        <div style="width:70px;text-align:right" id="hpText">100/100</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <div style="width:80px">XP</div>
        <div class="bar" style="flex:1"><div id="xpFill" class="fill xpFill" style="width:0%"></div></div>
        <div style="width:70px;text-align:right" id="xpText">0/15</div>
      </div>
    </div>

    <div id="inv" class="box">
      <!-- inventory slots rendered dynamically -->
    </div>
  </div>
</div>

<!-- Level up menu -->
<div id="levelMenu">
  <h2>¡Subiste de nivel!</h2>
  <div style="font-size:13px;color:#ccc">Elige una opción (sube arma si ya la tienes)</div>
  <div class="choices" id="levelChoices"></div>
</div>

<!-- Death panel -->
<div id="deathPanel">
  <h2>Has muerto</h2>
  <div id="deathScore"></div>
  <button id="btnRestart">Reiniciar</button>
</div>

<div id="debug"></div>

<script>
/* -------------------------
   Sistema base: armas por nivel
   Implementa: Pistola + Área Solar
   Estructura para añadir más armas (Ver comentarios)
   ------------------------- */

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width=innerWidth; canvas.height=innerHeight; }
addEventListener('resize', resize);
resize();

/* ---------- Estado global ---------- */
let time = 0;           // ms desde inicio
let score = 0;
let xp = 0;
let level = 100;
let xpToNext = 15;
let gamePaused = false;
let dead = false;

/* ---------- Player ---------- */
const player = {
  x: canvas.width/2,
  y: canvas.height/2,
  size: 18,
  speed: 3.5,
  hp: 100,
  maxHp: 100
};

/* ---------- Input ---------- */
const keys = {};
addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

/* ---------- Entities ---------- */
let bullets = [];
let enemies = [];
let orbs = [];
let bosses = [];

/* ---------- Balance constants (ajustables) ---------- */
const BASE_SPAWN = 25;    // ms initial spawn
let spawnRate = BASE_SPAWN;
let lastSpawn = 0;

/* ---------- Weapon system design ----------

We keep a 'library' of weapons definitions (static) and an active 'inventory' object
where each weapon has a level (1..10) and an enabled flag if learned.

Weapon data structure:
weaponsLib = {
  id: { displayName, slotType, applyLevelStats(level, weaponState), tick... }
}
inventory = { id: { level: 0..10, lastShot:0, extraState... } }

When leveling up, we show 3 choices chosen from library (excluding fully maxed weapons)
and when player selects:
- if in inventory: increase level (min 10), applyLevelStats to upgrade state
- else: add to inventory with level 1, apply initial stats

We'll implement Pistola and AreaSolar fully as example.

---------- */

/* ---------- Library (weapon definitions) ---------- */

const weaponsLib = {};

/* PISTOLA
   - level 1: shot every 2500ms, 1 bullet, damage 1
   - each level: reduce interval, increase bullets and damage
   - level scaling parameters can be adjusted
*/
weaponsLib.pistol = {
  id: 'pistol',
  name: 'Pistola',
  maxLevel: 10,
  // get stats for *this* weapon at a given level (returns object)
  statsForLevel(level){
    // simple progression (tune numbers as desired)
    const baseInterval = 2500; // ms at level 1
    const interval = Math.max(220, Math.round(baseInterval - (level-1)*200)); // faster with level
    // bullets count: 1 at lvl1, +1 at lvl5, +1 at lvl8, +1 at lvl10
    let bullets = 1;
    if(level >= 2) bullets += 1;
    if(level >= 3) bullets += 1;
    if(level >= 4) bullets += 1;
    if(level >= 5) bullets += 1;
    if(level >= 6) bullets += 1;
    if(level >= 7) bullets += 1;
    if(level >= 8) bullets += 1;
    if(level >= 9) bullets += 1;
    if(level >= 10) bullets += 1;
    // damage scales
    const damage = 1 + Math.floor((level-1)/3); // every 3 levels +1 damage
    // bullet speed slightly increases
    const speed = 4 + (level-1)*0.25;
    // bullet size increase at high level
    const size = 4 + Math.floor((level-1)/4);
    return { interval, bullets, damage, speed, size };
  },
  // shoot function receives weaponState (inventory entry) and performs shots
  shoot(weaponState){
    if(gamePaused || !weaponsState.pistol.level) return;
    const now = performance.now();
    const lvl = weaponsState.pistol.level;
    const s = weaponsLib.pistol.statsForLevel(lvl);
    if(now - weaponState.lastShot < s.interval) return;
    weaponState.lastShot = now;
    // target nearest enemy
    if(enemies.length === 0 && bosses.length === 0) return;
    let target = null;
    const pool = enemies.length ? enemies : bosses;
    target = pool.reduce((a,b) => (dist(a,player) < dist(b,player) ? a : b));
    const ang = Math.atan2(target.y - player.y, target.x - player.x);
    // spread bullets around center
    const total = s.bullets;
    const spread = 0.28 + 0.04 * total;
    const step = total>1 ? spread/(total-1) : 0;
    const start = ang - spread/2;
    for(let i=0;i<total;i++){
      const a = start + step*i;
      bullets.push({
        x: player.x, y: player.y,
        dx: Math.cos(a)*s.speed, dy: Math.sin(a)*s.speed,
        damage: s.damage, size: s.size, life: 4000
      });
    }
  }
};

/* AREA SOLAR
   - creates a persistent area (follows player) that pulses damage every tickInterval
   - level scales size and damage and shortens tick interval slightly
*/
weaponsLib.solar = {
  id: 'solar',
  name: 'Área Solar',
  maxLevel: 10,
  statsForLevel(level){
    // level 1 radius 80, damage 3, tick 300ms
    const radius = Math.round(60 + (level-1)*14); // 60 -> ~196 at lvl10
    const damage = 2 + Math.floor((level-1)*1.4);  // about 2 -> 15
    const tick = Math.max(120, Math.round(450 - (level-1)*35)); // faster at higher levels
    return { radius, damage, tick };
  },
  // solar is a persistent area in inventory.solarAreas
  // no shoot function — handled by update loop
};

/* Add more weapons to library later:
   weaponsLib.staff = { ... }
   weaponsLib.potion = { ... }
   weaponsLib.whip = { ... }
*/

/* ---------- Inventory / weapons state ----------
   inventory entries: { level:0..10, lastShot:number, extra: {} }
*/
const weaponsState = {
  pistol: { level: 0, lastShot: 0 },
  solar: { level: 20, lastDamageTick: 0, areas: [] },
  // future: staff, potion, whip...
};

/* ---------- Helper utilities ---------- */
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

/* ---------- Spawning enemies & orbs ---------- */
let lastTime = performance.now();
let lastSpawnTime = performance.now();

function spawnEnemy(){
  const edge = Math.floor(Math.random()*4); // 0 left,1 right,2 top,3 bottom
  let x = edge===0 ? -20 : edge===1 ? canvas.width+20 : Math.random()*canvas.width;
  let y = edge===2 ? -20 : edge===3 ? canvas.height+20 : Math.random()*canvas.height;
  // early game: first 2 minutes easier enemies hp=1
  const easyWindow = 120000;
  let hp = time < easyWindow ? 1 : 1 + Math.floor(time/90000); // slowly increase
  const speed = 0.9 + Math.random()*1.4 + Math.min(1.5, time/120000); // slowly grows
  const size = 12 + Math.random()*10;
  enemies.push({ x,y, hp, speed, size, color:'#c0392b' });
}

/* ---------- Orbs (XP drops) ---------- */
function spawnOrbAt(x,y){
  const value = 1 + Math.floor(Math.random()*3);
  orbs.push({ x,y, value });
}

/* ---------- Level-up selection ---------- */
function openLevelMenu(){
  gamePaused = true;
  const menu = document.getElementById('levelMenu');
  const choicesDiv = document.getElementById('levelChoices');
  choicesDiv.innerHTML = '';
  // Build candidate pool: all weapons from library that are not maxed + some generic bonuses
  const candidates = [];
  for(const id in weaponsLib){
    const curLevel = weaponsState[id].level || 0;
    if(curLevel < weaponsLib[id].maxLevel) candidates.push({ type:'weapon', id });
  }
  // add some generic bonuses if needed
  const genericBonuses = [
    { type:'bonus', id:'hpUp', name:'Más vida (+10)' },
    { type:'bonus', id:'speed', name:'Velocidad +0.4' },
    { type:'bonus', id:'xpBoost', name:'Más XP (recoge +1)' }
  ];
  // merge and pick 3 unique options (if pool small, include generic)
  const pool = [...candidates];
  while(pool.length < 6) { pool.push(randChoice(genericBonuses)); } // pad
  // choose 3 unique
  const picks = [];
  while(picks.length < 3){
    const p = randChoice(pool);
    if(!picks.find(x=>x.type===p.type && x.id===p.id)) picks.push(p);
  }
  // render choices
  picks.forEach(p=>{
    const btn = document.createElement('button');
    btn.className = 'choice';
    if(p.type === 'weapon'){
      const lvl = weaponsState[p.id].level || 0;
      btn.textContent = `${weaponsLib[p.id].name} ${lvl?('(Lv '+lvl+')'):''}`;
      btn.onclick = ()=>{
        // increase level or add weapon
        weaponsState[p.id].level = Math.min(weaponsLib[p.id].maxLevel, (weaponsState[p.id].level||0) + 1);
        // if picking solar at level 1 we create area anchored to player
        if(p.id === 'solar' && weaponsState.solar.level === 1){
          // add one area following player
          weaponsState.solar.areas.push({ x: player.x, y: player.y, since: performance.now() });
        }
        applyWeaponLevelEffects(p.id);
        closeLevelMenu();
      };
    } else { // bonus
      btn.textContent = p.name;
      btn.onclick = ()=>{
        applyGenericBonus(p.id);
        closeLevelMenu();
      };
    }
    choicesDiv.appendChild(btn);
  });
  menu.style.display = 'block';
}
function closeLevelMenu(){
  document.getElementById('levelMenu').style.display = 'none';
  gamePaused = false;
  updateHUD();
}

/* ---------- Apply weapon effects (called when a weapon gains a level) ---------- */
function applyWeaponLevelEffects(id){
  // For modularity: most weapon effects are applied at runtime via statsForLevel,
  // but some immediate effects (like spawning initial solar area or unlocking) handled here.
  if(id === 'pistol'){
    // nothing immediate — pistol.shoot reads weaponsState.pistol.level
  }
  if(id === 'solar'){
    // if newly unlocked, ensure area exists (handled in openLevelMenu when level==1)
  }
}

/* ---------- Generic bonuses ---------- */
function applyGenericBonus(id){
  if(id === 'hpUp'){ player.maxHp += 10; player.hp = player.maxHp; }
  if(id === 'speed'){ player.speed += 0.4; }
  if(id === 'xpBoost'){ /* simple: next orbs give +1; we'll implement by increment on pick */ }
}

/* ---------- HUD ---------- */
const hpFill = document.getElementById('hpFill');
const xpFill = document.getElementById('xpFill');
const xpText = document.getElementById('xpText');
const hpText = document.getElementById('hpText');
const levelText = document.getElementById('levelText');
const scoreText = document.getElementById('scoreText');
const invDiv = document.getElementById('inv');

function updateHUD(){
  const pct = Math.max(0, Math.min(1, player.hp / player.maxHp));
  hpFill.style.width = (pct*100)+'%';
  hpText.textContent = Math.round(player.hp)+' / '+player.maxHp;
  xpFill.style.width = Math.min(100, (xp/xpToNext)*100)+'%';
  xpText.textContent = Math.floor(xp)+' / '+xpToNext;
  levelText.textContent = level;
  scoreText.textContent = 'Puntos: '+score;
  renderInventory();
}
function renderInventory(){
  invDiv.innerHTML = '';
  for(const id in weaponsLib){
    const lvl = weaponsState[id].level || 0;
    const el = document.createElement('div');
    el.className = 'slot';
    el.style.opacity = lvl?1:0.5;
    el.innerHTML = `<b>${weaponsLib[id].name}</b> ${lvl?'<span style="float:right">Lv '+lvl+'</span>':''}
      <div style="font-size:12px;color:#ccc">${lvl?weaponShortDesc(id,lvl):'No equipado'}</div>`;
    invDiv.appendChild(el);
  }
}
function weaponShortDesc(id, lvl){
  if(id==='pistol'){
    const s = weaponsLib.pistol.statsForLevel(lvl);
    return `${s.bullets} disparo(s), dmg ${s.damage}, cadencia ${s.interval}ms`;
  }
  if(id==='solar'){
    const s = weaponsLib.solar.statsForLevel(lvl);
    return `radio ${s.radius}px, dmg ${s.damage}/${s.tick}ms`;
  }
  return '';
}

/* ---------- Game loop & updates ---------- */

let lastFrame = performance.now();
function gameLoop(now){
  const dt = now - lastFrame;
  lastFrame = now;
  if(!gamePaused && !dead){
    time += dt;
    // spawn
    if(now - lastSpawnTime > spawnRate){
      lastSpawnTime = now;
      spawnEnemy();
    }
    // movement
    updatePlayer(dt);
    // weapons: pistol shoot
    if(weaponsState.pistol.level) weaponsLib.pistol.shoot(weaponsState.pistol);
    // bullets movement & collisions
    updateBullets(dt);
    // enemies move
    updateEnemies(dt);
    // solar damage tick
    updateSolar(now);
    // orbs collect
    updateOrbs();
    // bosses? (not implemented fully here)
  }
  render();
  updateHUD();
  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

/* ---------- Update helpers ---------- */

function updatePlayer(dt){
  if(keys['w'] || keys['arrowup']) player.y -= player.speed;
  if(keys['s'] || keys['arrowdown']) player.y += player.speed;
  if(keys['a'] || keys['arrowleft']) player.x -= player.speed;
  if(keys['d'] || keys['arrowright']) player.x += player.speed;
  // clamp
  player.x = Math.max(0, Math.min(canvas.width, player.x));
  player.y = Math.max(0, Math.min(canvas.height, player.y));
  // update solar area positions (they follow player)
  if(weaponsState.solar.level){
    weaponsState.solar.areas.forEach(a => { a.x = player.x; a.y = player.y; });
  }
}

function updateBullets(dt){
  for(let i = bullets.length-1; i>=0; i--){
    const b = bullets[i];
    b.x += b.dx;
    b.y += b.dy;
    b.life -= dt;
    if(b.life <= 0 || b.x < -50 || b.x > canvas.width+50 || b.y < -50 || b.y > canvas.height+50){ bullets.splice(i,1); continue; }
    // collide with enemies
    for(let j = enemies.length-1; j>=0; j--){
      const e = enemies[j];
      if(dist(b,e) < e.size){
        e.hp -= b.damage;
        bullets.splice(i,1);
        if(e.hp <= 0){
          spawnOrbAt(e.x, e.y);
          enemies.splice(j,1);
          score += 1;
          // small xp drop handled in orb collection
        }
        break;
      }
    }
    // bullets can hit bosses too (not implemented)
  }
}

function updateEnemies(dt){
  for(let i = enemies.length-1; i>=0; i--){
    const e = enemies[i];
    const a = Math.atan2(player.y - e.y, player.x - e.x);
    e.x += Math.cos(a) * e.speed * (dt/16);
    e.y += Math.sin(a) * e.speed * (dt/16);
    // collision with player
    if(dist(e,player) < player.size + e.size){
      // deal gentle damage (not insta-kill)
      player.hp -= 6 * (dt/16);
      if(player.hp <= 0) onDeath();
      // enemy dies on contact to avoid stacking repeatedly
      spawnOrbAt(e.x, e.y);
      enemies.splice(i,1);
    }
  }
}

/* Solar damage handling: ticks every tick ms per area */
function updateSolar(now){
  if(!weaponsState.solar.level) return;
  const lvl = weaponsState.solar.level;
  const s = weaponsLib.solar.statsForLevel(lvl);
  // use stored lastDamageTick
  if(!weaponsState.solar.lastTick) weaponsState.solar.lastTick = 0;
  if(now - weaponsState.solar.lastTick < s.tick) return;
  weaponsState.solar.lastTick = now;
  // apply damage to enemies inside area(s)
  weaponsState.solar.areas.forEach(area=>{
    for(let i = enemies.length-1; i>=0; i--){
      const e = enemies[i];
      if(dist(e, area) < s.radius){
        e.hp -= s.damage;
        if(e.hp <= 0){
          spawnOrbAt(e.x, e.y);
          enemies.splice(i,1);
          score += 1;
        }
      }
    }
  });
}

/* Orbs collection */
function updateOrbs(){
  for(let i = orbs.length-1; i>=0; i--){
    const o = orbs[i];
    if(dist(o, player) < player.size + 10){
      xp += o.value;
      orbs.splice(i,1);
      if(xp >= xpToNext){
        levelUp();
      }
    }
  }
}

/* Level up flow */
function levelUp(){
  level++;
  xp = xp - xpToNext;
  xpToNext = Math.max(5, Math.floor(xpToNext * 1.25));
  openLevelMenu();
}

/* Death */
function onDeath(){
  dead = true;
  gamePaused = true;
  const dp = document.getElementById('deathPanel');
  dp.style.display = 'block';
  document.getElementById('deathScore').textContent = 'Puntos: '+score+' | Nivel máximo: '+level;
}
document.getElementById('btnRestart').onclick = ()=>{
  location.reload();
};

/* ---------- Rendering ---------- */
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw solar areas (behind)
  if(weaponsState.solar.level){
    const lvl = weaponsState.solar.level;
    const s = weaponsLib.solar.statsForLevel(lvl);
    ctx.fillStyle = 'rgba(255,200,50,0.08)';
    weaponsState.solar.areas.forEach(a=>{
      ctx.beginPath();
      ctx.arc(a.x, a.y, s.radius, 0, Math.PI*2);
      ctx.fill();
    });
  }
  // draw orbs
  for(const o of orbs){
    ctx.fillStyle = '#f1c40f';
    ctx.beginPath(); ctx.arc(o.x, o.y, 6, 0, Math.PI*2); ctx.fill();
  }
  // draw enemies
  for(const e of enemies){
    ctx.fillStyle = e.color || '#c0392b';
    ctx.beginPath(); ctx.arc(e.x, e.y, e.size, 0, Math.PI*2); ctx.fill();
    // hp small text
    ctx.fillStyle = '#fff';
    ctx.font = '11px sans-serif';
    ctx.fillText(Math.max(0,Math.round(e.hp)), e.x - 8, e.y - e.size - 4);
  }
  // draw bullets
  for(const b of bullets){
    ctx.fillStyle = '#fff59d';
    ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI*2); ctx.fill();
  }
  // draw player
  ctx.fillStyle = '#3ddc84';
  ctx.beginPath(); ctx.arc(player.x, player.y, player.size, 0, Math.PI*2); ctx.fill();
}

/* ---------- Utilities ---------- */
function spawnOrbAt(x,y){ orbs.push({ x,y, value: 1 + Math.floor(Math.random()*2) }); }

/* ---------- Init: add pistol level 1 by default so player starts with it ---------- */
weaponsState.pistol.level = 1;
weaponsState.pistol.lastShot = 0;
applyWeaponLevelEffects('pistol');

/* ---------- Start debug small waves for testing ---------- */
lastSpawnTime = performance.now();
requestAnimationFrame(gameLoop);

/* ---------- Small debug display ---------- */
const debugEl = document.getElementById('debug');
setInterval(()=> {
  debugEl.textContent = `Enemies: ${enemies.length} Orbs:${orbs.length} Bullets:${bullets.length} Time:${Math.floor(time/1000)}s`;
}, 500);

/* ---------- Exported helpers for console tweaking (optional) ---------- */
window.__VS = { weaponsLib, weaponsState, player, enemies, orbs, bullets, spawnEnemy, levelUp, openLevelMenu, applyWeaponLevelEffects };

</script>
</body>
</html>
