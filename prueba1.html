<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vampire Survival — Imán + Boss rebalanceado</title>
<style>
  :root{--hud-bg:rgba(0,0,0,0.55);--accent:#f1c40f;--muted:#999}
  html,body{height:100%;margin:0;background:#080808;color:#eee;font-family:Inter,Arial,Helvetica,sans-serif;overflow:hidden}
  canvas{display:block;background:linear-gradient(#111,#040404);width:100vw;height:100vh}
  /* TOP HUD (center) */
  #topHUD{position:fixed;top:10px;left:50%;transform:translateX(-50%);width:760px;max-width:85vw;z-index:30}
  .row{display:flex;gap:10px;align-items:center}
  .box{background:var(--hud-bg);padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.06)}
  #bars{flex:1}
  .bar{height:18px;background:#222;border-radius:8px;overflow:hidden;position:relative;border:1px solid rgba(255,255,255,0.05)}
  .fill{height:100%;transition:width .18s linear}
  .hpFill{background:linear-gradient(90deg,#2ecc71,#27ae60)}
  .xpFill{background:linear-gradient(90deg,#f39c12,#e67e22)}
  /* Left HUD (weapons column) */
  #leftHUD{position:fixed;left:10px;top:50%;transform:translateY(-50%);z-index:35;display:flex;flex-direction:column;gap:8px}
  .weaponSlot{width:160px;background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);font-size:13px;display:flex;align-items:center;gap:8px}
  .weaponIcon{width:36px;height:36px;border-radius:6px;background:rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;font-weight:700;color:var(--muted)}
  .weaponInfo{flex:1}
  .weaponName{font-size:13px}
  .weaponLvl{font-size:12px;color:var(--muted)}
  /* Timer top-right */
  #timer{position:fixed;top:12px;right:12px;background:var(--hud-bg);padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);z-index:40;font-size:14px}
  /* Level menu & death panel */
  #levelMenu,#deathPanel{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#111;padding:18px;border:2px solid #fff;border-radius:10px;z-index:50;display:none;min-width:320px}
  #levelMenu h2,#deathPanel h2{margin:0 0 8px}
  #levelMenu .choices{display:flex;flex-direction:column;gap:8px;margin-top:8px}
  button.choice{padding:10px;border-radius:8px;border:none;background:#222;color:#fff;cursor:pointer}
  button.choice:hover{background:#333}
  #deathPanel button{margin-top:10px;padding:8px 12px;border-radius:8px;border:none;background:#c0392b;color:white;cursor:pointer}
  /* chest popup */
  #chestPopup{position:fixed;left:50%;top:20%;transform:translateX(-50%);z-index:60;background:linear-gradient(90deg,#222,#111);padding:12px 16px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);display:none}
  /* debug */
  #debug{position:fixed;right:10px;bottom:10px;color:#999;font-size:12px;z-index:40}
  @keyframes chestGlow {0%{box-shadow:0 0 0 rgba(255,215,0,0)}50%{box-shadow:0 0 20px rgba(255,215,0,0.7)}100%{box-shadow:0 0 0 rgba(255,215,0,0)}}
  .chestAnim{animation: chestGlow 1s ease-in-out;}
  #mainMenu, #charSelect, #infoPanel {
  position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
  background:#111; padding:20px; border:2px solid #fff; border-radius:10px;
  z-index:60; min-width:280px; text-align:center;
}
#mainMenu h2, #charSelect h2, #infoPanel h2 { margin-bottom:15px; }
#mainMenu .menuButtons { display:flex; flex-direction:column; gap:10px; }
#mainMenu button, #charSelect button, #infoPanel button {
  padding:10px 14px; border:none; border-radius:8px; background:#222; color:#fff; cursor:pointer;
}
#mainMenu button:hover, #charSelect button:hover, #infoPanel button:hover { background:#333; }
</style>
</head>
<body>

<canvas id="c"></canvas>

<!-- Left HUD: weapon column -->
<div id="leftHUD" aria-hidden="true"></div>

<!-- Top HUD center -->
<div id="topHUD">
  <div class="row">
    <div class="box" style="min-width:220px">
      <div style="font-size:14px"><strong id="scoreText">Puntos: 0</strong></div>
      <div style="font-size:13px">Nivel <span id="levelText">1</span></div>
    </div>
    <div id="bars" class="box" style="display:flex;flex-direction:column;gap:6px">
      <div style="display:flex;gap:8px;align-items:center">
        <div style="width:80px">Vida</div>
        <div class="bar" style="flex:1"><div id="hpFill" class="fill hpFill" style="width:100%"></div></div>
        <div style="width:70px;text-align:right" id="hpText">100/100</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <div style="width:80px">XP</div>
        <div class="bar" style="flex:1"><div id="xpFill" class="fill xpFill" style="width:0%"></div></div>
        <div style="width:70px;text-align:right" id="xpText">0/15</div>
      </div>
    </div>
    <div id="inv" class="box" style="display:none"></div>
  </div>
</div>

<!-- Timer -->
<div id="timer">00:00</div>

<!-- Level up menu -->
<div id="levelMenu">
  <h2>¡Subiste de nivel!</h2>
  <div style="font-size:13px;color:#ccc">Elige una opción (sube arma/habilidad si ya la tienes)</div>
  <div class="choices" id="levelChoices"></div>
</div>

<!-- Death panel -->
<div id="deathPanel">
  <h2>Has muerto</h2>
  <div id="deathScore"></div>
  <button id="btnRestart">Reiniciar</button>
</div>
  
<!-- Main Menu -->
<div id="mainMenu">
  <h2>Vampire Survival</h2>
  <div class="menuButtons">
    <button id="btnPlay">Jugar</button>
    <button id="btnInfo">Información</button>
    <button id="btnQuit">Volver</button>
  </div>
</div>

<!-- Character Selection Menu -->
<div id="charSelect" style="display:none">
  <h2>Selecciona tu personaje</h2>
  <div class="choices" id="charChoices"></div>
  <button id="btnCharBack">Volver</button>
</div>

<!-- Info Panel -->
<div id="infoPanel" style="display:none">
  <h2>Información de armas</h2>
  <div id="infoContent" style="font-size:13px; max-height:300px; overflow-y:auto"></div>
  <button id="btnInfoBack">Volver</button>
</div>

<!-- Chest popup -->
<div id="chestPopup"></div>

<div id="debug"></div>

<script>
/* -------------------------
   JS completo: armas nuevas + menús + progresión
   Reemplaza TODO el contenido <script> por este.
   ------------------------- */
document.addEventListener('DOMContentLoaded', () => {
  /* ---------- Setup canvas & UI ---------- */
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
  addEventListener('resize', resize); resize();
  canvas.style.position = 'fixed'; canvas.style.left = '0'; canvas.style.top = '0'; canvas.style.zIndex = '0';

  // UI elements (use IDs you provided)
  const mainMenuEl = document.getElementById('mainMenu');
  const charSelectEl = document.getElementById('charSelect');
  const infoPanelEl = document.getElementById('infoPanel');
  const levelMenuEl = document.getElementById('levelMenu');
  const deathPanelEl = document.getElementById('deathPanel');
  const chestPopup = document.getElementById('chestPopup');
  const leftHUD = document.getElementById('leftHUD');
  const timerEl = document.getElementById('timer');
  const debugEl = document.getElementById('debug');

  const btnPlay = document.getElementById('btnPlay');
  const btnInfo = document.getElementById('btnInfo');
  const btnQuit = document.getElementById('btnQuit');
  const btnCharBack = document.getElementById('btnCharBack');
  const btnInfoBack = document.getElementById('btnInfoBack');
  const btnRestart = document.getElementById('btnRestart');

  [mainMenuEl,charSelectEl,infoPanelEl,levelMenuEl,deathPanelEl].forEach(el=>{
    if(el){ el.style.zIndex = 10; el.style.pointerEvents = 'auto'; el.style.position = 'fixed'; }
  });

  /* ---------- Globals & balance ---------- */
  let time = 0, score = 0, xp = 0, level = 1, xpToNext = 15;
  let gamePaused = false, dead = false;
  let gameStartTimestamp = performance.now();
  function formatTime(ms){ const total = Math.floor(ms/1000); const mins = Math.floor(total/60); const secs = total%60; return String(mins).padStart(2,'0') + ':' + String(secs).padStart(2,'0'); }

  const player = { x: canvas.width/2, y: canvas.height/2, size: 18, speed: 2.2, hp: 100, maxHp: 100 };
  const keys = {}; addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true); addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

  let bullets = [], enemies = [], orbs = [], meleeAttacks = [], boss = null, chests = [];
  let lastSpawnTime = performance.now(), lastBossSpawn = performance.now();

  const BOSS_INTERVAL = 150000; // ms
  const BASE_SPAWN_INTERVAL = 1200;
  let spawnInterval = BASE_SPAWN_INTERVAL;

  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
  function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  /* ---------- Weapons definitions (from your table) ---------- */
  const weaponsLib = {};

  // Helper: linear scaling
  function lerp(base,inc,level){ return base + inc*(level-1); }

  // WHIP (Látigo) - atraviesa y golpea horizontalmente, aplica congelación (slow)
  weaponsLib.whip = {
    id:'whip', name:'Látigo (Whip)', maxLevel:10,
    statsForLevel(l){
      return {
        length: Math.round(120 + (l-1)*12),
        damage: 4 + Math.floor((l-1)*1.1),
        cooldown: Math.max(140, 420 - (l-1)*20),
        freezeChance: Math.min(0.35, 0.08 + (l-1)*0.03),
        thickness: Math.max(6, 10 + Math.floor((l-1)/3)*2)
      };
    },
    attack(state){
      if(!state.level || gamePaused || dead) return;
      const now = performance.now();
      const s = weaponsLib.whip.statsForLevel(state.level);
      if(now - (state.last||0) < s.cooldown) return;
      state.last = now;
      // whip hits both left and right horizontally (two arcs)
      meleeAttacks.push({
        x: player.x, y: player.y, angle: 0, arc: 0.2, range: s.length, damage: s.damage, life: 120, type: 'whip', freezeChance: s.freezeChance, thickness: s.thickness, twin:true
      });
      // twin hit is simulated by same attack but flagged twin true; renderer uses that
    }
  };

  // KNIFE (Cuchillo) - ráfaga constante en dirección del jugador
  weaponsLib.knife = {
    id:'knife', name:'Cuchillo (Knife)', maxLevel:10,
    statsForLevel(l){
      return { interval: Math.max(120, 420 - (l-1)*30), count: 1 + Math.floor((l-1)/2), damage: 2 + Math.floor((l-1)*0.8), speed: 7 + (l-1)*0.25, spread: 0.06 + (l-1)*0.003 };
    },
    shoot(state){
      if(!state.level || gamePaused || dead) return;
      const now = performance.now(); const s = weaponsLib.knife.statsForLevel(state.level);
      if(now - (state.lastShot||0) < s.interval) return;
      state.lastShot = now;
      // shoot in facing direction: nearest enemy or forward (use nearest)
      const pool = boss ? enemies.concat([boss]) : enemies;
      if(!pool.length) return;
      let target = pool[0];
      for(const p of pool) if(dist(p,player) < dist(target,player)) target = p;
      const ang = Math.atan2(target.y - player.y, target.x - player.x);
      for(let i=0;i<s.count;i++){
        const a = ang + (i - (s.count-1)/2) * s.spread;
        bullets.push({ x:player.x, y:player.y, dx:Math.cos(a)*s.speed, dy:Math.sin(a)*s.speed, damage: s.damage, life: 2400, size:3, friendly:true, type:'knife' });
      }
    }
  };

  // AXE (Hacha) - arc shot, higher crit chance
  weaponsLib.axe = {
    id:'axe', name:'Hacha (Axe)', maxLevel:10,
    statsForLevel(l){
      return { arc: Math.PI/3 + (l-1)*0.04, range: 36 + (l-1)*4, damage: 8 + Math.floor((l-1)*1.8), interval: Math.max(240, 540 - (l-1)*30), critChance: Math.min(0.3, 0.06 + (l-1)*0.03) };
    },
    attack(state){
      if(!state.level || gamePaused || dead) return;
      const now = performance.now(); const s = weaponsLib.axe.statsForLevel(state.level);
      if(now - (state.last||0) < s.interval) return;
      state.last = now;
      // create an arc melee attack (similar to sword but wider)
      const pool = boss ? enemies.concat([boss]) : enemies;
      let target = pool.length ? pool[0] : null;
      if(target){
        for(const p of pool) if(dist(p,player) < dist(target,player)) target = p;
      }
      const ang = target ? Math.atan2(target.y - player.y, target.x - player.x) : 0;
      meleeAttacks.push({ x:player.x, y:player.y, angle:ang, arc:s.arc, range:s.range, damage:s.damage, life:140, type:'axe', critChance: s.critChance });
    }
  };

  // CROSS (Cruz) - becomes a falling sword randomly (simulated as periodic heavy melee)
  weaponsLib.cross = {
    id:'cross', name:'Cruz (Cross)', maxLevel:10,
    statsForLevel(l){ return { chanceToFall: Math.min(0.25, 0.07 + (l-1)*0.02), damage: 10 + Math.floor((l-1)*2), interval: Math.max(900, 1600 - (l-1)*90), critBonus: Math.min(0.5, 0.08 + (l-1)*0.03) }; },
    tick(state){
      if(!state.level || gamePaused || dead) return;
      const now = performance.now(); const s = weaponsLib.cross.statsForLevel(state.level);
      if(now - (state.lastTick||0) < s.interval) return;
      state.lastTick = now;
      // random chance to spawn falling sword that hits random enemy location
      if(enemies.length || boss){
        if(Math.random() < s.chanceToFall || (state.level > 6 && Math.random() < 0.25)){
          const pool = boss ? enemies.concat([boss]) : enemies;
          let target = pool[ Math.floor(Math.random()*pool.length) ];
          // create an instant area damage at target
          const dmg = s.damage;
          if(target === boss){ boss.hp -= dmg * (Math.random() < s.critBonus ? 1.6 : 1); if(boss.hp <= 0) killBoss(); }
          else {
            target.hp -= dmg * (Math.random() < s.critBonus ? 1.6 : 1);
            if(target.hp <= 0){ spawnOrbAt(target.x,target.y); enemies.splice(enemies.indexOf(target),1); score++; }
          }
        }
      }
    }
  };

  // HOLY WATER (Agua Bendita) - creates damaging puddles that grow and last
  weaponsLib.holywater = {
    id:'holywater', name:'Agua Bendita (Holy Water)', maxLevel:10,
    statsForLevel(l){ return { baseDamage: 4 + Math.floor((l-1)*1.2), grow: 4 + l, duration: 3000 + (l-1)*400, interval: Math.max(900, 2200 - (l-1)*120), radius: 14 + (l-1)*3 }; },
    throw(state){
      if(!state.level || gamePaused || dead) return;
      const now = performance.now(); const s = weaponsLib.holywater.statsForLevel(state.level);
      if(now - (state.last||0) < s.interval) return;
      state.last = now;
      // place puddle at random near player
      const angle = Math.random()*Math.PI*2;
      const d = 60 + Math.random()*80;
      const x = clamp(player.x + Math.cos(angle)*d, 10, canvas.width-10);
      const y = clamp(player.y + Math.sin(angle)*d, 10, canvas.height-10);
      chests.push = chests.push || (()=>{}); // no-op safety
      // puddles stored in bullets array type 'puddle'
      bullets.push({ x,y, radius: s.radius, grow: s.grow, created: now, duration: s.duration, damage: s.baseDamage, type:'puddle' });
    },
    update(state, dt){
      // puddle visual handled in render loop reading bullets entries type puddle
    }
  };

  // KING BIBLE (Biblia del Rey) - orbs rotating, longer duration and faster when evolved
  weaponsLib.kingbible = {
    id:'kingbible', name:'Biblia del Rey (King Bible)', maxLevel:10,
    statsForLevel(l){ return { orbCount: 1 + Math.floor(l/2), radius: 55 + l*6, damage: 0.9 + l*0.45, duration: 3000 + l*400, cooldown: Math.max(600, 8000 - l*250), speed: 0.006 + l*0.0006 }; },
    update(state, dt){
      if(!state.level || gamePaused || dead) return;
      const now = performance.now(); const s = weaponsLib.kingbible.statsForLevel(state.level);
      if(!state.active && (!state.lastUse || now - state.lastUse > s.cooldown)){ state.lastUse = now; state.active = true; state.spawnTime = now; state.orbs = []; for(let i=0;i<s.orbCount;i++) state.orbs.push({ angle: (i/s.orbCount)*Math.PI*2 }); }
      if(state.active){
        const elapsed = now - state.spawnTime;
        for(const orb of state.orbs){
          orb.angle += s.speed * dt;
          orb.x = player.x + Math.cos(orb.angle)*s.radius;
          orb.y = player.y + Math.sin(orb.angle)*s.radius;
          // damage enemies on contact handled in global collision loop
        }
        if(elapsed > s.duration){ state.active = false; state.orbs = []; }
      }
    }
  };

  // MAGIC WAND (Vara Mágica) - fires faster, targets nearest enemy, no cooldown at high level
  weaponsLib.magicwand = {
    id:'magicwand', name:'Vara Mágica (Magic Wand)', maxLevel:10,
    statsForLevel(l){ return { interval: Math.max(60, 400 - (l-1)*40), damage: 6 + Math.floor((l-1)*1.4), speed: 6 + (l-1)*0.25, size: 4 + Math.floor((l-1)/3) }; },
    shoot(state){
      if(!state.level || gamePaused || dead) return;
      const now = performance.now(); const s = weaponsLib.magicwand.statsForLevel(state.level);
      if(now - (state.lastShot||0) < s.interval) return;
      state.lastShot = now;
      const pool = boss ? enemies.concat([boss]) : enemies;
      if(!pool.length) return;
      let target = pool[0]; for(const p of pool) if(dist(p,player) < dist(target,player)) target = p;
      const ang = Math.atan2(target.y - player.y, target.x - player.x);
      bullets.push({ x:player.x,y:player.y,dx:Math.cos(ang)*s.speed,dy:Math.sin(ang)*s.speed,damage:s.damage,life:3000,size:s.size,friendly:true,type:'magicwand' });
    }
  };

  // FIRE WAND (Pájaro de Fuego) - big fireballs that pierce
  weaponsLib.firewand = {
    id:'firewand', name:'Pájaro de Fuego (Fire Wand)', maxLevel:10,
    statsForLevel(l){ return { interval: Math.max(700, 1600 - (l-1)*90), damage: 12 + Math.floor((l-1)*2), speed: 3.6 + (l-1)*0.12, size: 7 + Math.floor((l-1)/2), pierceCount: 1 + Math.floor((l-1)/3) }; },
    shoot(state){
      if(!state.level || gamePaused || dead) return;
      const now = performance.now(); const s = weaponsLib.firewand.statsForLevel(state.level);
      if(now - (state.lastShot||0) < s.interval) return;
      state.lastShot = now;
      // fireball goes up (or to nearest enemy)
      const pool = boss ? enemies.concat([boss]) : enemies;
      let ang = -Math.PI/2;
      if(pool.length){
        let target = pool[0]; for(const p of pool) if(dist(p,player) < dist(target,player)) target = p;
        ang = Math.atan2(target.y - player.y, target.x - player.x);
      }
      bullets.push({ x:player.x,y:player.y,dx:Math.cos(ang)*s.speed,dy:Math.sin(ang)*s.speed,damage:s.damage,life:5000,size:s.size,friendly:true,type:'firewand',pierce:s.pierceCount });
    }
  };

  // GARLIC (Ajo) - area aura that heals player on damage dealt
  weaponsLib.garlic = {
    id:'garlic', name:'Ajo (Garlic)', maxLevel:10,
    statsForLevel(l){ return { radius: 28 + (l-1)*6, dmg: 1 + Math.floor((l-1)*0.8), lifeStealPct: Math.min(0.25, 0.03 + (l-1)*0.02), tick: Math.max(120, 420 - (l-1)*20) }; },
    tick(state){
      if(!state.level || gamePaused || dead) return;
      const now = performance.now(); const s = weaponsLib.garlic.statsForLevel(state.level);
      if(now - (state.lastTick||0) < s.tick) return;
      state.lastTick = now;
      // damage enemies in radius and heal player
      for(let i=enemies.length-1;i>=0;i--){
        const e = enemies[i];
        const d = Math.hypot(e.x - player.x, e.y - player.y);
        if(d < s.radius + e.size){
          e.hp -= s.dmg;
          if(e.hp <= 0){ spawnOrbAt(e.x,e.y); enemies.splice(i,1); score++; }
          // heal proportionally
          player.hp = Math.min(player.maxHp, player.hp + Math.max(1, Math.round(s.dmg * s.lifeStealPct)));
        }
      }
      if(boss && Math.hypot(boss.x - player.x, boss.y - player.y) < s.radius + boss.size){
        boss.hp -= s.dmg;
        if(boss.hp <= 0) killBoss();
        player.hp = Math.min(player.maxHp, player.hp + Math.max(1, Math.round(s.dmg * s.lifeStealPct)));
      }
    }
  };

  // LIGHTNING RING (Rayo) - area effect that strikes twice
  weaponsLib.lightning = {
    id:'lightning', name:'Rayo (Lightning Ring)', maxLevel:10,
    statsForLevel(l){ return { radius: 34 + (l-1)*8, damage: 6 + Math.floor((l-1)*1.6), interval: Math.max(220, 600 - (l-1)*30), hits: 2 + Math.floor((l-1)/4) }; },
    tick(state){
      if(!state.level || gamePaused || dead) return;
      const now = performance.now(); const s = weaponsLib.lightning.statsForLevel(state.level);
      if(now - (state.last||0) < s.interval) return;
      state.last = now;
      // strike up to s.hits enemies randomly within radius
      const pool = enemies.concat(boss? [boss]:[]);
      const hits = Math.min(s.hits, pool.length);
      for(let i=0;i<hits;i++){
        if(pool.length===0) break;
        const idx = Math.floor(Math.random()*pool.length);
        const e = pool[idx];
        if(e === boss){ boss.hp -= s.damage; if(boss.hp<=0) killBoss(); } else { e.hp -= s.damage; if(e.hp<=0){ spawnOrbAt(e.x,e.y); enemies.splice(enemies.indexOf(e),1); score++; } }
        pool.splice(idx,1);
      }
    }
  };

  // PENTAGRAM - screen nuke area (on use) and evolved draws XP automatically
  weaponsLib.pentagram = {
    id:'pentagram', name:'Pentagrama (Pentagram)', maxLevel:10,
    statsForLevel(l){ return { cooldown: Math.max(4000, 12000 - l*500), clearRadius: Math.max(canvas.width, canvas.height) * 1.5, evolveXPAttract: l >= 8 }; },
    activate(state){
      if(!state.level || gamePaused || dead) return;
      const now = performance.now(); const s = weaponsLib.pentagram.statsForLevel(state.level);
      if(state.lastUse && now - state.lastUse < s.cooldown) return;
      state.lastUse = now;
      // clear all enemies and bullets
      enemies = [];
      bullets = bullets.filter(b => b.type === 'puddle'); // keep puddles
      chests.push({ x: player.x, y: player.y, spawned: now, offset: Math.random()*9000, rewardText: 'Pentagrama: recompensa' });
      if(s.evolveXPAttract){ weaponsState.__xpAttract = (weaponsState.__xpAttract||0) + 10; } // passive
    }
  };

  // SONG OF MANA (Gema de Canto) - AoE damage + slow
  weaponsLib.songofmana = {
    id:'songofmana', name:'Gema de Canto (Song of Mana)', maxLevel:10,
    statsForLevel(l){ return { radius: 40 + l*6, damage: 3 + Math.floor(l*1.2), slowPct: Math.min(0.6, 0.12 + l*0.03), tick: Math.max(200, 520 - l*30) }; },
    tick(state){
      if(!state.level || gamePaused || dead) return;
      const now = performance.now(); const s = weaponsLib.songofmana.statsForLevel(state.level);
      if(now - (state.last||0) < s.tick) return;
      state.last = now;
      for(const e of enemies){
        if(Math.hypot(e.x - player.x, e.y - player.y) < s.radius + e.size){
          e.hp -= s.damage;
          e.speed *= (1 - s.slowPct);
          setTimeout(()=> e.speed /= (1 - s.slowPct), 400); // revert after small time
          if(e.hp <= 0){ spawnOrbAt(e.x,e.y); enemies.splice(enemies.indexOf(e),1); score++; }
        }
      }
      if(boss && Math.hypot(boss.x - player.x, boss.y - player.y) < s.radius + boss.size){
        boss.hp -= s.damage;
        boss.speed *= (1 - s.slowPct);
        setTimeout(()=> boss.speed /= (1 - s.slowPct), 400);
        if(boss.hp <= 0) killBoss();
      }
    }
  };

  // EBONY WINGS (Daga de Ébano) - pairs with shovel (not implemented separately), makes a flying damaging projectile (simulated)
  weaponsLib.ebony = {
    id:'ebony', name:'Daga de Ébano (Ebony Wings)', maxLevel:10,
    statsForLevel(l){ return { dmg: 8 + Math.floor(l*1.6), speed: 6 + l*0.2, interval: Math.max(220,700 - l*40) }; },
    shoot(state){
      if(!state.level || gamePaused || dead) return;
      const now = performance.now(); const s = weaponsLib.ebony.statsForLevel(state.level);
      if(now - (state.lastShot||0) < s.interval) return;
      state.lastShot = now;
      // spawn small flying dagger toward nearest
      const pool = boss ? enemies.concat([boss]) : enemies;
      if(!pool.length) return;
      let target = pool[0]; for(const p of pool) if(dist(p,player) < dist(target,player)) target = p;
      const ang = Math.atan2(target.y - player.y, target.x - player.x);
      bullets.push({ x: player.x, y: player.y, dx: Math.cos(ang)*s.speed, dy: Math.sin(ang)*s.speed, damage: s.dmg, life:3000, size:4, friendly:true, type:'ebony' });
    }
  };

  // BLOOD WHIP (Látigo de Sangre) - leaves a fire trail while moving
  weaponsLib.bloodwhip = {
    id:'bloodwhip', name:'Látigo de Sangre (Blood Whip)', maxLevel:10,
    statsForLevel(l){ return { length: 110 + l*10, damage: 3 + Math.floor(l*1.1), trailDamage: 2 + Math.floor(l*0.5), cooldown: Math.max(140,420 - l*25) }; },
    attack(state){
      if(!state.level || gamePaused || dead) return;
      const now = performance.now(); const s = weaponsLib.bloodwhip.statsForLevel(state.level);
      if(now - (state.last||0) < s.cooldown) return;
      state.last = now;
      // melee arc with persistent trail effect (we simulate trail by spawning small 'fire' orbs following player)
      meleeAttacks.push({ x:player.x, y:player.y, angle:0, arc:0.26, range:s.length, damage:s.damage, life:160, type:'bloodwhip', trail: true, trailDamage: s.trailDamage });
    },
    trailTick(state){
      // spawn little persistent fire orbs behind player for short time
      if(!state.level) return;
      // spawn occasionally
      if(Math.random() < 0.25) orbs.push({ x: player.x + (Math.random()-0.5)*20, y: player.y + (Math.random()-0.5)*20, value: 0.5, fire:true, life:1200, dmg: weaponsLib.bloodwhip.statsForLevel(state.level).trailDamage });
    }
  };

  // POTION (leftover helper)
  weaponsLib.potion = {
    id:'potion', name:'Pociones', maxLevel:10,
    statsForLevel(l){ return { healAmount: 6 + Math.floor((l-1)*1.6), interval: Math.max(3500, 9000 - (l-1)*500) }; },
    tick(state){ if(!state.level || gamePaused || dead) return; const now = performance.now(); const s = weaponsLib.potion.statsForLevel(state.level); if(now - (state.lastHeal||0) < s.interval) return; state.lastHeal = now; player.hp = Math.min(player.maxHp, player.hp + s.healAmount); }
  };

  // MAGNET passive behaviour (keep)
  weaponsLib.magnet = {
    id:'magnet', name:'Imán', maxLevel:10,
    statsForLevel(l){ return { radius: 90 + (l-1)*24, pullStrength: 0.02 + (l-1)*0.008 }; },
    update(state, dt){
      if(!state.level) return;
      const s = weaponsLib.magnet.statsForLevel(state.level);
      for(const o of orbs){ const d = Math.hypot(o.x - player.x, o.y - player.y); if(d <= s.radius){ const k = s.pullStrength * (dt/16); o.x += (player.x - o.x)*k*1.2; o.y += (player.y - o.y)*k*1.2; } }
    }
  };

  /* ---------- Weapons state (levels & per-weapon storage) ---------- */
  const weaponsState = {
    whip: { level: 0 },
    knife: { level: 0 },
    axe: { level: 0 },
    cross: { level: 0 },
    holywater: { level: 0 },
    kingbible: { level: 0, active:false, orbs:[] },
    magicwand: { level: 0 },
    firewand: { level: 0 },
    garlic: { level: 0 },
    lightning: { level: 0 },
    pentagram: { level: 0 },
    songofmana: { level: 0 },
    ebony: { level: 0 },
    bloodwhip: { level: 0 },
    potion: { level: 0 },
    magnet: { level: 0 }
  };

  // define initial defaults: give player two basics by default (knife+pistol-equivalent = knife)
  weaponsState.knife.level = 1;
  weaponsState.potion.level = 0;

  // hidden combos / evolutions mapping (when both present, grant extras)
  const combos = [
    { name:'Whip+HollowHeart => Lash', required:['whip','bloodwhip'], effect: ()=>{ /* example */ }, activated:false },
    // You can add more evolutions to check in checkCombos()
  ];

  function checkCombos(){
    combos.forEach(c=>{
      if(c.activated) return;
      const ok = c.required.every(id=>weaponsState[id] && weaponsState[id].level>0);
      if(ok){ c.activated = true; try{ c.effect(); showChestPopup('¡Evolución activada: '+c.name+'!'); }catch(e){} }
    });
  }

  /* ---------- Spawners & pickups ---------- */
  function spawnEnemy(){
    const edge = Math.floor(Math.random()*4);
    let x = edge===0 ? -20 : edge===1 ? canvas.width+20 : Math.random()*canvas.width;
    let y = edge===2 ? -20 : edge===3 ? canvas.height+20 : Math.random()*canvas.height;
    const easyWindow = 120000;
    let hp = time < easyWindow ? 4 : 4 + Math.floor(time/90000);
    const speed = 0.45 + Math.random()*1.0 + Math.min(1.1, time/120000);
    const size = 10 + Math.random()*10;
    enemies.push({ x,y,hp,speed,size,color:'#c0392b' });
  }
  function spawnOrbAt(x,y){ const value = 1 + Math.floor(Math.random()*2); orbs.push({ x,y,value }); }

  /* ---------- HUD rendering helpers ---------- */
  function showChestPopup(text){
    chestPopup.textContent = text;
    chestPopup.style.display = 'block';
    chestPopup.classList.add('chestAnim');
    clearTimeout(showChestPopup._t);
    showChestPopup._t = setTimeout(()=>{ chestPopup.style.display = 'none'; chestPopup.classList.remove('chestAnim'); }, 2200);
  }

  function updateHUD(){
    const hpFill = document.getElementById('hpFill'), xpFill = document.getElementById('xpFill'), xpText = document.getElementById('xpText');
    const hpText = document.getElementById('hpText'), levelText = document.getElementById('levelText'), scoreText = document.getElementById('scoreText');
    if(hpFill) hpFill.style.width = (Math.max(0,Math.min(1, player.hp / player.maxHp))*100)+'%';
    if(hpText) hpText.textContent = Math.round(player.hp) + ' / ' + player.maxHp;
    if(xpFill) xpFill.style.width = Math.min(100,(xp/xpToNext)*100)+'%';
    if(xpText) xpText.textContent = Math.floor(xp) + ' / ' + xpToNext;
    if(levelText) levelText.textContent = level;
    if(scoreText) scoreText.textContent = 'Puntos: ' + score;
    renderLeftHUD();
  }

  function renderLeftHUD(){
    leftHUD.innerHTML = '';
    const order = ['knife','whip','axe','cross','holywater','kingbible','magicwand','firewand','garlic','lightning','pentagram','songofmana','ebony','bloodwhip','potion','magnet'];
    for(const id of order){
      if(!weaponsLib[id]) continue;
      const lvl = weaponsState[id]?.level || 0;
      const slot = document.createElement('div'); slot.className = 'weaponSlot'; slot.style.opacity = lvl?1:0.4;
      const icon = document.createElement('div'); icon.className = 'weaponIcon'; icon.textContent = id.charAt(0).toUpperCase();
      const info = document.createElement('div'); info.className = 'weaponInfo';
      const name = document.createElement('div'); name.className='weaponName'; name.textContent = weaponsLib[id].name;
      const lvldiv = document.createElement('div'); lvldiv.className='weaponLvl'; lvldiv.textContent = lvl ? `Lv ${lvl}` : 'No equipado';
      info.appendChild(name); info.appendChild(lvldiv); slot.appendChild(icon); slot.appendChild(info); leftHUD.appendChild(slot);
    }
  }

  /* ---------- Weapon application / level menu ---------- */
  function applyWeaponLevelEffects(id){
    if(id === 'kingbible'){ weaponsState.kingbible.lastUse = 0; weaponsState.kingbible.active = false; weaponsState.kingbible.orbs = []; }
    if(id === 'holywater' && weaponsState.holywater.level === 1){ /* ensure puddles possible */ }
    // magnet passive has implicit effect
  }
  function applyGenericBonus(id){
    if(id === 'hpUp'){ player.maxHp += 10; player.hp = player.maxHp; }
    if(id === 'speed'){ player.speed += 0.3; }
    if(id === 'xpBoost'){ weaponsState.__xpBoost = (weaponsState.__xpBoost||0) + 5; }
  }

  function openLevelMenu(){
    gamePaused = true; levelMenuEl.style.display = 'block';
    const choicesDiv = document.getElementById('levelChoices'); choicesDiv.innerHTML = '';
    const candidates = [];
    for(const id in weaponsLib){ const cur = weaponsState[id].level || 0; if(cur < weaponsLib[id].maxLevel) candidates.push({ type:'weapon', id }); }
    const genericBonuses = [ { type:'bonus', id:'hpUp', name:'Más vida (+10)' }, { type:'bonus', id:'speed', name:'Velocidad +0.3' }, { type:'bonus', id:'xpBoost', name:'Más XP (orb +1)' } ];
    const pool = [...candidates];
    while(pool.length < 6) pool.push(randChoice(genericBonuses));
    const picks = [];
    while(picks.length < 3){
      const p = randChoice(pool);
      if(!picks.find(x=>x.type===p.type && x.id===p.id)) picks.push(p);
    }
    picks.forEach(p=>{
      const btn = document.createElement('button'); btn.className = 'choice';
      if(p.type === 'weapon'){
        const lvl = weaponsState[p.id].level || 0; btn.textContent = `${weaponsLib[p.id].name} ${lvl?('(Lv '+lvl+')'):''}`;
        btn.onclick = ()=>{ weaponsState[p.id].level = Math.min(weaponsLib[p.id].maxLevel, (weaponsState[p.id].level||0)+1); applyWeaponLevelEffects(p.id); checkCombos(); closeLevelMenu(); };
      } else {
        btn.textContent = p.name; btn.onclick = ()=>{ applyGenericBonus(p.id); closeLevelMenu(); };
      }
      choicesDiv.appendChild(btn);
    });
  }
  function closeLevelMenu(){ levelMenuEl.style.display = 'none'; gamePaused = false; updateHUD(); }

  /* ---------- Updates: player, bullets, enemies, melee ---------- */
  function updatePlayer(dt){
    if(keys['w'] || keys['arrowup']) player.y -= player.speed;
    if(keys['s'] || keys['arrowdown']) player.y += player.speed;
    if(keys['a'] || keys['arrowleft']) player.x -= player.speed;
    if(keys['d'] || keys['arrowright']) player.x += player.speed;
    player.x = clamp(player.x, player.size, canvas.width - player.size);
    player.y = clamp(player.y, player.size, canvas.height - player.size);
    if(weaponsState.kingbible.level){ // keep areas attached to player via kingbible orbs
      const st = weaponsState.kingbible; if(st.orbs) st.orbs.forEach(a=>{ if(a) { a.x = player.x + (a.x?0:0); a.y = player.y + (a.y?0:0); } });
    }
  }

  function updateBullets(dt){
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      // handle puddles specially
      if(b.type === 'puddle'){
        // grow
        const age = performance.now() - b.created;
        const t = Math.min(1, age / b.duration);
        b.radius = (b.radius || 12) + (b.grow || 4) * t;
        // damage enemies inside
        for(let j=enemies.length-1;j>=0;j--){
          const e = enemies[j];
          if(Math.hypot(b.x - e.x, b.y - e.y) < b.radius + e.size){
            e.hp -= b.damage * (dt/100); // tick damage proportional to dt
            if(e.hp <= 0){ spawnOrbAt(e.x,e.y); enemies.splice(j,1); score++; }
          }
        }
        // lifetime
        if(performance.now() - b.created > b.duration) bullets.splice(i,1);
        continue;
      }
      // flying bullets (projectiles)
      if(b.homing){
        const pool = boss ? enemies.concat([boss]) : enemies;
        if(pool.length){
          let target = pool[0];
          for(const p of pool) if(dist(p,b) < dist(target,b)) target = p;
          const angTo = Math.atan2(target.y - b.y, target.x - b.x);
          const curAng = Math.atan2(b.dy, b.dx);
          let diff = angTo - curAng; while(diff > Math.PI) diff -= Math.PI*2; while(diff < -Math.PI) diff += Math.PI*2;
          let newAng = curAng + diff * (b.homingStrength || 0.12);
          b.dx = Math.cos(newAng) * (b.speed || Math.hypot(b.dx,b.dy));
          b.dy = Math.sin(newAng) * (b.speed || Math.hypot(b.dx,b.dy));
        }
      }
      b.x += b.dx * (dt/16);
      b.y += b.dy * (dt/16);
      b.life -= dt;
      if(b.life <= 0 || b.x < -80 || b.x > canvas.width+80 || b.y < -80 || b.y > canvas.height+80){ bullets.splice(i,1); continue; }
      // collisions with enemies
      for(let j=enemies.length-1;j>=0;j--){
        const e = enemies[j];
        if(Math.hypot(b.x - e.x, b.y - e.y) < e.size + (b.size||4)){
          // apply damage
          let dmg = b.damage || 1;
          if(b.pierce){
            if(b._pierced === undefined) b._pierced = 0;
            b._pierced++;
            if(b._pierced >= b.pierce) bullets.splice(i,1);
          } else bullets.splice(i,1);
          e.hp -= dmg;
          if(e.hp <= 0){ spawnOrbAt(e.x,e.y); enemies.splice(j,1); score++; }
          break;
        }
      }
      // hit boss
      if(boss && Math.hypot(b.x - boss.x, b.y - boss.y) < boss.size + (b.size||4)){
        boss.hp -= b.damage || 1;
        if(b.pierce){
          b._pierced = (b._pierced||0) + 1; if(b._pierced >= b.pierce) bullets.splice(i,1);
        } else bullets.splice(i,1);
        if(boss.hp <= 0) killBoss();
      }
    }
  }

  function updateMelee(dt){
    for(let i = meleeAttacks.length-1; i>=0; i--){
      const m = meleeAttacks[i];
      m.life -= dt;
      // check enemies
      for(let j=enemies.length-1;j>=0;j--){
        const e = enemies[j];
        const angToE = Math.atan2(e.y - m.y, e.x - m.x);
        let diff = Math.abs(((angToE - m.angle + Math.PI) % (2*Math.PI)) - Math.PI);
        if(diff <= (m.arc||0.6)/2 && dist(e,m) <= (m.range||40) + e.size){
          // apply damage & special effects
          let dmg = m.damage || 1;
          // crit for axe/cross
          if(m.critChance && Math.random() < m.critChance) dmg *= 1.75;
          e.hp -= dmg;
          // freeze chance for whip
          if(m.freezeChance && Math.random() < m.freezeChance){ e._slow = 0.35; setTimeout(()=> e._slow = 0, 800); e.speed *= 0.6; setTimeout(()=> e.speed /= 0.6, 800); }
          // blood whip trail damage handled elsewhere (trail spawns)
          if(e.hp <= 0){ spawnOrbAt(e.x,e.y); enemies.splice(j,1); score++; }
        }
      }
      // vs boss
      if(boss){
        const angToB = Math.atan2(boss.y - m.y, boss.x - m.x);
        let diffB = Math.abs(((angToB - m.angle + Math.PI) % (2*Math.PI)) - Math.PI);
        if(diffB <= (m.arc||0.6)/2 && dist(boss,m) <= (m.range||40) + boss.size){
          boss.hp -= m.damage || 1;
          if(boss.hp <= 0) killBoss();
        }
      }
      if(m.trail){ // spawn some fire orbs as trail
        if(Math.random() < 0.5) orbs.push({ x: m.x + (Math.random()-0.5)*30, y: m.y + (Math.random()-0.5)*30, value: 0.2, life: 900, fire:true, dmg: m.trailDamage || 1 });
      }
      if(m.life <= 0) meleeAttacks.splice(i,1);
    }
  }

  function updateEnemies(dt){
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      // apply temporary slow factor if present
      let effSpeed = e.speed * (e._slow ? (1 - e._slow) : 1);
      const a = Math.atan2(player.y - e.y, player.x - e.x);
      e.x += Math.cos(a) * effSpeed * (dt/16);
      e.y += Math.sin(a) * effSpeed * (dt/16);
      // contact with player
      if(Math.hypot(e.x - player.x, e.y - player.y) < player.size + e.size){
        player.hp -= 8 * (dt/16);
        spawnOrbAt(e.x, e.y);
        enemies.splice(i,1);
        if(player.hp <= 0) onDeath();
      }
    }
  }

  /* ---------- Solar & other passives ticking ---------- */
  function updateSolar(now){
    if(!weaponsState.songofmana.level && !weaponsState.kingbible.level && !weaponsState.lightning.level) return;
    // call relevant ticks
    if(weaponsState.songofmana.level) weaponsLib.songofmana.tick(weaponsState.songofmana);
    if(weaponsState.lightning.level) weaponsLib.lightning.tick(weaponsState.lightning);
    if(weaponsState.garlic.level) weaponsLib.garlic.tick(weaponsState.garlic);
    if(weaponsState.cross.level) weaponsLib.cross.tick(weaponsState.cross);
    if(weaponsState.holywater.level) weaponsLib.holywater.update && weaponsLib.holywater.update(weaponsState.holywater);
    if(weaponsState.kingbible.level) weaponsLib.kingbible.update(weaponsState.kingbible, 16);
    if(weaponsState.magicwand.level) weaponsLib.magicwand.shoot(weaponsState.magicwand); // auto shots included in main loop too
    if(weaponsState.firewand.level) weaponsLib.firewand.shoot(weaponsState.firewand);
    if(weaponsState.ebony.level) weaponsLib.ebony.shoot(weaponsState.ebony);
    if(weaponsState.whip.level) weaponsLib.whip.attack(weaponsState.whip);
    if(weaponsState.bloodwhip.level) { weaponsLib.bloodwhip.attack(weaponsState.bloodwhip); weaponsLib.bloodwhip.trailTick(weaponsState.bloodwhip); }
    if(weaponsState.knife.level) weaponsLib.knife.shoot(weaponsState.knife);
  }

  /* ---------- Orbs & chests ---------- */
  function updateOrbs(){
    for(let i=orbs.length-1;i>=0;i--){
      const o = orbs[i];
      // pickups
      if(dist(o, player) < player.size + 10){
        let gain = o.value || 1;
        if(weaponsState.__xpBoost && weaponsState.__xpBoost > 0){ gain += 1; weaponsState.__xpBoost--; }
        xp += gain; orbs.splice(i,1); if(xp >= xpToNext) levelUp();
        continue;
      } else {
        const d = Math.hypot(o.x - player.x, o.y - player.y);
        if(d < 36){ o.x += (player.x - o.x) * 0.06; o.y += (player.y - o.y) * 0.06; }
      }
      // fire orbs do damage to enemies
      if(o.fire && o.life !== undefined){
        o.life -= 16;
        for(let j=enemies.length-1;j>=0;j--){
          const e = enemies[j];
          if(Math.hypot(e.x - o.x, e.y - o.y) < 10 + e.size){ e.hp -= (o.dmg||1); if(e.hp <= 0){ spawnOrbAt(e.x,e.y); enemies.splice(j,1); score++; } }
        }
        if(o.life <= 0) orbs.splice(i,1);
      }
    }
  }

  function updateChests(){
    for(let i = chests.length-1; i>=0; i--){
      const c = chests[i];
      if(!c) continue;
      c.y -= Math.sin((performance.now()+ (c.offset||0))/300)*0.04;
      if(dist(c, player) < player.size + 18){
        applyChestReward(c);
        showChestPopup(`¡Cofre abierto! ${c.rewardText || ''}`);
        chests.splice(i,1);
        continue;
      }
      if(performance.now() - (c.spawned||0) > 30000) chests.splice(i,1);
    }
  }

  /* ---------- Boss ---------- */
  function spawnBoss(){
    const side = Math.random() < 0.5 ? -1 : 1;
    const x = side === -1 ? -120 : canvas.width + 120; const y = Math.random()*canvas.height;
    const minutes = Math.floor((performance.now()-gameStartTimestamp)/60000);
    const baseHp = Math.round((260 + minutes*80) * 0.8);
    const baseSize = 48 + minutes*8;
    const speed = 0.35 + Math.random()*0.35;
    boss = { x,y,hp: baseHp, maxHp: baseHp, size: baseSize, speed, color:'#8e44ad', spawned: performance.now(), contactDamage: 10 };
  }
  function updateBoss(dt){
    if(!boss) return;
    const ang = Math.atan2(player.y - boss.y, player.x - boss.x);
    boss.x += Math.cos(ang) * boss.speed * (dt/16);
    boss.y += Math.sin(ang) * boss.speed * (dt/16);
    if(Math.hypot(boss.x - player.x, boss.y - player.y) < player.size + boss.size){
      player.hp -= boss.contactDamage * (dt/16);
      if(player.hp <= 0) onDeath();
    }
  }
  function killBoss(){ if(!boss) return; chests.push({ x: boss.x, y: boss.y, spawned: performance.now(), offset: Math.random()*9999 }); boss = null; }

  function applyChestReward(chest){
    const owned = Object.keys(weaponsState).filter(k => (weaponsState[k].level||0) > 0 && weaponsState[k].level < (weaponsLib[k]?.maxLevel||10));
    if(owned.length){
      const pick = randChoice(owned);
      weaponsState[pick].level = Math.min(weaponsLib[pick].maxLevel || 10, weaponsState[pick].level + 1);
      applyWeaponLevelEffects(pick); chest.rewardText = `${weaponsLib[pick].name} +1 nivel`;
    } else { player.hp = Math.min(player.maxHp, player.hp + 25); chest.rewardText = `Vida +25 (fallback)`; }
  }

  /* ---------- Leveling & death ---------- */
  function levelUp(){ level++; xp = xp - xpToNext; xpToNext = Math.max(5, Math.floor(xpToNext * 1.22)); player.hp = Math.min(player.maxHp, player.hp + 10); openLevelMenu(); }
  function onDeath(){ if(dead) return; dead = true; gamePaused = true; deathPanelEl.style.display = 'block'; document.getElementById('deathScore').textContent = 'Puntos: ' + score + ' | Nivel alcanzado: ' + level; }

  btnRestart && btnRestart.addEventListener('click', ()=>{
    // graceful restart
    deathPanelEl.style.display = 'none'; dead = false; gamePaused = false;
    score = 0; xp = 0; level = 1; xpToNext = 15; time = 0;
    player.x = canvas.width/2; player.y = canvas.height/2; player.hp = player.maxHp;
    enemies = []; bullets = []; orbs = []; meleeAttacks = []; boss = null; chests = [];
    for(let i=0;i<4;i++) spawnEnemy();
    gameStartTimestamp = performance.now(); lastBossSpawn = performance.now() + 10000;
  });

  /* ---------- Rendering ---------- */
  function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // solar areas (song of mana radius) drawn as faint circles
    if(weaponsState.songofmana.level){
      const s = weaponsLib.songofmana.statsForLevel(weaponsState.songofmana.level);
      ctx.fillStyle = 'rgba(100,150,255,0.04)';
      ctx.beginPath(); ctx.arc(player.x, player.y, s.radius, 0, Math.PI*2); ctx.fill();
    }
    // orbs
    for(const o of orbs){ ctx.fillStyle = o.fire ? '#e66' : '#f1c40f'; ctx.beginPath(); ctx.arc(o.x, o.y, 6, 0, Math.PI*2); ctx.fill(); }
    // chests
    for(const c of chests){ ctx.fillStyle = '#9b59b6'; ctx.beginPath(); ctx.arc(c.x, c.y, 12, 0, Math.PI*2); ctx.fill(); }
    // player
    ctx.fillStyle = '#3498db'; ctx.beginPath(); ctx.arc(player.x, player.y, player.size, 0, Math.PI*2); ctx.fill();
    // enemies
    for(const e of enemies){ ctx.fillStyle = e.color || '#e74c3c'; ctx.beginPath(); ctx.arc(e.x, e.y, e.size, 0, Math.PI*2); ctx.fill(); }
    // boss
    if(boss){ ctx.fillStyle = boss.color || '#8e44ad'; ctx.beginPath(); ctx.arc(boss.x, boss.y, boss.size, 0, Math.PI*2); ctx.fill(); }
    // bullets & projectiles
    for(const b of bullets){
      if(b.type === 'puddle'){ ctx.fillStyle = 'rgba(120,200,255,0.08)'; ctx.beginPath(); ctx.arc(b.x,b.y,b.radius||12,0,Math.PI*2); ctx.fill(); continue; }
      ctx.fillStyle = b.type === 'firewand' ? '#e67e22' : b.type === 'magicwand' ? '#7ff' : '#fff';
      ctx.beginPath(); ctx.arc(b.x, b.y, b.size || 4, 0, Math.PI*2); ctx.fill();
    }
    // melee arcs
    for(const m of meleeAttacks){
      ctx.strokeStyle = m.type === 'whip' ? 'rgba(200,200,255,0.75)' : 'rgba(255,255,255,0.25)';
      ctx.lineWidth = m.thickness || 3;
      ctx.beginPath(); ctx.arc(m.x, m.y, m.range, m.angle - (m.arc||0.6)/2, m.angle + (m.arc||0.6)/2); ctx.stroke();
      if(m.twin){ // draw other horizontal direction
        ctx.beginPath(); ctx.arc(m.x, m.y, m.range, Math.PI - (m.arc||0.6)/2, Math.PI + (m.arc||0.6)/2); ctx.stroke();
      }
    }
    // king bible orbs
    if(weaponsState.kingbible.level && weaponsState.kingbible.active && weaponsState.kingbible.orbs){
      ctx.fillStyle = 'rgba(255,255,150,0.95)';
      for(const o of weaponsState.kingbible.orbs){ if(!o) continue; const x = player.x + Math.cos(o.angle) * weaponsLib.kingbible.statsForLevel(weaponsState.kingbible.level).radius; const y = player.y + Math.sin(o.angle) * weaponsLib.kingbible.statsForLevel(weaponsState.kingbible.level).radius; ctx.beginPath(); ctx.arc(x,y,10,0,Math.PI*2); ctx.fill(); }
    }
  }

  /* ---------- Game Loop ---------- */
  let lastFrame = performance.now();
  function gameLoop(now){
    const dt = now - lastFrame; lastFrame = now;
    if(!gamePaused && !dead){
      time += dt;
      timerEl.textContent = formatTime(performance.now() - gameStartTimestamp);
      spawnInterval = Math.max(450, BASE_SPAWN_INTERVAL - Math.floor(time/10000)*20);
      if(now - lastSpawnTime > spawnInterval){ lastSpawnTime = now; if(enemies.length < 30) spawnEnemy(); }
      if(!boss && (now - lastBossSpawn > BOSS_INTERVAL)){ spawnBoss(); lastBossSpawn = now; }
      updatePlayer(dt);
      updateSolar(now);
      updateBullets(dt);
      updateMelee(dt);
      updateEnemies(dt);
      updateOrbs();
      updateChests();
      if(boss) updateBoss(dt);
    }
    render();
    updateHUD();
    requestAnimationFrame(gameLoop);
  }
  requestAnimationFrame(gameLoop);

  /* ---------- Init ---------- */
  for(let i=0;i<4;i++) spawnEnemy();
  gameStartTimestamp = performance.now(); lastBossSpawn = performance.now() + 10000;
  updateHUD();
  window.__VS = { weaponsLib, weaponsState, player, enemies, orbs, bullets, chests, spawnEnemy, spawnBoss: ()=>{ lastBossSpawn = 0; }, killBoss, levelUp };

  /* ---------- UI wiring (menus & buttons) ---------- */
  function safeOn(el, ev, fn){
    if(!el) return;
    // remove previous handlers
    el.replaceWith(el.cloneNode(true));
    const fresh = document.getElementById(el.id);
    fresh.addEventListener(ev, fn);
    return fresh;
  }

  // Play -> show char select
  safeOn(btnPlay,'click', ()=>{
    mainMenuEl.style.display = 'none';
    showCharacterSelect();
  });

  // Info -> open info panel
  safeOn(btnInfo,'click', ()=>{
    mainMenuEl.style.display = 'none'; infoPanelEl.style.display = 'flex'; populateInfoPanel();
  });

  // Quit (no-op or close)
  safeOn(btnQuit,'click', ()=>{ console.log('Volver pulsado'); });

  // Char back
  safeOn(btnCharBack,'click', ()=>{ charSelectEl.style.display = 'none'; mainMenuEl.style.display = 'flex'; });

  // Info back
  safeOn(btnInfoBack,'click', ()=>{ infoPanelEl.style.display = 'none'; mainMenuEl.style.display = 'flex'; });

  // ensure restart handled earlier

  // Character selection screen population
  function showCharacterSelect(){
    const choices = charSelectEl.querySelector('#charChoices'); choices.innerHTML = '';
    const characters = [
      { name: 'Pistolero', unlocked: true },
      { name: 'Espadachín', unlocked: true },
      { name: 'Mago', unlocked: true }
    ];
    characters.forEach(c=>{
      const btn = document.createElement('button'); btn.className = 'choice'; btn.textContent = c.name;
      btn.addEventListener('click', ()=>{
        if(!c.unlocked) return;
        charSelectEl.style.display = 'none'; mainMenuEl.style.display = 'none';
        // start game state
        gamePaused = false; dead = false; score = 0; xp = 0; level = 1; xpToNext = 15; time = 0;
        player.x = canvas.width/2; player.y = canvas.height/2; player.hp = player.maxHp;
        enemies = []; bullets = []; orbs = []; meleeAttacks = []; boss = null; chests = [];
        for(let i=0;i<4;i++) spawnEnemy();
        gameStartTimestamp = performance.now(); lastBossSpawn = performance.now() + 10000;
      });
      choices.appendChild(btn);
    });
  }
  window.showCharacterSelect = showCharacterSelect;

  // Info panel population
  function populateInfoPanel(){
    const content = infoPanelEl.querySelector('#infoContent'); content.innerHTML = '';
    for(const id in weaponsLib){
      const w = weaponsLib[id]; const lvl = weaponsState[id]?.level || 0;
      const div = document.createElement('div'); div.style.marginBottom = '6px';
      div.textContent = `${w.name} — Nivel: ${lvl}`;
      content.appendChild(div);
    }
  }
  // attach populate to info open
  safeOn(btnInfo, 'click', ()=> populateInfoPanel());

  // Show main menu initially
  function showMainMenu(){
    mainMenuEl.style.display = 'flex'; charSelectEl.style.display = 'none'; infoPanelEl.style.display = 'none'; levelMenuEl.style.display = 'none'; deathPanelEl.style.display = 'none'; gamePaused = true;
  }
  showMainMenu();

  // small debug ticker
  setInterval(()=> { debugEl.textContent = `Enemies:${enemies.length} Chests:${chests.length} Orbs:${orbs.length} Time:${Math.floor(time/1000)}s`; }, 700);

}); // DOMContentLoaded end
</script>
</body>
</html>
