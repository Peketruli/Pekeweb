<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Monopoly ‚Äî OnePlayer / Multiplayer (Supabase)</title>
<style>
  :root{
    --bg:#cfe7ef;
    --panel:#fff;
    --leftWidth:240px;
    --hand-gap:10px;
    --accent:#2b8aef;
  }
  html,body{height:100%; margin:0; padding:0; background:var(--bg); font-family:Arial,Helvetica,sans-serif; color:#111}
  /* Layout: left column (hands) | center (board) | right (hud) */
  #page {
    display:grid;
    grid-template-columns: var(--leftWidth) 700px 360px;
    gap:18px;
    justify-content:center;
    align-items:start;
    padding:18px;
    min-height:100vh;
    box-sizing:border-box;
  }

  /* LEFT: Hands column */
  #leftCol {
    display:flex;
    flex-direction:column;
    gap:var(--hand-gap);
    align-items:stretch;
  }
  .handPanel {
    background:#0b6b3a; /* default for player */
    color:#fff;
    padding:8px;
    border-radius:8px;
    box-shadow:0 6px 18px rgba(0,0,0,0.12);
    min-height:180px;
  }
  .handPanel.ai { background:#23394d; color:#f7eab6; } /* AI style */
  .handTitle { font-weight:700; font-size:14px; margin-bottom:6px; display:flex;justify-content:space-between; align-items:center;}
  .handGrid { display:flex; flex-wrap:wrap; gap:8px; align-items:flex-start; }
  .handCard {
    width:100px;
    background:#fff;
    color:#111;
    border-radius:6px;
    padding:6px;
    box-shadow:0 6px 14px rgba(0,0,0,0.12);
    cursor:pointer;
    font-size:12px;
    position:relative;
    transition:transform .14s ease, box-shadow .14s ease;
  }
  .handCard:hover{ transform:translateY(-6px); box-shadow:0 12px 20px rgba(0,0,0,0.18); }
  .handCard .stripe { height:10px; border-radius:4px; margin-bottom:6px; }
  .handEmpty { opacity:0.7; font-size:13px; }

  /* CENTER: Board */
  #centerCol { display:flex; justify-content:center; align-items:flex-start; position:relative; }
  canvas { background:#fafafa; border:4px solid #333; box-shadow:0 8px 30px rgba(0,0,0,0.12); display:block; }

  /* RIGHT: HUD */
  #hud {
    width:360px; background:var(--panel); padding:14px; border-radius:8px; box-shadow:0 6px 20px rgba(0,0,0,0.08); max-height:82vh; overflow:auto;
  }
  h2{margin:6px 0 10px;font-size:18px;text-align:center;}
  .btn{display:block; width:100%; padding:10px; margin:8px 0; border-radius:6px; border:none; font-weight:600; cursor:pointer;}
  #rollBtn{background:var(--accent);color:#fff;}
  #payJailBtn{background:#e67e22;color:#fff; display:none;}
  #useCardBtn{background:#27ae60;color:#fff; display:none;}
  .info{background:#f3f6f8;padding:8px;border-radius:6px;margin-top:8px; font-size:14px; color:#111;}
  .small{font-size:13px;color:#444;margin-top:6px;}
  .playersList{margin-top:8px;}
  .playerRow{display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px dashed #eee;color:#111;}
  .center{display:flex;gap:8px;align-items:center;justify-content:center;}

  /* Prop modal (central) with animation */
  #propModal{position:fixed;left:0;top:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:9999}
  #propBox{
    width:460px;background:#fff;padding:18px;border-radius:12px;color:#111;
    box-shadow:0 20px 60px rgba(0,0,0,0.45);
    transform:scale(.9); opacity:0; transition:transform .32s cubic-bezier(.2,.9,.2,1), opacity .24s ease;
  }
  #propModal.show #propBox{ transform:scale(1); opacity:1; }
  #propBox h3{margin:0 0 8px; font-size:20px}
  .line{margin:6px 0}
  #propBox .btn{width:auto;margin-left:6px;padding:8px 10px;border-radius:6px}

  /* Card modal for deck reveals (also animated) */
  #cardModal{position:fixed;left:0;top:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:9998}
  #cardBox{width:380px;background:#fff;padding:16px;border-radius:10px;color:#111; transform:translateY(8px); opacity:0; transition:transform .28s ease, opacity .18s ease;}
  #cardModal.show #cardBox{ transform:translateY(0); opacity:1; }

  /* MENU overlay */
  #menuOverlay{position:fixed;inset:0;background:linear-gradient(180deg, rgba(10,10,10,0.5), rgba(10,10,10,0.55)); display:flex;align-items:center;justify-content:center;z-index:99999}
  #menuBox{width:720px;background:#fff;padding:22px;border-radius:12px; box-shadow:0 24px 80px rgba(0,0,0,0.5); text-align:center;}
  #menuBox h1{margin:0 0 8px}
  #menuButtons{display:flex;gap:12px;justify-content:center;margin-top:16px}
  .menuBtn{padding:12px 18px;border-radius:8px;border:none;font-weight:700;cursor:pointer}
  .menuBtn.primary{background:var(--accent);color:#fff}
  .menuBtn.alt{background:#2ecc71;color:#fff}

  /* Room UI */
  #roomPanel{margin-top:12px; display:flex; gap:8px; align-items:center; justify-content:center; flex-direction:column;}
  #roomPanel .row{display:flex; gap:8px; width:100%}

  /* floating card used in animation */
  .floatingCard { position:fixed; width:160px; height:100px; background:#fff; border-radius:8px; box-shadow:0 12px 30px rgba(0,0,0,0.25); display:flex;align-items:center;justify-content:center;font-weight:700; z-index:99997; pointer-events:none; }

  /* small responsive */
  @media(max-width:1200px){
    #page { grid-template-columns: 200px 700px 320px; }
    :root{--leftWidth:200px;}
    #menuBox{width:92%;}
  }

  /* subtle HUD micro styles */
  .muted{color:#666;font-size:13px}
  .copyBtn{background:#95a5a6;color:#fff;padding:8px;border-radius:6px;border:none;cursor:pointer}
</style>
</head>
<body>
<!-- MENU overlay -->
<div id="menuOverlay" aria-hidden="false">
  <div id="menuBox" role="dialog" aria-modal="true">
    <h1>Monopoly ‚Äî Modo de juego</h1>
    <div class="muted">Elige One Player para jugar contra la IA o Multiplayer para jugar online (Supabase).</div>
    <div id="menuButtons">
      <button id="onePlayerBtn" class="menuBtn primary">One Player</button>
      <button id="multiplayerBtn" class="menuBtn alt">Multiplayer</button>
    </div>

    <div id="roomPanel" style="display:none;margin-top:16px">
      <div class="row">
        <input id="roomInput" placeholder="ID sala (o vac√≠o para crear)" style="flex:1;padding:8px;border-radius:6px;border:1px solid #ddd"/>
        <button id="createRoomBtn" class="copyBtn">Crear sala</button>
        <button id="joinRoomBtn" class="copyBtn">Unirse</button>
      </div>
      <div class="row" style="justify-content:center;">
        <small class="muted">O copia el c√≥digo de la sala y comp√°rtelo con tu amigo.</small>
      </div>
      <div class="row" style="justify-content:center;">
        <button id="listRoomsBtn" class="copyBtn">Listar salas (√∫ltimas)</button>
      </div>
      <div id="roomsList" style="max-height:160px; overflow:auto; width:100%; margin-top:8px;"></div>
      <div style="margin-top:10px;"><small class="muted">Para multiplayer: introduce tu SUPABASE_URL y SUPABASE_KEY en el c√≥digo (ver comentarios).</small></div>
    </div>
  </div>
</div>

<div id="page" aria-hidden="false">
  <!-- LEFT: hands column -->
  <div id="leftCol">
    <div id="playerHandPanel" class="handPanel">
      <div class="handTitle"><span>Tu mano</span><span id="playerMoney" style="font-weight:600">$1500</span></div>
      <div id="playerHand" class="handGrid"><div class="handEmpty">Sin propiedades</div></div>
    </div>

    <div id="aiHandPanel" class="handPanel ai">
      <div class="handTitle"><span>Mano Oponente</span><span id="aiMoney" style="font-weight:600">$1500</span></div>
      <div id="aiHand" class="handGrid"><div class="handEmpty">Sin propiedades</div></div>
    </div>
  </div>

  <!-- CENTER: board -->
  <div id="centerCol">
    <canvas id="gameCanvas" width="700" height="700"></canvas>
  </div>

  <!-- RIGHT: HUD -->
  <div id="hud">
    <h2>Monopoly ‚Äî Turno: <span id="turnName">Jugador</span></h2>
    <div class="playersList" id="playersList"></div>

    <div class="center">
      <button id="rollBtn" class="btn">üé≤ Tirar dados</button>
    </div>

    <div class="center small">
      <button id="payJailBtn" class="btn" style="width:auto;padding:8px 10px;">üíµ Pagar $50 y salir</button>
      <button id="useCardBtn" class="btn" style="width:auto;padding:8px 10px;">üÉè Usar "Salir de la c√°rcel"</button>
    </div>

    <div class="info" id="infoBox">Bienvenido ‚Äî pulsa "Tirar dados".</div>

    <div class="small" style="margin-top:10px;">
      <strong>Cartas en mesa:</strong>
      <div>Suerte: <span id="suerteCount"></span> ‚Äî Arca: <span id="arcaCount"></span></div>
    </div>

    <div style="margin-top:12px;">
      <div class="hudTitle">Acciones r√°pidas</div>
      <div style="display:flex;gap:6px;margin-top:6px">
        <button id="endTurnBtn" class="btn" style="background:#95a5a6;color:#fff;width:50%">Terminar</button>
        <button id="toggleIAPropBtn" class="btn" style="background:#6c5ce7;color:#fff;width:50%">Mostrar oponente</button>
      </div>
    </div>

    <div id="multiplayerStatus" style="margin-top:12px;display:none;">
      <div class="muted">Multiplayer: <span id="roomIdDisplay">‚Äî</span></div>
      <div style="display:flex;gap:6px;margin-top:6px">
        <button id="copyRoomBtn" class="copyBtn">Copiar ID</button>
        <button id="leaveRoomBtn" class="copyBtn" style="background:#e74c3c;color:#fff">Salir sala</button>
      </div>
    </div>

  </div>
</div>

<!-- Card modal for deck reveals -->
<div id="cardModal" role="dialog" aria-hidden="true">
  <div id="cardBox">
    <div id="cardText">Contenido de la carta</div>
    <div style="display:flex; justify-content:flex-end; margin-top:8px;">
      <button id="closeCardBtn" class="copyBtn">Cerrar</button>
    </div>
  </div>
</div>

<!-- Property detail modal -->
<div id="propModal" aria-hidden="true">
  <div id="propBox">
    <h3 id="pmName"></h3>
    <div id="pmColor" style="height:14px;width:100%;border-radius:4px;margin:8px 0"></div>
    <div class="line"><strong>Precio compra:</strong> $<span id="pmPrice"></span></div>
    <div class="line"><strong>Costo por casa:</strong> $<span id="pmHouseCost"></span></div>
    <div class="line"><strong>Costo hotel:</strong> $<span id="pmHotelCost"></span></div>
    <div class="line"><strong>Rentas:</strong></div>
    <div id="pmRents" class="line" style="margin-left:8px"></div>
    <div class="line"><strong>Mejoras actuales:</strong> <span id="pmImprovements"></span></div>
    <div style="display:flex;justify-content:flex-end;margin-top:10px">
      <button id="buyPropBtn" class="btn" style="width:auto;background:var(--accent);color:#fff;padding:8px 10px">Comprar</button>
      <button id="buyHouseBtn" class="btn" style="width:auto;background:#2ecc71;color:#fff;padding:8px 10px;margin-left:6px">Comprar casa</button>
      <button id="buyHotelBtn" class="btn" style="width:auto;background:#e67e22;color:#fff;padding:8px 10px;margin-left:6px">Comprar hotel</button>
      <button id="closePropBtn" class="btn" style="width:auto;background:#95a5a6;color:#fff;padding:8px 10px;margin-left:6px">Cerrar</button>
    </div>
    <div id="propMsg" style="margin-top:8px;color:#b33;"></div>
  </div>
</div>

<!-- include supabase client (only used if you paste your keys) -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>

<script>
/* ----------------- CONFIG: put your Supabase values here for multiplayer -----------------
   If you don't want multiplayer, leave them empty and use One Player.
   IMPORTANT: use ANON public key (not your service_role) in client-side code.
*/
const SUPABASE_URL = "https://jdvwlfogkzrzovepzjqa.supabase.co"; // <-- pega aqu√≠ tu URL supabase
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpkdndsZm9na3pyem92ZXB6anFhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwMzY1MjEsImV4cCI6MjA3MzYxMjUyMX0.IwVFrvuluY0tfgE82XnqYSsRjFPsDYnlfyirHjKu1TI"; // <-- pega aqu√≠ tu KEY publica (anon)
let supabase = null;
if(SUPABASE_URL && SUPABASE_KEY){
  supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
}

/* ----------------- GLOBAL GAME STATE (based on your previous code) ----------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const SIZE = 700;
const CORNER = 100;
const SIDE_COUNT_BETWEEN_CORNERS = 9;
const SIDE_CELL_SIZE = (SIZE - CORNER*2) / SIDE_COUNT_BETWEEN_CORNERS;

const board = [ /* same board as before - abbreviated for brevity in comment; full entries below */ ];

(function populateBoard(){
  const names = [
  {name:"Salida", type:"especial"},
  {name:"Ronda de Valencia", color:"#8B4513", price:60, type:"propiedad"},
  {name:"Comunidad", type:"arca"},
  {name:"Plaza Lavapi√©s", color:"#8B4513", price:60, type:"propiedad"},
  {name:"Impuesto", type:"impuesto"},
  {name:"Estaci√≥n Mediod√≠a", type:"estacion", price:200},
  {name:"Glorieta Cuatro Caminos", color:"#ADD8E6", price:100, type:"propiedad"},
  {name:"Suerte", type:"suerte"},
  {name:"Avenida Reina Victoria", color:"#ADD8E6", price:100, type:"propiedad"},
  {name:"Calle Bravo Murillo", color:"#ADD8E6", price:120, type:"propiedad"},
  {name:"C√°rcel", type:"especial"},
  {name:"Glorieta Bilbao", color:"#FFC0CB", price:140, type:"propiedad"},
  {name:"Compa√±√≠a electricidad", type:"compa√±ia", price:150},
  {name:"Calle Alberto Aguilera", color:"#FFC0CB", price:140, type:"propiedad"},
  {name:"Calle Fuencarral", color:"#FFC0CB", price:160, type:"propiedad"},
  {name:"Estaci√≥n Norte", type:"estacion", price:200},
  {name:"Avenida Felipe II", color:"#FFA500", price:180, type:"propiedad"},
  {name:"Comunidad", type:"arca"},
  {name:"Calle Serrano", color:"#FFA500", price:180, type:"propiedad"},
  {name:"Calle Vel√°zquez", color:"#FFA500", price:200, type:"propiedad"},
  {name:"Parking", type:"especial"},
  {name:"Avenida de Am√©rica", color:"#FF0000", price:220, type:"propiedad"},
  {name:"Suerte", type:"suerte"},
  {name:"Calle Mar√≠a de Molina", color:"#FF0000", price:220, type:"propiedad"},
  {name:"Calle Cea Berm√∫dez", color:"#FF0000", price:240, type:"propiedad"},
  {name:"Estaci√≥n Delicias", type:"estacion", price:200},
  {name:"Avenida de los Poblados", color:"#FFFF00", price:260, type:"propiedad"},
  {name:"Calle O'Donnell", color:"#FFFF00", price:260, type:"propiedad"},
  {name:"Compa√±√≠a de agua", type:"compa√±ia", price:150},
  {name:"Calle Goya", color:"#FFFF00", price:280, type:"propiedad"},
  {name:"Ve a la c√°rcel", type:"especial"},
  {name:"Calle Alcal√°", color:"#008000", price:300, type:"propiedad"},
  {name:"Calle Gran V√≠a", color:"#008000", price:300, type:"propiedad"},
  {name:"Comunidad", type:"arca"},
  {name:"Paseo de la Castellana", color:"#008000", price:320, type:"propiedad"},
  {name:"Estaci√≥n Sur", type:"estacion", price:200},
  {name:"Suerte", type:"suerte"},
  {name:"Paseo del Prado", color:"#0000FF", price:350, type:"propiedad"},
  {name:"Impuesto de lujo", type:"impuesto"},
  {name:"Calle Serrano Mayor", color:"#0000FF", price:400, type:"propiedad"}
  ];
  // copy into board array
  while(board.length) board.pop();
  for(let c of names) board.push(JSON.parse(JSON.stringify(c)));
})();

/* add propertyData template */
for(let c of board){
  if(c.type === "propiedad" && c.price){
    const base = Math.max(1, Math.floor(c.price * 0.1));
    c.propertyData = {
      price: c.price,
      rent: [
        base,
        Math.floor(base * 3),
        Math.floor(base * 8),
        Math.floor(base * 18),
        Math.floor(base * 30),
        Math.floor(base * 50)
      ],
      houseCost: Math.max(10, Math.floor(c.price * 0.5)),
      hotelCost: Math.max(10, Math.floor(c.price * 0.5)),
      houses: 0,
      hotel: false
    };
  }
  if((c.type === "estacion" || c.type === "compa√±ia") && c.price){
    c.propertyData = { price: c.price, houses:0, hotel:false };
  }
}

/* players skeleton; multiplayer will replace names/ids */
let players = [
  {id: "local1", name:"Jugador", color:"#1f77b4", pos:0, money:1500, properties:[], inJail:false, jailTurns:0, hasGetOutCard:false},
  {id: "local2", name:"Oponente", color:"#d62728", pos:0, money:1500, properties:[], inJail:false, jailTurns:0, hasGetOutCard:false}
];

let current = 0;
let animating = false;
let diceRolling = false;
let diceResult = [1,1];
let lastRollWasDouble = false;
let suerteDeck = [], arcaDeck = [];

/* UI refs */
const playerHandDiv = document.getElementById('playerHand');
const aiHandDiv = document.getElementById('aiHand');
const playerMoneyEl = document.getElementById('playerMoney');
const aiMoneyEl = document.getElementById('aiMoney');
const rollBtn = document.getElementById('rollBtn');
const payJailBtn = document.getElementById('payJailBtn');
const useCardBtn = document.getElementById('useCardBtn');
const infoBox = document.getElementById('infoBox');
const turnName = document.getElementById('turnName');
const playersListDiv = document.getElementById('playersList');
const suerteCount = document.getElementById('suerteCount');
const arcaCount = document.getElementById('arcaCount');
const cardModal = document.getElementById('cardModal');
const cardTextEl = document.getElementById('cardText');
const closeCardBtn = document.getElementById('closeCardBtn');
const propModal = document.getElementById('propModal');
const propBox = document.getElementById('propBox');
const pmName = document.getElementById('pmName');
const pmColor = document.getElementById('pmColor');
const pmPrice = document.getElementById('pmPrice');
const pmHouseCost = document.getElementById('pmHouseCost');
const pmHotelCost = document.getElementById('pmHotelCost');
const pmRents = document.getElementById('pmRents');
const pmImprovements = document.getElementById('pmImprovements');
const buyHouseBtn = document.getElementById('buyHouseBtn');
const buyHotelBtn = document.getElementById('buyHotelBtn');
const buyPropBtn = document.getElementById('buyPropBtn');
const closePropBtn = document.getElementById('closePropBtn');
const propMsg = document.getElementById('propMsg');

/* Menu & multiplayer UI */
const menuOverlay = document.getElementById('menuOverlay');
const onePlayerBtn = document.getElementById('onePlayerBtn');
const multiplayerBtn = document.getElementById('multiplayerBtn');
const roomPanel = document.getElementById('roomPanel');
const roomInput = document.getElementById('roomInput');
const createRoomBtn = document.getElementById('createRoomBtn');
const joinRoomBtn = document.getElementById('joinRoomBtn');
const listRoomsBtn = document.getElementById('listRoomsBtn');
const roomsList = document.getElementById('roomsList');
const multiplayerStatus = document.getElementById('multiplayerStatus');
const roomIdDisplay = document.getElementById('roomIdDisplay');
const copyRoomBtn = document.getElementById('copyRoomBtn');
const leaveRoomBtn = document.getElementById('leaveRoomBtn');

/* state for multiplayer */
let inMultiplayer = false;
let roomId = null;
let myPlayerIndex = 0; // 0 or 1 in multiplayer
let pollInterval = null;

/* helpers */
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
function showMsg(t){ infoBox.textContent = t; }
function uid(len=6){ return Math.random().toString(36).slice(2,2+len).toUpperCase(); }

/* decks */
function createDecks(){
  suerteDeck = [
    {text:"Avanza a Salida. Cobra $200.", action:(p)=>{ p.pos=0; p.money+=200; showMsg(`${p.name} avanza a Salida y cobra $200`); }},
    {text:"Ve a la C√°rcel (no cobras por pasar).", action:(p)=>{ p.pos=10; p.inJail=true; p.jailTurns=0; showMsg(`${p.name} va a la c√°rcel`); }},
    {text:"Cobras $150.", action:(p)=>{ p.money+=150; showMsg(`${p.name} cobra $150`); updateHUD(); }},
    {text:"Paga $50.", action:(p)=>{ p.money-=50; showMsg(`${p.name} paga $50`); updateHUD(); }},
    {text:"Toma tarjeta 'Salir de la c√°rcel'.", action:(p)=>{ p.hasGetOutCard=true; addCardToPlayerHand(p, {name:"Salir de la c√°rcel", type:"card", desc:"Usa para salir de la c√°rcel"}); showMsg(`${p.name} obtiene 'Salir de la c√°rcel'`); }},
    {text:"Avanza a Paseo del Prado.", action:(p)=>{ p.pos=38; showMsg(`${p.name} avanza a Paseo del Prado`); }},
    {text:"Avanza a la pr√≥xima estaci√≥n. Paga si no es tuya.", action:(p)=>{ advanceToNextStation(p); }}
  ];
  arcaDeck = [
    {text:"Cobras $100.", action:(p)=>{ p.money+=100; showMsg(`${p.name} cobra $100`); updateHUD(); }},
    {text:"Paga $50.", action:(p)=>{ p.money-=50; showMsg(`${p.name} paga $50`); updateHUD(); }},
    {text:"Toma tarjeta 'Salir de la c√°rcel'.", action:(p)=>{ p.hasGetOutCard=true; addCardToPlayerHand(p, {name:"Salir de la c√°rcel", type:"card", desc:"Usa para salir de la c√°rcel"}); showMsg(`${p.name} obtiene 'Salir de la c√°rcel'`); }},
    {text:"Recibe $40 de otros (simplificado).", action:(p)=>{ p.money+=40; showMsg(`${p.name} recibe $40 (simplificado)`); updateHUD(); }},
    {text:"Avanza a Salida. Cobra $200.", action:(p)=>{ p.pos=0; p.money+=200; showMsg(`${p.name} avanza a Salida y cobra $200`); updateHUD(); }}
  ];
  shuffle(suerteDeck);
  shuffle(arcaDeck);
}

/* geometry */
function getCellRect(index){
  if(index === 0) return { x: SIZE - CORNER, y: SIZE - CORNER, w: CORNER, h: CORNER };
  if(index === 10) return { x: 0, y: SIZE - CORNER, w: CORNER, h: CORNER };
  if(index === 20) return { x: 0, y: 0, w: CORNER, h: CORNER };
  if(index === 30) return { x: SIZE - CORNER, y: 0, w: CORNER, h: CORNER };

  if(index > 0 && index < 10){
    const i = index;
    const w = SIDE_CELL_SIZE;
    const h = CORNER;
    const x = SIZE - CORNER - w * i;
    const y = SIZE - CORNER;
    return { x, y, w, h };
  }
  if(index > 10 && index < 20){
    const i = index - 10;
    const w = CORNER;
    const h = SIDE_CELL_SIZE;
    const x = 0;
    const y = SIZE - CORNER - h * i;
    return { x, y, w, h };
  }
  if(index > 20 && index < 30){
    const i = index - 20;
    const w = SIDE_CELL_SIZE;
    const h = CORNER;
    const x = CORNER + w * (i - 1);
    const y = 0;
    return { x, y, w, h };
  }
  if(index > 30 && index < 40){
    const i = index - 30;
    const w = CORNER;
    const h = SIDE_CELL_SIZE;
    const x = SIZE - CORNER;
    const y = CORNER + h * (i - 1);
    return { x, y, w, h };
  }
  return { x:0,y:0,w:CORNER,h:CORNER };
}

/* draw helpers (wrap text) */
function wrapText(ctx, text, maxWidth){
  const words = text.split(' ');
  const lines = [];
  let line = "";
  for(let w of words){
    const test = line ? line + " " + w : w;
    if(ctx.measureText(test).width > maxWidth){
      lines.push(line);
      line = w;
    } else {
      line = test;
    }
  }
  if(line) lines.push(line);
  return lines;
}

/* draw board */
function drawBoard(){
  ctx.clearRect(0,0,SIZE,SIZE);
  ctx.lineWidth = 1;
  ctx.strokeStyle = "#222";

  for(let i=0;i<40;i++){
    const r = getCellRect(i);
    ctx.strokeRect(Math.round(r.x)+0.5, Math.round(r.y)+0.5, Math.round(r.w), Math.round(r.h));
  }

  ctx.textBaseline = "top";
  for(let i=0;i<40;i++){
    const cellInfo = board[i];
    const r = getCellRect(i);

    if(cellInfo.color && cellInfo.type && (cellInfo.type === "propiedad" || cellInfo.type === "estacion")){
      ctx.fillStyle = cellInfo.color;
      ctx.fillRect(r.x, r.y, r.w, Math.min(12, r.h));
    }

    ctx.fillStyle = "#111";
    ctx.font = `${Math.max(10, Math.floor(r.h/8))}px Arial`;
    const lines = wrapText(ctx, cellInfo.name, r.w - 8);
    const textX = r.x + 6;
    const textY = r.y + 16;
    for(let li=0; li<Math.min(lines.length, 4); li++){
      ctx.fillText(lines[li], textX, textY + li * (Math.max(10, Math.floor(r.h/10))));
    }

    ctx.font = "11px Arial";
    if(cellInfo.price && cellInfo.type !== "especial"){
      ctx.fillStyle = "#333";
      ctx.fillText(`$${cellInfo.price}`, r.x + 6, r.y + r.h - 16);
    } else if(cellInfo.type === "suerte" || cellInfo.type === "arca"){
      ctx.fillStyle = "#222";
      ctx.fillText(cellInfo.type.toUpperCase(), r.x + 6, r.y + r.h - 16);
    } else if(cellInfo.type === "impuesto"){
      ctx.fillStyle = "#b33";
      ctx.fillText("IMPUESTO", r.x + 6, r.y + r.h - 16);
    } else if(cellInfo.type === "especial"){
      ctx.fillStyle = "#000";
      ctx.font = "bold 13px Arial";
      const linesC = wrapText(ctx, cellInfo.name, r.w - 12);
      const startY = r.y + (r.h/2) - (linesC.length * 10);
      for(let li=0; li<linesC.length; li++){
        ctx.fillText(linesC[li], r.x + 6, startY + li*14);
      }
      ctx.font = "11px Arial";
    }

    if(cellInfo.owner){
      ctx.fillStyle = "#000";
      ctx.font = "11px Arial";
      ctx.fillText(`Owner: ${cellInfo.owner}`, r.x + r.w - 80, r.y + r.h - 16);
    }

    if(cellInfo.propertyData && (cellInfo.propertyData.houses > 0 || cellInfo.propertyData.hotel)){
      const n = cellInfo.propertyData.houses;
      const boxW = 8, boxH = 8;
      for(let k=0;k<n;k++){
        ctx.fillStyle = "#2ecc71";
        ctx.fillRect(r.x + 6 + k*(boxW+4), r.y + r.h - 30, boxW, boxH);
      }
      if(cellInfo.propertyData.hotel){
        ctx.fillStyle = "#e74c3c";
        ctx.fillRect(r.x + r.w - 18, r.y + r.h - 30, 12, 12);
      }
    }
  }

  // center decks
  const deckW = 60, deckH = 90;
  const centerX = SIZE/2, centerY = SIZE/2;
  ctx.fillStyle = "#fff"; ctx.fillRect(centerX - deckW - 12, centerY - deckH/2, deckW, deckH);
  ctx.strokeStyle = "#333"; ctx.strokeRect(centerX - deckW - 12, centerY - deckH/2, deckW, deckH);
  ctx.fillStyle = "#333"; ctx.font = "bold 12px Arial"; ctx.fillText("ARCA", centerX - deckW - 12 + 8, centerY - 6);
  ctx.fillStyle = "#fff"; ctx.fillRect(centerX + 12, centerY - deckH/2, deckW, deckH);
  ctx.strokeRect(centerX + 12, centerY - deckH/2, deckW, deckH);
  ctx.fillStyle = "#333"; ctx.fillText("SUERTE", centerX + 12 + 6, centerY - 6);

  ctx.font = "11px Arial";
  ctx.fillText(`${arcaDeck.length}`, centerX - deckW - 12 + deckW - 14, centerY + deckH/2 - 8);
  ctx.fillText(`${suerteDeck.length}`, centerX + 12 + deckW - 14, centerY + deckH/2 - 8);

  // tokens
  players.forEach((pl, idx) => {
    const r = getCellRect(pl.pos);
    const tx = r.x + r.w/2 + (idx===myPlayerIndex ? -14 : 14);
    const ty = r.y + r.h/2 + (idx===myPlayerIndex ? -10 : 10);
    ctx.fillStyle = pl.color; ctx.beginPath(); ctx.arc(tx, ty, 12, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.stroke();
  });
}

/* ---------- HAND UI & ANIMATION ---------- */
/* Create DOM card element for a property or card */
function createHandCardDOM(item){
  const el = document.createElement('div');
  el.className = 'handCard';
  const stripe = document.createElement('div');
  stripe.className = 'stripe';
  stripe.style.background = item.color || '#ddd';
  el.appendChild(stripe);
  const name = document.createElement('div'); name.textContent = item.name; name.style.fontWeight='700'; name.style.marginBottom='6px';
  el.appendChild(name);
  if(item.propertyData){
    const price = document.createElement('div'); price.textContent = `$${item.propertyData.price}`; price.style.fontSize='12px'; price.style.color='#444';
    el.appendChild(price);
    const imp = document.createElement('div'); imp.style.fontSize='12px'; imp.style.marginTop='6px';
    imp.textContent = `Casas: ${item.propertyData.houses || 0} ${item.propertyData.hotel ? 'Hotel' : ''}`;
    el.appendChild(imp);
  } else if(item.type === 'card'){
    const desc = document.createElement('div'); desc.textContent = item.desc || ''; desc.style.fontSize='12px'; desc.style.color='#555';
    el.appendChild(desc);
  } else {
    const price = document.createElement('div'); price.textContent = item.price?`$${item.price}`:""; price.style.fontSize='12px'; price.style.color='#444';
    el.appendChild(price);
  }
  // clicking a card opens the modal (shows rents/house costs) ‚Äî requested behaviour
  el.addEventListener('click', ()=>{
    // find which player owns it (if stored as owner) or just open modal as property
    openPropertyModal(players[0], item, { fromHand:true });
  });
  return el;
}

/* Add card to player's hand with flying animation from center -> hand */
function animateAddToHand(playerIndex, item){
  const canvasRect = canvas.getBoundingClientRect();
  const deckCenter = { x: canvasRect.left + SIZE/2, y: canvasRect.top + SIZE/2 - 20 };

  const floatEl = document.createElement('div');
  floatEl.className = 'floatingCard';
  floatEl.textContent = item.name;
  document.body.appendChild(floatEl);
  floatEl.style.left = (deckCenter.x - 80) + 'px';
  floatEl.style.top = (deckCenter.y - 50) + 'px';
  floatEl.style.opacity = '1';
  floatEl.style.transform = 'scale(1)';

  const targetContainer = (playerIndex === 0) ? playerHandDiv : aiHandDiv;
  const targetRect = targetContainer.getBoundingClientRect();
  const targetX = targetRect.left + 12 + Math.random()*30;
  const targetY = targetRect.top + 36 + Math.random()*30;

  const frames = 22;
  let f = 0;
  const start = { x: deckCenter.x - 80, y: deckCenter.y - 50 };
  const dx = (targetX - start.x) / frames;
  const dy = (targetY - start.y) / frames;
  const scaleStart = 1, scaleEnd = 0.9;
  const dscale = (scaleEnd - scaleStart) / frames;

  const anim = setInterval(()=>{
    f++;
    floatEl.style.left = (start.x + dx*f) + 'px';
    floatEl.style.top = (start.y + dy*f) + 'px';
    floatEl.style.transform = `scale(${(scaleStart + dscale*f).toFixed(3)})`;
    if(f >= frames){
      clearInterval(anim);
      addCardToPlayerHandDOM(playerIndex, item);
      floatEl.remove();
    }
  }, 16);
}

/* Adds item to player's data and shows dom card */
function addCardToPlayerHand(playerObj, item){
  playerObj.properties.push(item);
  const pIndex = players.indexOf(playerObj);
  animateAddToHand(pIndex, item);
  updateHUD();
}

/* append card DOM to hand container (no animation) */
function addCardToPlayerHandDOM(playerIndex, item){
  const container = (playerIndex === 0) ? playerHandDiv : aiHandDiv;
  const empty = container.querySelector('.handEmpty');
  if(empty) empty.remove();
  const cardDOM = createHandCardDOM(item);
  // if it's property on board, permit opening modal for building if owner
  cardDOM.addEventListener('click', ()=>{
    openPropertyModal(players[playerIndex], item, { fromHand:true });
  });
  container.appendChild(cardDOM);
}

/* Render full hands */
function renderFullHands(){
  playerHandDiv.innerHTML = '';
  aiHandDiv.innerHTML = '';
  if(players[0].properties.length === 0) playerHandDiv.innerHTML = '<div class="handEmpty">Sin propiedades</div>';
  if(players[1].properties.length === 0) aiHandDiv.innerHTML = '<div class="handEmpty">Sin propiedades</div>';
  for(let it of players[0].properties) addCardToPlayerHandDOM(0, it);
  for(let it of players[1].properties) addCardToPlayerHandDOM(1, it);
}

/* ---------- TURNS / MOVEMENT / BUYING ---------- */
function updateHUD(){
  turnName.textContent = players[current].name;
  playersListDiv.innerHTML = "";
  players.forEach(p=>{
    const row = document.createElement('div'); row.className = "playerRow";
    const left = document.createElement('div'); left.innerHTML = `<strong style="color:${p.color}">${p.name}</strong><br><span class="small">Pos: ${p.pos}</span>`;
    const right = document.createElement('div'); right.innerHTML = `<div>$${p.money}</div><div class="small">${p.properties.length} cartas</div>`;
    row.appendChild(left); row.appendChild(right);
    playersListDiv.appendChild(row);
  });
  suerteCount.textContent = suerteDeck.length;
  arcaCount.textContent = arcaDeck.length;
  playerMoneyEl.textContent = `$${players[0].money}`;
  aiMoneyEl.textContent = `$${players[1].money}`;
  const pl = players[current];
  if(pl.inJail){
    payJailBtn.style.display = "inline-block";
    useCardBtn.style.display = pl.hasGetOutCard ? "inline-block" : "none";
  } else {
    payJailBtn.style.display = "none";
    useCardBtn.style.display = "none";
  }
  renderFullHands();
}


function animateMove(player, steps){
  if(animating) return;
  animating = true;
  let s = 0;
  function step(){
    if(s < steps){
      player.pos++;
      if(player.pos >= 40){ player.pos -= 40; player.money += 200; showMsg(`${player.name} pasa por Salida +$200`); }
      s++;
      drawBoard(); updateHUD();
      setTimeout(step, 180);
    } else {
      animating = false;
      handleLandingWithDoubles(player);
    }
  }
  step();
}

/* landing logic with property buying: when bought -> add to player's hand with animation */
function handleLandingWithDoubles(pl){
  const cell = board[pl.pos];

  if(cell.type === "propiedad" || cell.type === "estacion" || cell.type === "compa√±ia"){
    // open property modal in center showing details (requested)
    openPropertyModal(pl, cell, { autoOpen:true });
    // if unowned: allow buy (button in modal). If owned by other, show pay message.
    if(!cell.owner){
      showMsg(`${pl.name} cae en ${cell.name} ‚Äî sin propietario.`);
    } else if(cell.owner !== pl.name){
      const owner = players.find(p => p.name === cell.owner);
      let rent = 0;
      if(cell.propertyData){
        if(cell.propertyData.hotel) rent = cell.propertyData.rent[5];
        else rent = cell.propertyData.rent[cell.propertyData.houses || 0];
      } else {
        rent = Math.floor(cell.price/2);
      }
      pl.money -= rent; owner.money += rent;
      showMsg(`${pl.name} paga $${rent} a ${owner.name}`);
      updateHUD(); drawBoard();
      if(inMultiplayer) pushStateToRoom();
      setTimeout(()=> nextTurn(), 900);
    } else {
      showMsg(`${pl.name} cae en su propia propiedad`);
      setTimeout(()=> nextTurn(), 800);
    }
    return;
  }

  if(cell.type === "impuesto"){
    pl.money -= 100;
    showMsg(`${pl.name} paga impuesto $100`);
    drawBoard(); updateHUD();
    if(inMultiplayer) pushStateToRoom();
    setTimeout(()=> nextTurn(), 800);
    return;
  }

  if(cell.type === "suerte" || cell.type === "arca"){
    animateTakeCard(cell.type, pl);
    return;
  }

  if(cell.name === "Ve a la c√°rcel"){
    pl.pos = 10; pl.inJail = true; pl.jailTurns = 0;
    showMsg(`${pl.name} va directo a la c√°rcel`);
    drawBoard(); updateHUD();
    if(inMultiplayer) pushStateToRoom();
    setTimeout(()=> nextTurn(), 800);
    return;
  }

  if(cell.name === "C√°rcel"){
    showMsg(`${pl.name} est√° en la casilla de C√°rcel`);
    setTimeout(()=> nextTurn(), 800);
    return;
  }

  showMsg(`${pl.name} cae en ${cell.name}`);
  setTimeout(()=> nextTurn(), 800);
}

/* stations helper */
function advanceToNextStation(player){
  const stations = [5,15,25,35];
  for(let s of stations){
    if(s > player.pos){ player.pos = s; break; }
  }
  const cell = board[player.pos];
  if(cell.owner && cell.owner !== player.name){
    const owner = players.find(p=>p.name === cell.owner);
    player.money -= 100; owner.money += 100;
    showMsg(`${player.name} paga $100 a ${owner.name} por estaci√≥n`);
  } else showMsg(`${player.name} avanza a estaci√≥n`);
  drawBoard(); updateHUD();
  if(inMultiplayer) pushStateToRoom();
  setTimeout(()=> nextTurn(), 900);
}

/* ---------- CARD animation & reveal (deck drawing) ---------- */
function animateTakeCard(deckName, player){
  const canvasRect = canvas.getBoundingClientRect();
  const deckCenterCanvas = { x: SIZE/2 + (deckName==="arca"? - (60/2 + 12) : (60/2 + 12)), y: SIZE/2 };
  const deckScreen = { x: canvasRect.left + deckCenterCanvas.x, y: canvasRect.top + deckCenterCanvas.y };

  const cardEl = document.createElement('div');
  cardEl.className = 'floatingCard';
  cardEl.textContent = deckName.toUpperCase();
  document.body.appendChild(cardEl);

  cardEl.style.left = `${deckScreen.x - 80}px`;
  cardEl.style.top = `${deckScreen.y - 50}px`;

  const targetX = window.innerWidth/2 - 190/2;
  const targetY = window.innerHeight/2 - 80;

  const frames = 18; let f = 0;
  const start = { x: deckScreen.x - 80, y: deckScreen.y - 50 };
  const dx = (targetX - start.x) / frames;
  const dy = (targetY - start.y) / frames;

  const anim = setInterval(()=>{
    f++;
    cardEl.style.left = `${start.x + dx * f}px`;
    cardEl.style.top = `${start.y + dy * f}px`;
    if(f >= frames){
      clearInterval(anim);
      setTimeout(()=>{ cardEl.remove(); revealCard(deckName, player); }, 120);
    }
  }, 22);
}

function revealCard(deckName, player){
  let deck = deckName === "suerte" ? suerteDeck : arcaDeck;
  if(deck.length === 0){ createDecks(); deck = deckName==="suerte"?suerteDeck:arcaDeck; }
  const card = deck.shift();
  cardTextEl.textContent = card.text;
  cardModal.style.display = "flex";
  cardModal.classList.add('show');
  function closeHandler(){
    cardModal.style.display = "none";
    cardModal.classList.remove('show');
    closeCardBtn.removeEventListener('click', closeHandler);
    card.action(player);
    updateHUD(); drawBoard();
    if(inMultiplayer) pushStateToRoom();
    setTimeout(()=> nextTurn(), 700);
  }
  closeCardBtn.addEventListener('click', closeHandler);
}

/* ---------- dice animation ---------- */
function randDice(){ return Math.floor(Math.random()*6)+1; }
function drawPips(x,y,w,num){
  ctx.fillStyle="#000";
  const r=4; const cx = x + w/2, cy = y + w/2, offset= Math.max(10, w/4);
  const left = cx - offset, right = cx + offset, top = cy - offset, bottom = cy + offset;
  const draw = (px,py)=>{ ctx.beginPath(); ctx.arc(px,py,r,0,Math.PI*2); ctx.fill(); };
  if(num===1) draw(cx,cy);
  if(num===2){ draw(left,top); draw(right,bottom); }
  if(num===3){ draw(left,top); draw(cx,cy); draw(right,bottom); }
  if(num===4){ draw(left,top); draw(right,top); draw(left,bottom); draw(right,bottom); }
  if(num===5){ draw(left,top); draw(right,top); draw(cx,cy); draw(left,bottom); draw(right,bottom); }
  if(num===6){ draw(left,top); draw(right,top); draw(left,cy); draw(right,cy); draw(left,bottom); draw(right,bottom); }
}
function drawDicePreview(d1,d2){
  const sizeDie = 44; const margin = 10;
  const x1 = SIZE - sizeDie*2 - margin - 6; const y1 = SIZE - sizeDie - margin - 6;
  ctx.fillStyle = "rgba(0,0,0,0.06)"; ctx.fillRect(x1-8,y1-8,sizeDie*2+18,sizeDie+16);
  ctx.fillStyle="#fff"; ctx.fillRect(x1,y1,sizeDie,sizeDie); ctx.strokeStyle="#333"; ctx.strokeRect(x1,y1,sizeDie,sizeDie); drawPips(x1,y1,sizeDie,d1);
  const x2 = x1 + sizeDie + 10; ctx.fillStyle="#fff"; ctx.fillRect(x2,y1,sizeDie,sizeDie); ctx.strokeRect(x2,y1,sizeDie,sizeDie); drawPips(x2,y1,sizeDie,d2);
}
function rollDiceAnimated(callback){
  if(diceRolling) return;
  diceRolling = true;
  let frames = 12, f = 0;
  const interval = 70;
  const anim = setInterval(()=>{
    diceResult = [randDice(), randDice()];
    drawBoard(); drawDicePreview(diceResult[0], diceResult[1]);
    f++;
    if(f >= frames){
      clearInterval(anim);
      diceRolling = false;
      drawBoard(); drawDicePreview(diceResult[0], diceResult[1]);
      setTimeout(()=> callback(diceResult[0], diceResult[1]), 180);
    }
  }, interval);
}

/* ---------- jail mechanics ---------- */
function rollForJail(pl){
  rollDiceAnimated((d1,d2)=>{
    showMsg(`${pl.name} intenta sacar dobles: ${d1}, ${d2}`);
    if(d1===d2){
      pl.inJail = false; pl.jailTurns = 0;
      showMsg(`${pl.name} sac√≥ dobles y sale`); animateMove(pl, d1 + d2);
    } else {
      pl.jailTurns++;
      showMsg(`${pl.name} no saca dobles (${pl.jailTurns}/3)`);
      if(pl.jailTurns >= 3){
        pl.money -= 50; pl.inJail = false; pl.jailTurns = 0;
        showMsg(`${pl.name} paga $50 tras 3 intentos y sale`);
        animateMove(pl, d1 + d2);
      } else {
        setTimeout(()=> nextTurn(), 700);
      }
    }
  });
}

document.getElementById('payJailBtn').addEventListener('click', ()=>{
  const pl = players[current];
  if(pl.inJail){ pl.money -= 50; pl.inJail = false; pl.jailTurns = 0; showMsg(`${pl.name} paga $50 y sale`); drawBoard(); updateHUD(); if(inMultiplayer) pushStateToRoom(); }
});
document.getElementById('useCardBtn').addEventListener('click', ()=>{
  const pl = players[current];
  if(pl.hasGetOutCard){
    pl.hasGetOutCard = false; pl.inJail = false; pl.jailTurns = 0; showMsg(`${pl.name} usa 'Salir de la c√°rcel'`);
    const idx = pl.properties.findIndex(x=>x.name === "Salir de la c√°rcel");
    if(idx>=0) pl.properties.splice(idx,1);
    drawBoard(); updateHUD(); if(inMultiplayer) pushStateToRoom();
  }
});

/* ---------- roll button ---------- */
rollBtn.addEventListener('click', ()=>{
  const pl = players[current];
  // multiplayer guard: only allow if it's your turn
  if(inMultiplayer && players[current].id !== players[myPlayerIndex].id){
    showMsg("No es tu turno (multiplayer).");
    return;
  }
  if(animating || diceRolling) return;
  if(pl.inJail){ rollForJail(pl); if(inMultiplayer) pushStateToRoom(); return; }
  rollDiceAnimated((d1,d2)=>{
    const sum = d1 + d2;
    showMsg(`${pl.name} tira ${d1} + ${d2} = ${sum}`);
    lastRollWasDouble = (d1 === d2);
    animateMove(pl, sum);
    if(inMultiplayer) setTimeout(()=> pushStateToRoom(), 900); // push after move resolves
  });
});

/* ---------- AI ---------- */
function aiTakeTurn(ai){
  if(ai.inJail){
    if(ai.hasGetOutCard){ ai.hasGetOutCard = false; ai.inJail = false; ai.jailTurns = 0; showMsg("Oponente usa 'Salir de la c√°rcel'"); setTimeout(()=> animateMove(ai, randDice()+randDice()), 500); return; }
    if(ai.money > 120){ ai.money -= 50; ai.inJail = false; ai.jailTurns = 0; showMsg("Oponente paga $50 y sale"); setTimeout(()=> animateMove(ai, randDice()+randDice()), 500); return; }
    rollForJail(ai); return;
  }
  rollDiceAnimated((d1,d2)=>{
    const sum = d1+d2;
    showMsg(`Oponente tira ${d1} + ${d2} = ${sum}`);
    lastRollWasDouble = (d1===d2);
    setTimeout(()=> animateMove(ai, sum), 220);
  });
}

/* ---------- Property modal ---------- */
/* options: { autoOpen:bool, fromHand:bool } */
let modalOpenFor = null;
function openPropertyModal(playerObj, p, options = {}){
  modalOpenFor = p;
  pmName.textContent = p.name;
  pmColor.style.background = p.color || '#ddd';
  pmPrice.textContent = p.propertyData ? p.propertyData.price : (p.price || "-");
  pmHouseCost.textContent = p.propertyData ? p.propertyData.houseCost : "-";
  pmHotelCost.textContent = p.propertyData ? p.propertyData.hotelCost : "-";
  if(p.propertyData){
    pmRents.innerHTML = `
      Base: $${p.propertyData.rent[0]}<br>
      1 Casa: $${p.propertyData.rent[1]}<br>
      2 Casas: $${p.propertyData.rent[2]}<br>
      3 Casas: $${p.propertyData.rent[3]}<br>
      4 Casas: $${p.propertyData.rent[4]}<br>
      Hotel: $${p.propertyData.rent[5]}
    `;
    pmImprovements.textContent = `${p.propertyData.houses || 0} casas ${p.propertyData.hotel ? "y hotel" : ""}`;
  } else {
    pmRents.innerHTML = `<i>No aplicable</i>`;
    pmImprovements.textContent = "-";
  }
  propMsg.textContent = "";

  const currentPlayerObj = players.find(pl => pl.id === playerObj.id);
  const ownerName = p.owner || null;

  // Show/hide controls depending on context
  // If property unowned and it's current player's turn and the player landed (autoOpen), show buy button
  buyPropBtn.style.display = "none";
  buyHouseBtn.style.display = "none";
  buyHotelBtn.style.display = "none";

  if(ownerName === currentPlayerObj.name && p.propertyData){
    // owner viewing their own property -> allow building
    buyHouseBtn.style.display = "inline-block";
    buyHotelBtn.style.display = "inline-block";
  } else if(!ownerName && options.autoOpen && players[current].id === currentPlayerObj.id){
    buyPropBtn.style.display = "inline-block";
  } else if(!ownerName && options.fromHand && currentPlayerObj.properties.includes(p)){
    // if viewing from hand and you own, allow building
    buyHouseBtn.style.display = "inline-block";
  }

  // set modal visible with animation
  propModal.style.display = "flex";
  propModal.classList.add('show');
}

/* clicking close */
closePropBtn.addEventListener('click', ()=>{ propModal.style.display = "none"; propModal.classList.remove('show'); modalOpenFor = null; propMsg.textContent = ""; });

buyPropBtn.addEventListener('click', ()=>{
  const p = modalOpenFor;
  const pl = players[current];
  if(!p || !p.price){ propMsg.textContent = "No es comprable."; return; }
  if(pl.money < p.price){ propMsg.textContent = "No tienes dinero suficiente."; return; }
  pl.money -= p.price;
  p.owner = pl.name;
  addCardToPlayerHand(pl, p);
  propMsg.textContent = `Has comprado ${p.name} por $${p.price}.`;
  drawBoard(); updateHUD();
  if(inMultiplayer) pushStateToRoom();
  // keep modal open to show updated state
});

buyHouseBtn.addEventListener('click', ()=>{
  const p = modalOpenFor;
  const pl = players.find(x => x.id === players[current].id);
  if(!p || !p.propertyData){ propMsg.textContent = "No es propiedad construible."; return; }
  if(p.owner !== pl.name){ propMsg.textContent = "No eres el propietario."; return; }
  if(p.propertyData.hotel){ propMsg.textContent = "Ya tienes hotel."; return; }
  if(p.propertyData.houses >= 4){ propMsg.textContent = "4 casas alcanzadas; compra hotel."; return; }
  const cost = p.propertyData.houseCost;
  if(pl.money < cost){ propMsg.textContent = "No tienes dinero suficiente."; return; }
  pl.money -= cost; p.propertyData.houses++;
  propMsg.textContent = `Comprada 1 casa por $${cost}.`;
  updateHUD(); drawBoard();
  if(inMultiplayer) pushStateToRoom();
});

buyHotelBtn.addEventListener('click', ()=>{
  const p = modalOpenFor;
  const pl = players.find(x => x.id === players[current].id);
  if(!p || !p.propertyData){ propMsg.textContent = "No es propiedad construible."; return; }
  if(p.owner !== pl.name){ propMsg.textContent = "No eres el propietario."; return; }
  if(p.propertyData.hotel){ propMsg.textContent = "Ya tienes hotel."; return; }
  if(p.propertyData.houses < 4){ propMsg.textContent = "Necesitas 4 casas antes de comprar hotel."; return; }
  const cost = p.propertyData.hotelCost;
  if(pl.money < cost){ propMsg.textContent = "No tienes dinero suficiente."; return; }
  pl.money -= cost; p.propertyData.houses = 0; p.propertyData.hotel = true;
  propMsg.textContent = `Comprado hotel por $${cost}.`;
  updateHUD(); drawBoard();
  if(inMultiplayer) pushStateToRoom();
});

/* ---------- STARTUP ---------- */
createDecks();
drawBoard();
updateHUD();
showMsg("Juego listo. Pulsa 'Tirar dados'.");

/* keep board refreshing to keep dice preview updated */
setInterval(()=>{ if(!diceRolling) drawBoard(); }, 700);

/* ---------------- MULTIPLAYER: Basic rooms using Supabase table 'monopoly_rooms' ----------------
   Table schema expected (you can create in Supabase SQL):
   CREATE TABLE public.monopoly_rooms (
     id text primary key,
     state jsonb,
     created_at timestamptz default now()
   );
   We will use simple polling to fetch the room state every 1s.
*/
async function createRoom(initialState){
  if(!supabase) { alert("Supabase no configurado. No puedes crear sala."); return null; }
  const id = uid(8);
  const insert = await supabase.from('monopoly_rooms').insert([{ id, state: initialState }]);
  if(insert.error){ console.error(insert.error); alert("Error creando sala: " + insert.error.message); return null; }
  return id;
}
async function setRoomState(id, state){
  if(!supabase) return;
  const res = await supabase.from('monopoly_rooms').upsert({ id, state }, { onConflict: 'id' });
  if(res.error) console.error(res.error);
}
async function getRoomState(id){
  if(!supabase) return null;
  const res = await supabase.from('monopoly_rooms').select('state').eq('id', id).single();
  if(res.error){ console.warn(res.error); return null; }
  return res.data ? res.data.state : null;
}
async function listRooms(){
  if(!supabase) return [];
  const res = await supabase.from('monopoly_rooms').select('id, created_at').order('created_at', { ascending: false }).limit(20);
  if(res.error){ console.warn(res.error); return []; }
  return res.data || [];
}

/* wrappers to push/pull game state */
async function pushStateToRoom(){
  if(!inMultiplayer || !roomId) return;
  const state = {
    players,
    board,
    current,
    message: infoBox.textContent
  };
  await setRoomState(roomId, state);
}
async function pullStateFromRoom(){
  if(!inMultiplayer || !roomId) return;
  const state = await getRoomState(roomId);
  if(!state) return;
  // apply remote state: this is naive merging - we replace local with remote
  try{
    // keep local identity mapping: assume players array has ids to determine myPlayerIndex
    if(state.players && Array.isArray(state.players)){
      players = state.players;
      // determine myPlayerIndex by comparing stored ids: if this client hasn't been assigned an id, use names
      if(players.length >= 2){
        const myId = players[myPlayerIndex] && players[myPlayerIndex].id;
        // if my id not present, pick index by matching name 'Jugador'
        if(!myId){
          myPlayerIndex = players.findIndex(p => p.name === 'Jugador');
          if(myPlayerIndex === -1) myPlayerIndex = 0;
        } else {
          // find index of myId in new players
          const idx = players.findIndex(p => p.id === myId);
          if(idx !== -1) myPlayerIndex = idx;
        }
      }
    }
    if(state.board) {
      // update board in-place to preserve references in UI
      for(let i=0;i<state.board.length && i<board.length;i++){
        board[i] = state.board[i];
      }
    }
    if(typeof state.current === 'number') current = state.current;
    if(state.message) showMsg(state.message);
    drawBoard(); updateHUD();
  }catch(e){ console.error("Error aplicando estado remoto", e); }
}

/* menu interactions */
onePlayerBtn.addEventListener('click', ()=>{
  // start one player mode
  menuOverlay.style.display = "none";
  inMultiplayer = false;
  multiplayerStatus.style.display = "none";
  // reset players simple
  players = [
    {id:"local1", name:"Jugador", color:"#1f77b4", pos:0, money:1500, properties:[], inJail:false, jailTurns:0, hasGetOutCard:false},
    {id:"local2", name:"Oponente", color:"#d62728", pos:0, money:1500, properties:[], inJail:false, jailTurns:0, hasGetOutCard:false}
  ];
  myPlayerIndex = 0;
  current = 0;
  createDecks();
  updateHUD();
  drawBoard();
  showMsg("One Player ‚Äî Juega contra la IA.");
});
multiplayerBtn.addEventListener('click', ()=>{
  // show room UI inside menu
  roomPanel.style.display = "flex";
  document.getElementById('menuBox').style.height = "auto";
});

/* create / join */
createRoomBtn.addEventListener('click', async ()=>{
  if(!supabase){ alert("Supabase no configurado. Introduce SUPABASE_URL y SUPABASE_KEY en el c√≥digo."); return; }
  // prepare initial state from local game
  const initState = {
    players,
    board,
    current,
    message: "Sala creada ‚Äî esperando jugador 2..."
  };
  const id = await createRoom(initState);
  if(id){
    roomId = id;
    inMultiplayer = true;
    myPlayerIndex = 0; // creator is player 0
    players[0].id = "p-"+uid(6);
    players[1].id = "p-guest";
    // write more robust initial players array
    players[0].name = "Jugador";
    players[1].name = "Oponente";
    await setRoomState(roomId, { players, board, current, message: "Sala creada. Esperando jugador..." });
    startPollingRoom();
    menuOverlay.style.display = "none";
    multiplayerStatus.style.display = "block";
    roomIdDisplay.textContent = roomId;
    showMsg("Sala creada. Comparte el ID con quien quieras jugar.");
  }
});

joinRoomBtn.addEventListener('click', async ()=>{
  const id = roomInput.value.trim();
  if(!id){ alert("Introduce un ID de sala para unirte."); return; }
  if(!supabase){ alert("Supabase no configurado. Introduce SUPABASE_URL y SUPABASE_KEY en el c√≥digo."); return; }
  const remote = await getRoomState(id);
  if(!remote){ alert("Sala no encontrada o sin estado."); return; }
  // join - become player 1 if slot free
  roomId = id;
  inMultiplayer = true;
  // adopt remote state
  try{
    if(remote.players && remote.players.length === 2){
      players = remote.players;
    } else {
      // fallback: use default players
      players = [
        {id:"p-guest", name:"Jugador", color:"#1f77b4", pos:0, money:1500, properties:[], inJail:false, jailTurns:0, hasGetOutCard:false},
        {id:"p-host", name:"Oponente", color:"#d62728", pos:0, money:1500, properties:[], inJail:false, jailTurns:0, hasGetOutCard:false}
      ];
    }
  }catch(e){ console.warn(e); }
  myPlayerIndex = 1; // guest
  players[myPlayerIndex].id = "p-"+uid(6);
  // update remote to contain explicit ids and players array
  await pushStateToRoom();
  startPollingRoom();
  menuOverlay.style.display = "none";
  multiplayerStatus.style.display = "block";
  roomIdDisplay.textContent = roomId;
  showMsg("Unido a la sala. Empieza el juego cuando sea tu turno.");
});

listRoomsBtn.addEventListener('click', async ()=>{
  if(!supabase){ alert("Supabase no configurado."); return; }
  roomsList.innerHTML = "Cargando...";
  const r = await listRooms();
  roomsList.innerHTML = "";
  if(r.length === 0) roomsList.innerHTML = "<div class='muted'>No hay salas recientes</div>";
  for(let item of r){
    const d = document.createElement('div');
    d.style.padding = "6px";
    d.style.borderBottom = "1px solid #eee";
    d.innerHTML = `<strong>${item.id}</strong> <span class="muted">(${new Date(item.created_at).toLocaleString()})</span>`;
    d.addEventListener('click', ()=>{ roomInput.value = item.id; });
    roomsList.appendChild(d);
  }
});

/* copy/leave */
copyRoomBtn.addEventListener('click', ()=>{
  if(!roomId) return;
  navigator.clipboard?.writeText(roomId).then(()=> alert('ID copiado!'));
});
leaveRoomBtn.addEventListener('click', ()=>{
  stopPollingRoom();
  roomId = null;
  inMultiplayer = false;
  multiplayerStatus.style.display = "none";
  menuOverlay.style.display = "flex";
  showMsg("Has salido de la sala.");
});

/* polling */
function startPollingRoom(){
  if(pollInterval) clearInterval(pollInterval);
  pollInterval = setInterval(async ()=>{
    if(!roomId) return;
    await pullStateFromRoom();
  }, 1200);
}
function stopPollingRoom(){ if(pollInterval) clearInterval(pollInterval); pollInterval = null; }

/* ---------- END MULTIPLAYER ---------- */

/* make canvas responsive */
function resizeCanvas(){
  // keep size fixed for board but center canvas; if you want to scale, change here
  canvas.width = SIZE; canvas.height = SIZE;
}
addEventListener('resize', resizeCanvas);
resizeCanvas();

  // =========================
// üîÅ CAMBIO DE TURNO
// =========================
function nextTurn() {
  currentPlayer = (currentPlayer === player) ? ai : player;
  if (currentPlayer === ai) {
    setTimeout(handleAITurn, 1000); // IA act√∫a con peque√±a pausa
  } else {
    log("üé≤ Es tu turno. Tira los dados.");
  }
}

// =========================
// üéØ MOVER JUGADOR
// =========================
function movePlayer(playerObj, steps) {
  playerObj.position = (playerObj.position + steps) % board.length;
  updatePlayerPositions();

  const cell = board[playerObj.position];
  log(`${playerObj.name} cae en ${cell.name}.`);

  if (cell.type === "property") {
    handlePropertyLanding(playerObj, cell);
  } else if (cell.type === "chance" || cell.type === "community") {
    drawCard(cell.type, playerObj);
  } else if (cell.type === "tax") {
    payTax(playerObj, cell);
  } else if (cell.type === "jail") {
    sendToJail(playerObj);
  } else if (cell.type === "go") {
    collectGo(playerObj);
  }

  updateHUD();
}

// =========================
// üè† MANEJAR CAER EN PROPIEDAD
// =========================
function handlePropertyLanding(playerObj, property) {
  if (!property.owner) {
    if (playerObj === player) {
      showPropertyCard(property, playerObj);
    } else {
      aiBuyProperty(property);
    }
  } else if (property.owner !== playerObj) {
    const rent = calculateRent(property);
    playerObj.money -= rent;
    property.owner.money += rent;
    log(`${playerObj.name} paga $${rent} de renta a ${property.owner.name}.`);
    updateHUD();
  } else if (playerObj === player) {
    showPropertyCard(property, playerObj, true);
  }
}

function showPropertyCard(property, playerObj, isOwner = false) {
  const modal = document.getElementById("propertyModal");
  const content = modal.querySelector(".property-content");
  content.innerHTML = `
    <div class="property-card" style="border:2px solid black;border-radius:10px;width:300px;margin:auto;text-align:center;background:#fff;font-family:Arial;">
      <div style="background:${property.color};color:white;padding:10px;border-top-left-radius:10px;border-top-right-radius:10px;">
        <strong>${property.name}</strong>
      </div>
      <div style="padding:10px;">
        <p>Renta base: $${property.rent}</p>
        <p>Con 1 casa: $${property.houseRent1}</p>
        <p>Con 2 casas: $${property.houseRent2}</p>
        <p>Con 3 casas: $${property.houseRent3}</p>
        <p>Con 4 casas: $${property.houseRent4}</p>
        <p>Hotel: $${property.hotelRent}</p>
        <p>Casas cuestan: $${property.houseCost}</p>
        <p>Hotel cuesta: $${property.hotelCost}</p>
        <p>Precio de compra: $${property.price}</p>
      </div>
      <div style="padding:10px;">
        ${
          !isOwner
            ? (!property.owner
                ? `<button id="buyBtn" class="buy-btn">Comprar</button>`
                : `<p>Propietario: ${property.owner.name}</p>`)
            : `<p>Ya eres due√±o de esta propiedad.</p>`
        }
        <button id="closeBtn" class="close-btn">Cerrar</button>
      </div>
    </div>`;
  modal.style.display = "flex";
  modal.style.animation = "fadeIn 0.3s ease, zoomIn 0.3s ease";
  modal.querySelector("#closeBtn").onclick = () => (modal.style.display = "none");
  const buyBtn = modal.querySelector("#buyBtn");
  if (buyBtn) {
    buyBtn.onclick = () => {
      if (playerObj.money >= property.price) {
        playerObj.money -= property.price;
        property.owner = playerObj;
        playerObj.properties.push(property);
        log(`${playerObj.name} compr√≥ ${property.name} por $${property.price}.`);
        updateHands();
        updateHUD();
      } else {
        log("No tienes suficiente dinero para comprar esta propiedad.");
      }
      modal.style.display = "none";
      nextTurn();
    };
  }
}

function aiBuyProperty(property) {
  setTimeout(() => {
    if (ai.money >= property.price) {
      ai.money -= property.price;
      property.owner = ai;
      ai.properties.push(property);
      log(`ü§ñ La IA compr√≥ ${property.name} por $${property.price}.`);
    } else {
      log(`ü§ñ La IA no tiene suficiente dinero para comprar ${property.name}.`);
    }
    updateHands();
    updateHUD();
    nextTurn();
  }, 1000);
}
</script>
</body>
</html>
