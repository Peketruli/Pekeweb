<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Casino 3D - Estilo Cl√°sico (Corregido)</title>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<style>
  body { margin:0; overflow:hidden; background:#000; font-family:Arial, Helvetica, sans-serif; }
  #hint {
    position: absolute; left: 12px; top: 12px; z-index: 5;
    background: rgba(0,0,0,0.6); color: #fff; padding:8px 10px; border-radius:8px;
    font-size:13px;
  }
  #credits {
    position: absolute; right: 12px; top: 12px; z-index: 5;
    background: rgba(0,0,0,0.45); color:#ddd; padding:6px 8px; border-radius:6px; font-size:12px;
  }
</style>
</head>
<body>
<div id="hint">üé∞ Mover: W A S D ‚Äî Mirar: rat√≥n</div>
<div id="credits">Casino cl√°sico ‚Äî texturas libres (online)</div>

<script>
// -------------------- Escena / Renderer / C√°mara --------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x060304); // muy oscuro, ambiente c√°lido
scene.fog = new THREE.FogExp2(0x060304, 0.012);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
// spawn moved further back to avoid spawning inside table
camera.position.set(0, 1.7, 18);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// -------------------- Cargador de texturas --------------------
const loader = new THREE.TextureLoader();

// Texturas p√∫blicas (CDN). Si quieres cambiar por locales, reemplaza URLs.
const woodTex = loader.load('https://threejs.org/examples/textures/brick_diffuse.jpg'); // sirve como madera b√°sica si no hay otra
const floorTex = loader.load('https://cdn.pixabay.com/photo/2016/11/21/15/55/pattern-1846866_1280.jpg'); // patr√≥n para suelo (alternativo)
const feltTex = createGreenFeltTexture(); // generado por funci√≥n abajo
const metalTex = loader.load('https://threejs.org/examples/textures/uv_grid_opengl.jpg'); // para slots cuerpos
const rouletteWood = loader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'); // placeholder wood-like map for rim

floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
floorTex.repeat.set(8, 8);

// -------------------- Iluminaci√≥n --------------------
// Luz ambiente c√°lida
scene.add(new THREE.AmbientLight(0xffecd6, 0.45));

// Luz direccional c√°lida (sol artificial)
const dir = new THREE.DirectionalLight(0xffe0b5, 0.6);
dir.position.set(5, 20, 10);
dir.castShadow = true;
dir.shadow.mapSize.set(1024,1024);
dir.shadow.camera.near = 1;
dir.shadow.camera.far = 100;
scene.add(dir);

// Spots c√°lidos sobre mesas
const spot1 = new THREE.SpotLight(0xffe6c2, 0.9, 30, Math.PI/6, 0.4);
spot1.position.set(0, 8, 2);
spot1.castShadow = true;
scene.add(spot1);

// L√°mparas peque√±as de acento (luces c√°lidas)
const accent1 = new THREE.PointLight(0xffd8a8, 0.7, 12);
accent1.position.set(0, 5, 4);
scene.add(accent1);

// -------------------- Suelo, techo y paredes --------------------
// Suelo (alfombra cl√°sica: usaremos suelo texturizado y multiplicaremos con un color oscuro)
const floorMat = new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.9, metalness: 0.02 });
const floor = new THREE.Mesh(new THREE.PlaneGeometry(80,80), floorMat);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// Techo
const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(40, 40), new THREE.MeshStandardMaterial({ color: 0x1b0d05, roughness:1 }));
ceiling.rotation.x = Math.PI/2;
ceiling.position.y = 7;
ceiling.receiveShadow = true;
scene.add(ceiling);

// Back wall (con puerta)
const backWallMat = new THREE.MeshStandardMaterial({ map: woodTex, roughness: 1.0, metalness: 0.05 });
const backWall = new THREE.Mesh(new THREE.BoxGeometry(40,8,0.8), backWallMat);
backWall.position.set(0,4,-30);
backWall.receiveShadow = true;
scene.add(backWall);

// Front wall
const frontWall = backWall.clone();
frontWall.position.set(0,4,30);
scene.add(frontWall);

// Left / Right walls
const sideWall = new THREE.Mesh(new THREE.BoxGeometry(0.8,8,60), backWallMat);
sideWall.position.set(-20,4,0);
scene.add(sideWall);
const sideWallR = sideWall.clone();
sideWallR.position.set(20,4,0);
scene.add(sideWallR);

// -------------------- Puerta trasera (salida) --------------------
const doorMat = new THREE.MeshStandardMaterial({ color: 0x6b3f1a, roughness: 0.7 });
const door = new THREE.Mesh(new THREE.BoxGeometry(3,4,0.3), doorMat);
door.position.set(0, 2, -29.6);
door.castShadow = true;
scene.add(door);

// Puerta con marco dorado
const frameMat = new THREE.MeshStandardMaterial({ color:0x8a5a2b, metalness: 0.8, roughness: 0.4 });
const doorFrame = new THREE.Mesh(new THREE.BoxGeometry(3.4,4.4,0.15), frameMat);
doorFrame.position.set(0,2,-29.45);
scene.add(doorFrame);

// -------------------- Pasillo de entrada --------------------
for (let i = -22; i <= -6; i += 6) {
  const pil = new THREE.Mesh(new THREE.BoxGeometry(1,6,2), new THREE.MeshStandardMaterial({ color:0x3d2516 }));
  pil.position.set(-8, 3, i);
  scene.add(pil);
  const pil2 = pil.clone();
  pil2.position.set(8,3,i);
  scene.add(pil2);
}

// -------------------- Mesas y muebles --------------------
// Mesa de blackjack (tapete verde + borde de madera)
const tableTopGeo = new THREE.CylinderGeometry(4.2, 4.2, 0.4, 32);
const tableTopMat = new THREE.MeshStandardMaterial({ map: feltTex, roughness: 0.8, metalness: 0.04 });
const tableTop = new THREE.Mesh(tableTopGeo, tableTopMat);
tableTop.position.set(0, 0.6, 6);
tableTop.castShadow = true;
tableTop.receiveShadow = true;
scene.add(tableTop);

// Borde de madera alrededor del tapete
const rimGeo = new THREE.TorusGeometry(4.35, 0.25, 16, 100);
const rimMat = new THREE.MeshStandardMaterial({ color: 0x4a2b12, metalness:0.2, roughness:0.6 });
const rim = new THREE.Mesh(rimGeo, rimMat);
rim.rotation.x = Math.PI/2;
rim.position.set(0, 0.9, 6);
scene.add(rim);

// Sillas (simples) alrededor (decorativas)
for (let i=0;i<5;i++){
  const angle = (i / 5) * Math.PI*2;
  const sx = Math.sin(angle)*5;
  const sz = Math.cos(angle)*5 + 6;
  const seat = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), new THREE.MeshStandardMaterial({ color:0x2b1508 }));
  seat.position.set(sx, 0.3, sz);
  scene.add(seat);
}

// -------------------- Ruleta detallada --------------------
const wheelGroup = new THREE.Group();
const wheelBase = new THREE.Mesh(new THREE.CylinderGeometry(2.2,2.2,0.6,48), new THREE.MeshStandardMaterial({ color:0x2f1608, metalness:0.6, roughness:0.4 }));
wheelBase.position.y = 0.5;
wheelGroup.add(wheelBase);

// Wooden rim (use slotTex or rouletteWood as wood pattern)
const rimMesh = new THREE.Mesh(new THREE.TorusGeometry(2.4,0.18,16,100), new THREE.MeshStandardMaterial({ map: rouletteWood, metalness:0.3, roughness:0.6 }));
rimMesh.rotation.x = Math.PI/2;
rimMesh.position.y = 0.85;
wheelGroup.add(rimMesh);

// wheel plate (drawn via canvas texture)
const wheelCanvas = document.createElement('canvas');
wheelCanvas.width = 1024; wheelCanvas.height = 1024;
drawRouletteWheel(wheelCanvas);
const wheelTex = new THREE.CanvasTexture(wheelCanvas);
const wheelPlate = new THREE.Mesh(new THREE.CylinderGeometry(1.9,1.9,0.08,64), new THREE.MeshStandardMaterial({ map: wheelTex }));
wheelPlate.rotation.x = Math.PI/2;
wheelPlate.position.y = 0.86;
wheelGroup.add(wheelPlate);

wheelGroup.position.set(-10, 0, 8);
wheelGroup.castShadow = true;
scene.add(wheelGroup);

// -------------------- Tragaperras con pantalla animada --------------------
const machines = [];
for (let i = 0; i < 6; i++) {
  const group = new THREE.Group();

  // Body
  const body = new THREE.Mesh(new THREE.BoxGeometry(1.6, 2.6, 1.2), new THREE.MeshStandardMaterial({ color: 0x2b1a14, metalness: 0.3, roughness: 0.6 }));
  body.position.y = 1.3;
  group.add(body);

  // Front panel (wood + metal)
  const panel = new THREE.Mesh(new THREE.PlaneGeometry(0.9, 0.9), new THREE.MeshStandardMaterial({ color: 0x111111 }));
  panel.position.set(0, 1.4, 0.65);
  group.add(panel);

  // Screen (canvas texture)
  const screenCanvas = document.createElement('canvas');
  screenCanvas.width = 256; screenCanvas.height = 256;
  const sctx = screenCanvas.getContext('2d');
  drawSlotScreen(sctx, ["7","‚òÖ","üçí","üîî","BAR"], 0);

  const screenTex = new THREE.CanvasTexture(screenCanvas);
  const screenMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), new THREE.MeshBasicMaterial({ map: screenTex }));
  screenMesh.position.set(0, 1.4, 0.66);
  group.add(screenMesh);

  // lever
  const lever = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.7,8), new THREE.MeshStandardMaterial({ color:0x6b3f1a }));
  lever.rotation.z = Math.PI/4;
  lever.position.set(0.8, 0.7, 0.45);
  group.add(lever);

  group.position.set(i*3 - 7.5, 0, -12);
  group.userData = { screenCanvas, sctx, screenTex, reels:["7","‚òÖ","üçí","üîî","BAR"], spinning:false };
  group.castShadow = true;
  scene.add(group);
  machines.push(group);
}

// -------------------- Peque√±os detalles / deco --------------------
const carpetPatch = new THREE.Mesh(new THREE.PlaneGeometry(10, 6), new THREE.MeshStandardMaterial({ color: 0x3b1f10, roughness:0.9, metalness:0.02 }));
carpetPatch.rotation.x = -Math.PI/2;
carpetPatch.position.set(0, 0.01, 6);
scene.add(carpetPatch);

// -------------------- Movimiento & c√°mara (mejor estabilizado) --------------------
let yaw = 0;   // horizontal rotation
let pitch = 0; // vertical rotation
const sens = 0.0026; // mouse sensitivity

window.addEventListener('mousemove', (e) => {
  // fallback for different browsers
  const mx = (e.movementX !== undefined) ? e.movementX : (e.mozMovementX || e.webkitMovementX || 0);
  const my = (e.movementY !== undefined) ? e.movementY : (e.mozMovementY || e.webkitMovementY || 0);
  yaw -= mx * sens;
  pitch -= my * sens;
  const maxPitch = Math.PI / 2 - 0.05;
  pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));
});

// Keyboard move
const keys = {};
window.addEventListener('keydown', (e) => { keys[e.code] = true; });
window.addEventListener('keyup', (e) => { keys[e.code] = false; });

// Smooth movement velocity (simple)
const velocity = new THREE.Vector3();
const accel = 30.0;
const damping = 10.0;

// Temporary vectors to avoid allocations
const forwardVec = new THREE.Vector3();
const rightVec = new THREE.Vector3();
const upVec = new THREE.Vector3(0,1,0);

const clock = new THREE.Clock();

function updateMovement(dt) {
  // apply camera rotations using Euler YXZ -> this avoids gimball/NAN problems
  const euler = new THREE.Euler(pitch, yaw, 0, 'YXZ');
  camera.quaternion.setFromEuler(euler);
  camera.updateMatrixWorld();

  camera.getWorldDirection(forwardVec);
  forwardVec.y = 0; // keep movement on XZ plane
  forwardVec.normalize();

  // right vector = forward cross up
  rightVec.copy(forwardVec).cross(upVec).negate(); // ensure right points to camera's right

  // desired direction
  let moveX = 0, moveZ = 0;
  if (keys['KeyW']) moveZ += 1;
  if (keys['KeyS']) moveZ -= 1;
  if (keys['KeyD']) moveX -= 1;
  if (keys['KeyA']) moveX += 1;

  const desired = new THREE.Vector3();
  desired.addScaledVector(forwardVec, moveZ);
  desired.addScaledVector(rightVec, moveX);
  if (desired.lengthSq() > 0) desired.normalize();

  // accelerate / damp
  velocity.addScaledVector(desired, accel * dt);
  velocity.multiplyScalar(1 / (1 + damping * dt));

  // move camera position
  camera.position.addScaledVector(velocity, dt);
}

// -------------------- Slot screen animation (visual only) --------------------
let slotTick = 0;
function animateSlotScreens(dt) {
  slotTick += dt * 8;
  machines.forEach((m, idx) => {
    const data = m.userData;
    // spin each screen with offset
    const center = Math.floor((slotTick + idx*3) % data.reels.length);
    drawSlotScreen(data.sctx, data.reels, center);
    data.screenTex.needsUpdate = true;
  });
}

// -------------------- Interact: press E near door to exit --------------------
window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'e') {
    // if near door, go to home
    const d = camera.position.distanceTo(door.position);
    if (d < 3.2) {
      // redirect (ajusta la ruta si es otra)
      window.location.href = 'h.html';
    }
  }
});

// -------------------- Animaci√≥n general --------------------
function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.05);

  updateMovement(dt);

  // rotate wheel slightly (guardamos acceso para no romper si no existe)
  if (typeof wheelGroup !== 'undefined' && wheelGroup) wheelGroup.rotation.y += 0.02;

  // animate slot screens
  animateSlotScreens(dt);

  // subtle light flicker for atmosphere
  const t = Date.now() * 0.001;
  if (typeof accent1 !== 'undefined') accent1.intensity = 0.65 + Math.sin(t * 1.3) * 0.15;
  if (typeof spot1 !== 'undefined') spot1.intensity = 0.6 + Math.sin(t * 0.7) * 0.1;

  mainLoopRender();
}

// separated render function so it is clearer
function mainLoopRender() {
  renderer.render(scene, camera);
}
animate();

// -------------------- Resize --------------------
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// -------------------- Helper functions --------------------

// create a green felt-like texture via canvas
function createGreenFeltTexture(){
  const c = document.createElement('canvas');
  c.width = c.height = 512;
  const ctx = c.getContext('2d');
  // base green
  ctx.fillStyle = '#0b5b35';
  ctx.fillRect(0,0,c.width,c.height);
  // add subtle noise
  for (let i=0;i<30000;i++){
    const x = Math.random()*c.width, y = Math.random()*c.height;
    const a = Math.random()*30;
    ctx.fillStyle = `rgba(0,0,0,${a/255})`;
    ctx.fillRect(x,y,1,1);
  }
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(2,2);
  return tex;
}

// draw a simple stylized roulette wheel onto a canvas
function drawRouletteWheel(canvas){
  const ctx = canvas.getContext('2d');
  const size = canvas.width;
  // background
  ctx.fillStyle = '#3b2b20';
  ctx.fillRect(0,0,size,size);
  const cx = size/2, cy = size/2, r = size*0.42;
  // draw alternating red/black segments (simplified)
  const segments = 18;
  for (let i=0;i<segments;i++){
    ctx.beginPath();
    const start = (i/segments) * Math.PI*2;
    const end = ((i+1)/segments) * Math.PI*2;
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,r,start,end);
    ctx.closePath();
    ctx.fillStyle = (i%2===0) ? '#9b0000' : '#000000';
    ctx.fill();
  }
  // inner circle
  ctx.beginPath();
  ctx.fillStyle = '#222';
  ctx.arc(cx,cy, r*0.55, 0, Math.PI*2);
  ctx.fill();
  // center
  ctx.beginPath();
  ctx.fillStyle = '#d1c6b3';
  ctx.arc(cx,cy, r*0.12,0,Math.PI*2);
  ctx.fill();
}

// draw slot screen symbols to canvas
function drawSlotScreen(ctx, reels, centerIndex){
  ctx.clearRect(0,0,256,256);
  ctx.fillStyle = '#080300';
  ctx.fillRect(0,0,256,256);
  ctx.fillStyle = '#ffd27f';
  ctx.fillRect(8,8,240,240);
  ctx.fillStyle = '#000';
  ctx.fillRect(12,12,232,232);
  ctx.font = '48px serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#fff';
  // draw three symbols vertically centered
  for (let col=0; col<3; col++){
    const sym = reels[(centerIndex + col) % reels.length];
    ctx.fillText(sym, 40 + col*85, 130);
  }
  // small highlight
  ctx.strokeStyle = 'rgba(255,215,140,0.18)';
  ctx.lineWidth = 6;
  ctx.strokeRect(8,8,240,240);
}

// -------------------- Fin --------------------
</script>
</body>
</html>
