<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Casino 3D â€” Perfecto</title>
<style>
  :root{--bg:#0b0f1a;--panel:#101625;--accent:#f5b642;--muted:#9aa5b1}
  html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:white;overflow:hidden}
  #container{width:100%;height:100%}
  #ui{position:absolute;top:12px;left:12px;z-index:50}
  .panel{background:rgba(0,0,0,0.45);padding:10px;border-radius:8px;margin-bottom:8px;backdrop-filter:blur(4px)}
  #modal{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    width:460px;max-width:95vw;background:var(--panel);padding:18px;border-radius:12px;
    display:none;z-index:100;max-height:80vh;overflow:auto;box-shadow:0 8px 30px rgba(0,0,0,0.6)
  }
  #npcMsg{position:absolute;bottom:12px;left:50%;transform:translateX(-50%);
    background:rgba(0,0,0,0.6);padding:8px 12px;border-radius:8px;display:none}
  button,input,select{background:#182034;color:white;border:1px solid #334;padding:8px;border-radius:8px;margin:6px 0;cursor:pointer}
  .gameUI h2{margin:4px 0 10px 0;text-align:center}
  .gameUI{display:flex;flex-direction:column;align-items:center}
  .gameUI .row{width:100%;display:flex;gap:8px;justify-content:center}
  .gameResult{margin-top:10px;color:var(--accent);min-height:30px;text-align:center}
  label{font-size:0.95rem}
  input[type=number]{width:100px;padding:6px;border-radius:6px}
  .small{font-size:0.85rem;color:#c3cbd2}
</style>
</head>
<body>
<div id="container"></div>

<div id="ui" class="panel">
  <div>Saldo: <strong id="balance">0</strong> â‚¬</div>
  <div class="small">Pulsa <b>E</b> para interactuar â€” mueve con WASD y rota con flechas</div>
</div>

<div id="modal" role="dialog" aria-modal="true"></div>
<div id="npcMsg">Pulsa E para recoger fichas diarias</div>

<!-- three.js -->
<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>

<script>
(async function(){

/* ---------------------
   InicializaciÃ³n usuario
   --------------------- */
const balanceEl = document.getElementById('balance');
let currentUser;
try{ currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null'); }catch(e){ currentUser = null; }
if(!currentUser){
  // Usuario de prueba local (si en tu app tienes login, localStorage debe contener currentUser)
  currentUser = { id: 1, username: 'Guest', pekepuntos: 1000, last_claim: null };
  localStorage.setItem('currentUser', JSON.stringify(currentUser));
}
let balance = Number(currentUser.pekepuntos || 0);
function refreshBalance(){ balanceEl.textContent = balance.toLocaleString(); }
function saveBalance(){
  currentUser.pekepuntos = balance;
  localStorage.setItem('currentUser', JSON.stringify(currentUser));
  refreshBalance();
}
refreshBalance();

/* ---------------------
   Helpers
   --------------------- */
function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* ---------------------
   THREE scene, camera, renderer
   --------------------- */
const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0f1a);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,1.6,5);
camera.rotation.order = 'YXZ';

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.outputColorSpace = THREE.SRGBColorSpace;
container.appendChild(renderer.domElement);

/* ---------------------
   Lights
   --------------------- */
const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.8); hemi.position.set(0,50,0); scene.add(hemi);
scene.add(new THREE.AmbientLight(0xffffff, 0.22));
const dir = new THREE.DirectionalLight(0xfff6d6, 0.6); dir.position.set(5,10,5); dir.castShadow = true; scene.add(dir);

/* ---------------------
   Canvas textures (reusable)
   --------------------- */
function canvasTexture(size, drawFn){
  const c = document.createElement('canvas'); c.width = c.height = size;
  const ctx = c.getContext('2d');
  drawFn(ctx, size);
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.anisotropy = 4;
  return tex;
}

/* floor pattern */
const floorTex = canvasTexture(1024, (ctx, s) => {
  // radial soft pattern + grid
  ctx.fillStyle = '#1b0022';
  ctx.fillRect(0,0,s,s);
  const grd = ctx.createLinearGradient(0,0,s,s);
  grd.addColorStop(0,'#22001f'); grd.addColorStop(1,'#0e0010');
  ctx.fillStyle = grd; ctx.globalAlpha = 0.7; ctx.fillRect(0,0,s,s); ctx.globalAlpha = 1;
  ctx.strokeStyle = 'rgba(255,255,255,0.02)'; ctx.lineWidth = 2;
  for(let i=0;i<s;i+=64){
    ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,s); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(s,i); ctx.stroke();
  }
});

/* marble walls */
const marbleTex = canvasTexture(1024, (ctx,s)=>{
  ctx.fillStyle = '#222428'; ctx.fillRect(0,0,s,s);
  for(let i=0;i<300;i++){
    ctx.strokeStyle = `rgba(255,255,255,${0.02+Math.random()*0.03})`;
    ctx.beginPath();
    ctx.moveTo(Math.random()*s, Math.random()*s);
    ctx.quadraticCurveTo(Math.random()*s, Math.random()*s, Math.random()*s, Math.random()*s);
    ctx.stroke();
  }
});

/* blackjack felt */
const blackjackTex = canvasTexture(512, (ctx,s)=>{
  ctx.fillStyle = '#084b2f'; ctx.fillRect(0,0,s,s);
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  for(let i=0;i<200;i++){ ctx.fillRect(Math.random()*s, Math.random()*s, 1, 1); }
  ctx.strokeStyle = '#f2e7c9'; ctx.lineWidth = Math.max(1, s/160);
  ctx.strokeRect(6, s-120, s-12, 108);
  ctx.fillStyle = '#fff'; ctx.font = '18px Arial'; ctx.textAlign='center';
  ctx.fillText('BLACKJACK PAYS 3 TO 2', s/2, 26);
});

/* slot screen texture (empty dark) */
const slotScreenTex = canvasTexture(512, (ctx,s)=>{
  ctx.fillStyle = '#05050b'; ctx.fillRect(0,0,s,s);
  const g = ctx.createLinearGradient(0,0,s,0);
  g.addColorStop(0, 'rgba(255,255,255,0.02)'); g.addColorStop(1,'rgba(0,0,0,0.15)');
  ctx.fillStyle = g; ctx.fillRect(0,0,s,s);
});

/* metallic */
const metalTex = canvasTexture(256, (ctx,s)=>{
  const g = ctx.createLinearGradient(0,0,s,s); g.addColorStop(0,'#777'); g.addColorStop(1,'#bcbcbc');
  ctx.fillStyle = g; ctx.fillRect(0,0,s,s);
});

/* ---------------------
   Room (floor + walls)
   --------------------- */
const floorMat = new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.95, metalness: 0.02 });
const floor = new THREE.Mesh(new THREE.PlaneGeometry(30,30), floorMat);
floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

const wallMat = new THREE.MeshStandardMaterial({ map: marbleTex, roughness: 0.9 });
function makeWall(x,z,rotY=0){
  const wall = new THREE.Mesh(new THREE.BoxGeometry(30,6,0.2), wallMat);
  wall.position.set(x,3,z); wall.rotation.y = rotY; wall.receiveShadow=true; scene.add(wall);
}
makeWall(0,-15); makeWall(0,15,Math.PI); makeWall(-15,0,Math.PI/2); makeWall(15,0,-Math.PI/2);

/* ---------------------
   Objects: Blackjack table, Roulette (base + disk), Slot machine, NPC
   --------------------- */
const interactables = [];

/* blackjack table */
const bjMat = new THREE.MeshStandardMaterial({ map: blackjackTex, roughness: 0.6, metalness: 0.02 });
const bjTable = new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.6,0.3,64), bjMat);
bjTable.position.set(-4,0.3,0); bjTable.userData.type='blackjack';
bjTable.castShadow = true; bjTable.receiveShadow = true; scene.add(bjTable); interactables.push(bjTable);

/* roulette base + wheel (disk) */
const ruletaBase = new THREE.Mesh(new THREE.CylinderGeometry(1.2,1.2,0.4,64), new THREE.MeshStandardMaterial({ color:0x222222, metalness:0.45, roughness:0.25 }));
ruletaBase.position.set(0,0.2,0); ruletaBase.userData.type='roulette';
ruletaBase.castShadow=true; ruletaBase.receiveShadow=true; scene.add(ruletaBase); interactables.push(ruletaBase);

/* ruleta disk (separate mesh to rotate) */
const ruletaDisk = new THREE.Mesh(new THREE.CylinderGeometry(1.15,1.15,0.08,256), new THREE.MeshStandardMaterial({ map: null, metalness:0.25, roughness:0.45 }));
ruletaDisk.rotation.x = Math.PI/2;
ruletaDisk.position.set(0,0.45,0);
ruletaDisk.castShadow=true; ruletaDisk.receiveShadow=true;
scene.add(ruletaDisk);

/* create numbered segments on a canvas and set as texture for disk */
(function createRouletteTexture(){
  const s = 2048;
  const canv = document.createElement('canvas'); canv.width = canv.height = s;
  const ctx = canv.getContext('2d');
  ctx.translate(s/2, s/2);
  const cellCount = 37;
  const anglePer = (Math.PI*2)/cellCount;
  // outer circle
  ctx.fillStyle = '#2f1b10'; ctx.beginPath(); ctx.arc(0,0,s/2,0,Math.PI*2); ctx.fill();
  const redNums = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
  for(let i=0;i<cellCount;i++){
    const start = i*anglePer - Math.PI/2;
    const end = start + anglePer;
    const isZero = (i===0);
    ctx.beginPath();
    ctx.fillStyle = isZero ? '#0b8a12' : (redNums.has(i) ? '#d22' : '#111');
    ctx.moveTo(0,0);
    ctx.arc(0,0,s*0.48,start,end);
    ctx.closePath(); ctx.fill();
    // numbers
    ctx.save();
    ctx.rotate(start + anglePer/2);
    ctx.fillStyle = isZero ? '#fff' : '#fff';
    ctx.font = `${s*0.05}px Arial`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(i.toString(), 0, -s*0.35);
    ctx.restore();
  }
  // center wood
  ctx.beginPath(); ctx.fillStyle='#8b5a2b'; ctx.arc(0,0,s*0.18,0,Math.PI*2); ctx.fill();
  const tex = new THREE.CanvasTexture(canv); tex.needsUpdate = true;
  tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
  ruletaDisk.material.map = tex;
  ruletaDisk.material.needsUpdate = true;
})();

/* slot machine model (group) */
function createSlotMachine(){
  const g = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(1.1,2.1,1.0), new THREE.MeshStandardMaterial({ color:0x222222, metalness:0.6, roughness:0.25 }));
  body.position.y = 1.05; g.add(body);
  const screen = new THREE.Mesh(new THREE.PlaneGeometry(0.7,0.45), new THREE.MeshStandardMaterial({ map: slotScreenTex, emissive: 0x111111, emissiveIntensity: 0.9 }));
  screen.position.set(0,1.4,0.51); g.add(screen);
  const lever = new THREE.Mesh(new THREE.CylinderGeometry(0.04,0.04,0.9,12), new THREE.MeshStandardMaterial({ color:0xaa3333, metalness:0.4, roughness:0.4 }));
  lever.rotation.z = -Math.PI/2; lever.position.set(0.6,1.1,0); g.add(lever);
  const coin = new THREE.Mesh(new THREE.TorusGeometry(0.12, 0.03, 12, 24), new THREE.MeshStandardMaterial({ color:0xffdd66, metalness:0.9, roughness:0.2 }));
  coin.position.set(0.95,1.1,0); g.add(coin);
  return g;
}
const slotMachine = createSlotMachine();
slotMachine.position.set(4,0,0);
slotMachine.userData = { type: 'slots' }; // for raycast we add proxy separately
scene.add(slotMachine);
const slotProxy = new THREE.Mesh(new THREE.BoxGeometry(1.05,2.05,1.05), new THREE.MeshBasicMaterial({ visible:false }));
slotProxy.position.copy(slotMachine.position); slotProxy.position.y = 1; slotProxy.userData.type = 'slots';
scene.add(slotProxy); interactables.push(slotProxy);

/* NPC (glossy chest-coffer) */
const npc = new THREE.Mesh(new THREE.CylinderGeometry(0.42,0.42,1.6,16), new THREE.MeshStandardMaterial({ color:0xdddddd, metalness:0.7, roughness:0.25, map: metalTex }));
npc.position.set(0,1,5); npc.userData.type = 'npc'; npc.castShadow = true; scene.add(npc); interactables.push(npc);

/* add ruletaBase and blackjack table to interactables already added earlier */
interactables.push(ruletaBase);
interactables.push(bjTable);

/* ---------------------
   Movement & camera control
   --------------------- */
const keys = {};
document.addEventListener('keydown', e => keys[e.code] = true);
document.addEventListener('keyup', e => keys[e.code] = false);
let yaw = 0, pitch = 0;

function updateCamera(dt){
  const yawSpeed = 1.8, pitchSpeed = 1.2;
  if(keys['ArrowLeft']) yaw += yawSpeed * dt;
  if(keys['ArrowRight']) yaw -= yawSpeed * dt;
  if(keys['ArrowUp']) pitch += pitchSpeed * dt;
  if(keys['ArrowDown']) pitch -= pitchSpeed * dt;
  const pitchLimit = Math.PI/2 - 0.05;
  pitch = clamp(pitch, -pitchLimit, pitchLimit);
  camera.rotation.set(pitch, yaw, 0);

  const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
  const right = new THREE.Vector3(); right.crossVectors(forward, camera.up).normalize();
  const move = new THREE.Vector3();
  if(keys['KeyW']) move.add(forward);
  if(keys['KeyS']) move.sub(forward);
  if(keys['KeyD']) move.add(right);
  if(keys['KeyA']) move.sub(right);
  move.multiplyScalar(3 * dt);
  camera.position.add(move);
}

/* ---------------------
   Raycast / interaction detection
   --------------------- */
const ray = new THREE.Raycaster();
let lookingAt = null;
const npcMsgEl = document.getElementById('npcMsg');

function checkInteraction(){
  ray.set(camera.position, camera.getWorldDirection(new THREE.Vector3()));
  const hits = ray.intersectObjects(interactables, false);
  if(!hits.length || hits[0].distance > 4){ lookingAt = null; npcMsgEl.style.display = 'none'; return; }
  lookingAt = hits[0].object;
  npcMsgEl.style.display = (lookingAt.userData.type === 'npc') ? 'block' : 'none';
}

/* ---------------------
   UI modal functions
   --------------------- */
const modal = document.getElementById('modal');
function showUI(html){
  modal.innerHTML = html; modal.style.display = 'block';
}
function hideUI(){ modal.style.display = 'none'; }

/* ---------------------
   Daily claim
   --------------------- */
async function claimDaily(){
  const today = new Date().toISOString().slice(0,10);
  const last = currentUser.last_claim ? currentUser.last_claim.slice(0,10) : null;
  if(last === today){
    showUI(`<div class="gameUI"><h2>Recompensa diaria</h2><div class="gameResult">Ya reclamaste hoy.</div><button onclick="document.getElementById('modal').style.display='none'">Cerrar</button></div>`);
    return;
  }
  balance += 100;
  currentUser.last_claim = new Date().toISOString();
  saveBalance();
  showUI(`<div class="gameUI"><h2>Recompensa diaria</h2><div class="gameResult">Recibiste +100 Pekepuntos.</div><button onclick="document.getElementById('modal').style.display='none'">Cerrar</button></div>`);
}

/* ---------------------
   Blackjack: full deck, UI, hit/stand/double/split (simplified split)
   --------------------- */
function createDeck(){
  const vals = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  const suits = ['â™ ','â™¥','â™¦','â™£'];
  const d = [];
  for(const s of suits) for(const v of vals) d.push({ v, s });
  // shuffle
  for(let i = d.length-1; i > 0; i--){ const j = Math.floor(Math.random()*(i+1)); [d[i], d[j]] = [d[j], d[i]]; }
  return d;
}
function valueOf(card){
  if(card.v === 'A') return 11;
  if(['J','Q','K'].includes(card.v)) return 10;
  return parseInt(card.v,10);
}
function score(hand){
  let sum = 0, aces = 0;
  for(const c of hand){ if(c.v === 'A') aces++; sum += valueOf(c); }
  while(sum > 21 && aces) { sum -= 10; aces--; }
  return sum;
}

function openBlackjack(){
  showUI(`
    <div class="gameUI">
      <h2>Blackjack</h2>
      <div class="row"><label>Apuesta: <input id="bjBet" type="number" value="50" min="1" /></label></div>
      <div class="row"><button id="dealBtn">Repartir</button><button id="closeBJ">Cerrar</button></div>
      <div id="bjState" style="width:100%;margin-top:8px;"></div>
      <div id="bjActions" class="row" style="display:flex;flex-wrap:wrap;justify-content:center;gap:8px;margin-top:8px"></div>
      <div class="gameResult" id="bjResult"></div>
    </div>
  `);
  const stateEl = document.getElementById('bjState');
  const actionsEl = document.getElementById('bjActions');
  const resultEl = document.getElementById('bjResult');
  const betInput = document.getElementById('bjBet');
  let deck, playerHand, dealerHand, betAmount, splitHand=null, inRound=false;

  function renderHands(){
    const ph = playerHand.map(c => c.v + c.s).join(' ');
    const dh = dealerHand.map((c,i) => i===0 && inRound ? (c.v + c.s) + ' ?' : c.v + c.s).join(' ');
    stateEl.innerHTML = `<div style="text-align:left"><strong>Jugador:</strong> ${ph} â€” (${score(playerHand)})</div>
                         <div style="text-align:left"><strong>Dealer:</strong> ${dh} â€” (${inRound ? '??' : score(dealerHand)})</div>`;
  }

  function endRound(){
    inRound = false;
    actionsEl.innerHTML = '';
    // reveal and compute result
    const playerScore = score(playerHand);
    let dealerScore = score(dealerHand);
    while(dealerScore < 17){ dealerHand.push(deck.pop()); dealerScore = score(dealerHand); }
    if(playerScore > 21){ resultEl.textContent = `Te pasaste (${playerScore}). Pierdes ${betAmount}`; balance -= betAmount; }
    else if(dealerScore > 21 || playerScore > dealerScore){ resultEl.textContent = `Ganas! Tu ${playerScore} / Dealer ${dealerScore} â†’ +${betAmount}`; balance += betAmount; }
    else if(playerScore === dealerScore){ resultEl.textContent = `Empate (${playerScore}). No hay cambios.`; }
    else { resultEl.textContent = `Pierdes (${playerScore} vs ${dealerScore}). -${betAmount}`; balance -= betAmount; }
    saveBalance();
    renderHands();
    // auto-close after a short time
    setTimeout(()=> hideUI(), 1600);
  }

  document.getElementById('dealBtn').onclick = () => {
    betAmount = clamp(Number(betInput.value) || 0, 1, balance);
    if(!betAmount || betAmount <= 0){ resultEl.textContent = 'Introduce una apuesta vÃ¡lida.'; return; }
    deck = createDeck();
    playerHand = [deck.pop(), deck.pop()];
    dealerHand = [deck.pop(), deck.pop()];
    inRound = true;
    renderHands();
    actionsEl.innerHTML = `
      <button id="hitBtn">Pedir</button>
      <button id="standBtn">Plantarse</button>
      <button id="doubleBtn">Doblar</button>
      <button id="splitBtn">Dividir</button>
    `;
    resultEl.textContent = '';
    // attach actions
    document.getElementById('hitBtn').onclick = () => {
      playerHand.push(deck.pop());
      renderHands();
      if(score(playerHand) > 21){ endRound(); }
    };
    document.getElementById('standBtn').onclick = () => { endRound(); };
    document.getElementById('doubleBtn').onclick = () => {
      if(balance < betAmount * 2){ resultEl.textContent = 'Saldo insuficiente para doblar.'; return; }
      balance -= betAmount; betAmount *= 2;
      playerHand.push(deck.pop());
      renderHands();
      endRound();
    };
    const canSplit = playerHand.length === 2 && playerHand[0].v === playerHand[1].v && balance >= betAmount;
    const splitBtn = document.getElementById('splitBtn');
    if(!canSplit){ splitBtn.disabled = true; }
    else {
      splitBtn.onclick = () => {
        // Simplified split handling: treat as two separate single-card hands, resolve sequentially.
        const cardA = [playerHand[0], deck.pop()];
        const cardB = [playerHand[1], deck.pop()];
        // Play each quickly: we'll compare both to dealer
        const resolveHand = (hand) => {
          while(score(hand) < 17) hand.push(deck.pop());
          return hand;
        };
        // deduct an extra bet
        balance -= betAmount;
        const hand1 = resolveHand(cardA);
        const hand2 = resolveHand(cardB);
        const dealerResolve = () => { while(score(dealerHand) < 17) dealerHand.push(deck.pop()); };
        dealerResolve();
        let payout = 0;
        const check = (h) => {
          const ps = score(h), ds = score(dealerHand);
          if(ps > 21) return -betAmount;
          if(ds > 21 || ps > ds) return betAmount;
          if(ps === ds) return 0;
          return -betAmount;
        };
        payout += check(hand1) + check(hand2);
        balance += payout;
        saveBalance();
        resultEl.innerHTML = `Split result â€” Dealer ${score(dealerHand)}. Mano1 ${score(hand1)} / Mano2 ${score(hand2)} â†’ ${payout>=0?('+'+payout):payout}`;
        renderHands();
        setTimeout(()=> hideUI(), 2000);
      };
    }
  };

  document.getElementById('closeBJ').onclick = () => hideUI();
}

/* ---------------------
   Roulette: UI + spin animation of ruletaDisk (visual)
   --------------------- */
let ruletaSpinning = false, ruletaVelocity = 0, ruletaTargetAngle = 0;
function openRoulette(){
  showUI(`
    <div class="gameUI">
      <h2>Ruleta</h2>
      <div class="row"><label>Apuesta: <input id="rBet" type="number" value="50" min="1" /></label></div>
      <div class="row">
        <button id="btnNumber">NÃºmero</button>
        <button id="btnColor">Color</button>
        <button id="btnParity">Par/Impar</button>
      </div>
      <div id="rOptions" style="margin-top:8px" class="row"></div>
      <div id="rResult" class="gameResult"></div>
      <div class="row"><button id="closeR">Cerrar</button></div>
    </div>
  `);
  const options = document.getElementById('rOptions');
  const rResult = document.getElementById('rResult');
  const rBet = document.getElementById('rBet');

  function commitSpin(type, value){
    const bet = clamp(Number(rBet.value)||0, 1, balance);
    if(!bet){ rResult.textContent = 'Introduce una apuesta vÃ¡lida.'; return; }
    // start visual spin
    ruletaSpinning = true;
    ruletaVelocity = 10 + Math.random()*6;
    // select landing number
    const landing = rand(0,36);
    // compute target angle so that landing number faces a "pointer" at angle 0.
    // On texture we placed numbers starting at -Math.PI/2 offset; we simply map index -> angle
    const idx = landing;
    const anglePer = (Math.PI*2)/37;
    const desired = - (idx * anglePer); // choose negative rotation to match earlier mapping
    // simulate several rotations
    const spins = 3 + Math.floor(Math.random()*3);
    ruletaTargetAngle = spins * Math.PI*2 + desired;
    // temporarily lock UI spin button
    rResult.textContent = 'Girando...';
    // determine win after delay (we'll check when spin stops)
    // store bet & choice for result resolution
    ruletaPending = { bet, type, value, landing, rResult };
    // deduct player bet now
    balance -= bet; saveBalance();
    refreshBalance();
  }

  document.getElementById('btnNumber').onclick = () => {
    options.innerHTML = '';
    for(let i=0;i<=36;i++){
      const b = document.createElement('button'); b.textContent = i; b.onclick = ()=> commitSpin('number', i);
      options.appendChild(b);
    }
  };
  document.getElementById('btnColor').onclick = () => {
    options.innerHTML = '';
    ['rojo','negro'].forEach(c => {
      const b = document.createElement('button'); b.textContent = c; b.onclick = ()=> commitSpin('color', c);
      options.appendChild(b);
    });
  };
  document.getElementById('btnParity').onclick = () => {
    options.innerHTML = '';
    ['par','impar'].forEach(p => {
      const b = document.createElement('button'); b.textContent = p; b.onclick = ()=> commitSpin('par', p);
      options.appendChild(b);
    });
  };

  document.getElementById('closeR').onclick = () => hideUI();
}

// pending spin info
let ruletaPending = null;

/* ---------------------
   Slots UI (screen animation simulated / reels handled in UI)
   --------------------- */
function openSlots(){
  showUI(`
    <div class="gameUI">
      <h2>Tragamonedas</h2>
      <div class="row"><label>Apuesta: <input id="sBet" type="number" value="50" min="1" /></label></div>
      <div class="row"><button id="playSlotsBtn">Jugar</button></div>
      <div id="slotsReels" style="font-size:32px;margin-top:10px">â€¢ â€¢ â€¢</div>
      <div id="slotsRes" class="gameResult"></div>
      <div class="row"><button id="closeS">Cerrar</button></div>
    </div>
  `);
  const reelsEl = document.getElementById('slotsReels');
  const resEl = document.getElementById('slotsRes');
  const betEl = document.getElementById('sBet');
  const symbols = ['ðŸ’','ðŸ‹','ðŸŠ','ðŸ‡','ðŸ’Ž','7ï¸âƒ£'];

  document.getElementById('playSlotsBtn').onclick = () => {
    const bet = clamp(Number(betEl.value)||0, 1, balance);
    if(!bet){ resEl.textContent = 'Introduce una apuesta vÃ¡lida.'; return; }
    balance -= bet; saveBalance();
    // animate reels
    let ticks = 0; const final = [];
    const interval = setInterval(()=>{
      ticks++;
      const a = symbols[rand(0,symbols.length-1)], b = symbols[rand(0,symbols.length-1)], c = symbols[rand(0,symbols.length-1)];
      reelsEl.textContent = `${a} ${b} ${c}`;
      if(ticks > 24){
        clearInterval(interval);
        // finalize
        final[0] = symbols[rand(0,symbols.length-1)];
        final[1] = symbols[rand(0,symbols.length-1)];
        final[2] = symbols[rand(0,symbols.length-1)];
        reelsEl.textContent = final.join(' ');
        let won = final[0] === final[1] && final[1] === final[2];
        if(won){ const payout = bet*5; balance += payout; resEl.textContent = `Â¡Jackpot! ${final.join(' ')} Ganaste ${payout}`; }
        else if(final[0]===final[1]||final[1]===final[2]||final[0]===final[2]){ const payout = bet*2; balance += payout; resEl.textContent = `Dos iguales ${final.join(' ')} Ganaste ${payout}`; }
        else { resEl.textContent = `Perdiste ${bet} â€” ${final.join(' ')}`; }
        saveBalance();
      }
    }, 50);
  };

  document.getElementById('closeS').onclick = () => hideUI();
}

/* ---------------------
   Keyboard E to open related UI
   --------------------- */
document.addEventListener('keydown', async (e) => {
  if(e.code !== 'KeyE') return;
  if(!lookingAt) return;
  const type = lookingAt.userData.type;
  if(type === 'npc'){ await claimDaily(); return; }
  if(type === 'blackjack'){ openBlackjack(); return; }
  if(type === 'roulette'){ openRoulette(); return; }
  if(type === 'slots'){ openSlots(); return; }
});

/* ---------------------
   Animation loop - handles ruleta spin damping & resolution
   --------------------- */
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  updateCamera(dt);
  checkInteraction();

  // ruleta spin animation
  if(ruletaSpinning){
    // simple angular approach to target
    const cur = ruletaDisk.rotation.z;
    // rotate forward by velocity
    ruletaDisk.rotation.z += ruletaVelocity * dt;
    // slowly reduce velocity
    ruletaVelocity = Math.max(0, ruletaVelocity - dt * 2.8);
    // if velocity low, ease to target
    if(ruletaVelocity <= 0.01){
      // snap toward target angle (increase rotation toward ruletaTargetAngle)
      const diff = ruletaTargetAngle - (ruletaDisk.userData._spinStart || 0) - (ruletaDisk.rotation.z - (ruletaDisk.userData._spinBase || 0));
      // actually simply stop and resolve now
      ruletaSpinning = false;
      // resolve pending
    }
  }

  // if there is a pending ruleta and the disk has slowed a lot, resolve outcome
  if(ruletaPending && !ruletaSpinning && ruletaVelocity <= 0.02){
    // resolve immediately using ruletaPending.landing
    const pending = ruletaPending;
    const landing = pending.landing;
    // color & parity
    const redSet = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
    const color = landing === 0 ? 'green' : (redSet.has(landing) ? 'rojo' : 'negro');
    const parity = landing === 0 ? 'none' : (landing % 2 === 0 ? 'par' : 'impar');
    let won = false, payout = 0;
    const type = pending.type, value = pending.value;
    if(type === 'number'){ if(Number(value) === landing){ won = true; payout = pending.bet * 35; } }
    else if(type === 'color'){ if(value === color) { won = true; payout = pending.bet * 2; } }
    else if(type === 'par'){ if(value === parity) { won = true; payout = pending.bet * 2; } }
    if(won){ balance += payout; pending.rResult.textContent = `Â¡Sale ${landing} (${color}) â€” Ganaste ${payout}!`; }
    else { pending.rResult.textContent = `Sale ${landing} (${color}) â€” Perdiste ${pending.bet}`; }
    saveBalance();
    ruletaPending = null;
  }

  renderer.render(scene, camera);
}
animate();

/* ---------------------
   Resize handling
   --------------------- */
window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ---------------------
   Debug helper (opcional)
   --------------------- */
window._casino = { scene, camera, renderer, currentUser, saveBalance };

/* ---------------------
   Success: ready
   --------------------- */
console.log('Casino 3D inicializado â€” versiÃ³n A (full quality).');

})(); // end main
</script>
</body>
</html>
