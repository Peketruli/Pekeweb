<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Casino 3D - Fase 1 Mejorada</title>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<style>
  body {
    margin: 0; 
    overflow: hidden; 
    background: #000; 
    font-family: Arial, Helvetica, sans-serif;
  }
  #hint {
    position: absolute; 
    left: 12px; 
    top: 12px; 
    z-index: 5;
    background: rgba(0,0,0,0.5); 
    color: #fff; 
    padding:8px 10px; 
    border-radius:8px;
    font-size:13px;
  }
</style>
</head>
<body>
<div id="hint">ðŸŽ° Mover: W A S D â€” Mirar: ratÃ³n</div>
<script>
// ---------- Escena, cÃ¡mara y renderer ----------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050008);
scene.fog = new THREE.Fog(0x050008, 15, 80);

const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(0, 1.7, 10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// ---------- Luces ----------
scene.add(new THREE.AmbientLight(0xffffff, 0.3));

const neonPink = new THREE.PointLight(0xff00ff, 1.8, 40);
neonPink.position.set(10, 5, 0);
scene.add(neonPink);

const neonCyan = new THREE.PointLight(0x00ffff, 1.8, 40);
neonCyan.position.set(-10, 5, 0);
scene.add(neonCyan);

const warmLight = new THREE.SpotLight(0xffaa88, 0.6, 60, Math.PI / 6, 0.3);
warmLight.position.set(0, 12, 0);
scene.add(warmLight);

// ---------- Texturas ----------
const loader = new THREE.TextureLoader();

const floorTex = loader.load("https://cdn.pixabay.com/photo/2016/11/21/15/55/pattern-1846866_1280.jpg");
floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
floorTex.repeat.set(10, 10);

const wallTex = loader.load("https://cdn.pixabay.com/photo/2016/11/29/10/07/brick-wall-1867284_1280.jpg");
wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;
wallTex.repeat.set(6, 3);

// ---------- Suelo y paredes ----------
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(60, 60),
  new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.8 })
);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

const wallMat = new THREE.MeshStandardMaterial({ map: wallTex, roughness: 0.9 });
const backWall = new THREE.Mesh(new THREE.BoxGeometry(60, 10, 1), wallMat);
backWall.position.set(0, 5, -25);
scene.add(backWall);

const leftWall = new THREE.Mesh(new THREE.BoxGeometry(1, 10, 60), wallMat);
leftWall.position.set(-30, 5, 5);
scene.add(leftWall);

const rightWall = new THREE.Mesh(new THREE.BoxGeometry(1, 10, 60), wallMat);
rightWall.position.set(30, 5, 5);
scene.add(rightWall);

// ---------- Elementos decorativos ----------
const slotTex = new THREE.MeshStandardMaterial({ 
  color: 0xaa00ff, 
  emissive: 0x440044, 
  metalness: 0.6, 
  roughness: 0.3 
});
for (let i = 0; i < 6; i++) {
  const slot = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.5, 1.5), slotTex);
  slot.position.set(i * 3 - 7.5, 1.25, -10);
  slot.castShadow = true;
  scene.add(slot);
}

const table = new THREE.Mesh(
  new THREE.CylinderGeometry(5, 5, 0.5, 32),
  new THREE.MeshStandardMaterial({ color: 0x004400, metalness: 0.3 })
);
table.position.set(0, 0.25, 5);
table.receiveShadow = true;
scene.add(table);

const ruleta = new THREE.Mesh(
  new THREE.CylinderGeometry(2, 2, 0.3, 32),
  new THREE.MeshStandardMaterial({ color: 0xdd0000, metalness: 0.6 })
);
ruleta.position.set(-10, 0.15, 8);
ruleta.castShadow = true;
scene.add(ruleta);

// ---------- Movimiento y cÃ¡mara ----------
let yaw = 0, pitch = 0;
const sens = 0.0026;
const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

const velocity = new THREE.Vector3();
const accel = 30.0;
const damping = 10.0;
const forwardVec = new THREE.Vector3();
const rightVec = new THREE.Vector3();
const upVec = new THREE.Vector3(0,1,0);
const clock = new THREE.Clock();

window.addEventListener('mousemove', e => {
  yaw -= (e.movementX || 0) * sens;
  pitch -= (e.movementY || 0) * sens;
  const maxPitch = Math.PI / 2 - 0.05;
  pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));
});

function updateMovement(dt) {
  camera.rotation.set(pitch, yaw, 0, "ZYX");
  camera.updateMatrixWorld();

  camera.getWorldDirection(forwardVec);
  forwardVec.y = 0;
  forwardVec.normalize();
  rightVec.copy(forwardVec).cross(upVec).negate();

  let moveX = 0, moveZ = 0;
  if (keys['KeyW']) moveZ += 1;
  if (keys['KeyS']) moveZ -= 1;
  if (keys['KeyD']) moveX -= 1;
  if (keys['KeyA']) moveX += 1;

  const desired = new THREE.Vector3();
  desired.addScaledVector(forwardVec, moveZ);
  desired.addScaledVector(rightVec, moveX);
  if (desired.lengthSq() > 0) desired.normalize();

  velocity.addScaledVector(desired, accel * dt);
  velocity.multiplyScalar(1 / (1 + damping * dt));

  camera.position.addScaledVector(velocity, dt);
}

// ---------- AnimaciÃ³n ----------
function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.05);
  updateMovement(dt);

  // animaciones ligeras
  ruleta.rotation.y += 0.01;
  neonPink.intensity = 1.5 + Math.sin(Date.now() * 0.002) * 0.3;
  neonCyan.intensity = 1.5 + Math.cos(Date.now() * 0.002) * 0.3;

  renderer.render(scene, camera);
}
animate();

// ---------- Resize ----------
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// ---------- Ocultar ayuda ----------
setTimeout(()=>{ document.getElementById('hint').style.display = 'none'; }, 4000);
</script>
</body>
</html>
