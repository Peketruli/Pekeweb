<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Casino 3D - Peketruli</title>
  <!-- Three.js and PointerLockControls from CDN -->
  <script src="https://unpkg.com/three@0.163.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.163.0/examples/js/controls/PointerLockControls.js"></script>
  <style>
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;overflow:hidden}
    #container{width:100%;height:100%;position:relative;background:#111}
    canvas{display:block}

    /* UI overlays */
    .hud{position:absolute;left:12px;top:12px;color:#fff;z-index:5;}
    #pekepoints{background:rgba(0,0,0,0.5);padding:10px;border-radius:8px}
    #minimap{position:absolute;right:12px;top:12px;background:rgba(0,0,0,0.5);padding:6px;border-radius:8px;z-index:5}
    #prompt{position:absolute;left:50%;bottom:60px;transform:translateX(-50%);background:rgba(0,0,0,0.6);padding:8px 12px;border-radius:6px;color:#fff;display:none;z-index:6}

    /* Modal */
    .modal{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:#222;color:#fff;padding:16px;border-radius:8px;z-index:10;display:none;min-width:320px}
    .modal h2{margin:0 0 8px}
    .controls{display:flex;gap:8px;align-items:center;margin-top:8px}
    .btn{background:#0a74ff;padding:8px 12px;border-radius:6px;border:none;color:white;cursor:pointer}
    .close{background:#444}

    /* Interaction hint */
    #hint{position:absolute;left:12px;bottom:12px;color:#eee;z-index:5}
    /* Small crosshair */
    #crosshair{position:absolute;left:50%;top:50%;width:8px;height:8px;margin:-4px 0 0 -4px;border-radius:50%;background:rgba(255,255,255,0.6);z-index:4}

    /* Simple responsive */
    @media (max-width:600px){.modal{min-width:90%}}
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="crosshair"></div>
  <div class="hud">
    <div id="pekepoints">Pekepoints: <span id="ppValue">1000</span></div>
  </div>
  <canvas id="mapCanvas" width="180" height="180" style="position:absolute;right:12px;top:12px;z-index:7;border-radius:6px;background:#111"></canvas>
  <div id="prompt">Presiona <b>E</b> para interactuar</div>
  <div id="hint">WASD mover • Shift correr • Barra espacio saltar • Click para bloquear ratón</div>

  <!-- Blackjack modal -->
  <div id="blackjack" class="modal">
    <h2>Blackjack</h2>
    <div>Tu apuesta: <input id="bjBet" type="number" value="10" min="1" style="width:80px"></div>
    <div class="controls">
      <button id="bjPlay" class="btn">Jugar</button>
      <button id="bjClose" class="btn close">Cerrar</button>
    </div>
    <div id="bjResult" style="margin-top:8px"></div>
  </div>

  <!-- Roulette modal -->
  <div id="roulette" class="modal">
    <h2>Ruleta</h2>
    <div>Tu apuesta (número 0-36): <input id="rNum" type="number" value="7" min="0" max="36" style="width:80px"></div>
    <div>Tu apuesta (cantidad): <input id="rBet" type="number" value="10" min="1" style="width:80px"></div>
    <div class="controls">
      <button id="rPlay" class="btn">Girar</button>
      <button id="rClose" class="btn close">Cerrar</button>
    </div>
    <div id="rResult" style="margin-top:8px"></div>
  </div>

  <!-- Slot modal -->
  <div id="slots" class="modal">
    <h2>Tragaperras</h2>
    <div>Apuesta: <input id="sBet" type="number" value="5" min="1" style="width:80px"></div>
    <div class="controls">
      <button id="sPlay" class="btn">Girar</button>
      <button id="sClose" class="btn close">Cerrar</button>
    </div>
    <div id="sResult" style="margin-top:8px"></div>
  </div>

<script>
// Basic three.js casino environment with interactions
let scene, camera, renderer, controls;
let objects = []; // interactive objects with metadata
let move = {forward:false,back:false,left:false,right:false,run:false};
let velocity = new THREE.Vector3();
let canJump = false;
let prevTime = performance.now();
let playerHeight = 1.8;
let pekepoints = 1000;
const container = document.getElementById('container');
const ppValue = document.getElementById('ppValue');
ppValue.textContent = pekepoints;

init();
animate();

function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x222233);

  camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
  camera.position.set(0, playerHeight, 0);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);

  // Lights
  const hemi = new THREE.HemisphereLight(0xffffff,0x444444,0.6);
  hemi.position.set(0,50,0); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff,0.6); dir.position.set(-10,20,10); scene.add(dir);

  // Floor
  const floorGeo = new THREE.PlaneGeometry(60,60);
  const floorMat = new THREE.MeshStandardMaterial({color:0x444455});
  const floor = new THREE.Mesh(floorGeo,floorMat); floor.rotation.x = -Math.PI/2; scene.add(floor);

  // Corridor and room
  buildCorridorAndRoom();

  // Add interactive casino objects
  addBlackjackTable(new THREE.Vector3(0,0, -6));
  addRoulette(new THREE.Vector3(6,0,-6));
  addSlots(new THREE.Vector3(-6,0,-6));

  // Door behind spawn leading to h.html
  addDoor(new THREE.Vector3(0,0,6));

  // Pointer lock controls
  controls = new THREE.PointerLockControls(camera, document.body);
  document.addEventListener('click', ()=>{ controls.lock(); }, false);

  controls.addEventListener('lock', ()=>{ document.getElementById('crosshair').style.display='block'; document.body.style.cursor='none'; });
  controls.addEventListener('unlock', ()=>{ document.getElementById('crosshair').style.display='none'; document.body.style.cursor='auto'; });

  scene.add(controls.getObject());

  // Movement keys
  const onKeyDown = function (event) {
    switch(event.code){
      case 'ArrowUp': case 'KeyW': move.forward=true; break;
      case 'ArrowLeft': case 'KeyA': move.left=true; break;
      case 'ArrowDown': case 'KeyS': move.back=true; break;
      case 'ArrowRight': case 'KeyD': move.right=true; break;
      case 'ShiftLeft': case 'ShiftRight': move.run=true; break;
      case 'Space': if(canJump){ velocity.y += 6; canJump=false; } break;
      case 'KeyE': tryInteract(); break;
    }
  };
  const onKeyUp = function(event){
    switch(event.code){
      case 'ArrowUp': case 'KeyW': move.forward=false; break;
      case 'ArrowLeft': case 'KeyA': move.left=false; break;
      case 'ArrowDown': case 'KeyS': move.back=false; break;
      case 'ArrowRight': case 'KeyD': move.right=false; break;
      case 'ShiftLeft': case 'ShiftRight': move.run=false; break;
    }
  };
  document.addEventListener('keydown',onKeyDown);
  document.addEventListener('keyup',onKeyUp);

  // Resize
  window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });

  // Raycaster for interaction
  window.raycaster = new THREE.Raycaster();

  // Minimap
  setupMiniMap();
}

function buildCorridorAndRoom(){
  // Corridor: a rectangular box with walls
  const corridorLength = 12;
  const corridorHeight = 3;
  const corridorWidth = 4;

  // Floor is already global. Build walls using boxes
  const wallMat = new THREE.MeshStandardMaterial({color:0x666677});
  const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.2,corridorHeight,corridorLength),wallMat);
  leftWall.position.set(-corridorWidth/2, corridorHeight/2, 0); scene.add(leftWall);
  const rightWall = leftWall.clone(); rightWall.position.set(corridorWidth/2, corridorHeight/2, 0); scene.add(rightWall);
  const ceiling = new THREE.Mesh(new THREE.BoxGeometry(corridorWidth,0.2,corridorLength), wallMat);
  ceiling.position.set(0,corridorHeight,0); scene.add(ceiling);

  // Room at far end
  const room = new THREE.Mesh(new THREE.BoxGeometry(12,0.2,12), new THREE.MeshStandardMaterial({color:0x333344}));
  room.position.set(0,0, -6); // floor already
  // Add simple pillars/support for roulette (visual)

  // Spawn player at corridor start looking toward room
  controls?.getObject?.().position.set(0, playerHeight, 6-0.5); // spawn just in front of door
  camera.position.set(0,playerHeight,6-0.5);
}

function addBlackjackTable(pos){
  const table = new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.6,0.4,24), new THREE.MeshStandardMaterial({color:0x003300}));
  table.position.copy(pos); table.position.y = 0.2; scene.add(table);
  const tag = { type:'blackjack', obj:table, pos:pos, range:2.0 };
  objects.push(tag);
}

function addRoulette(pos){
  const base = new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.6,0.6,32), new THREE.MeshStandardMaterial({color:0x552200}));
  base.position.copy(pos); base.position.y = 0.3; scene.add(base);
  const wheel = new THREE.Mesh(new THREE.CylinderGeometry(1.3,1.3,0.1,36), new THREE.MeshStandardMaterial({color:0x222222}));
  wheel.position.copy(pos); wheel.position.y = 0.7; wheel.rotation.x = Math.PI/2; scene.add(wheel);
  // simple indicator
  const indicator = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.6), new THREE.MeshStandardMaterial({color:0xff0000})); indicator.position.set(pos.x,1.2,pos.z+0.8); scene.add(indicator);
  objects.push({type:'roulette', obj:base, pos:pos, range:2.2});
}

function addSlots(pos){
  const body = new THREE.Mesh(new THREE.BoxGeometry(1,1.6,0.6), new THREE.MeshStandardMaterial({color:0x880033}));
  body.position.copy(pos); body.position.y = 0.8; scene.add(body);
  const screen = new THREE.Mesh(new THREE.PlaneGeometry(0.6,0.4), new THREE.MeshStandardMaterial({color:0xffffcc}));
  screen.position.set(pos.x,1.1,pos.z+0.35); scene.add(screen);
  objects.push({type:'slots', obj:body, pos:pos, range:2.0 });
}

function addDoor(pos){
  const door = new THREE.Mesh(new THREE.BoxGeometry(1.6,2.2,0.1), new THREE.MeshStandardMaterial({color:0x4444aa}));
  door.position.copy(pos); door.position.y = 1.1; scene.add(door);
  objects.push({type:'door', obj:door, pos:pos, range:2.0});
}

function tryInteract(){
  // check nearest interactive object within range
  const origin = controls.getObject().position;
  let nearest = null; let nd = Infinity;
  for(const it of objects){
    const d = it.pos.distanceTo(origin);
    if(d < it.range && d < nd){ nearest = it; nd = d; }
  }
  if(nearest){
    openInteraction(nearest.type);
  }
}

function openInteraction(type){
  if(type==='blackjack') showModal('blackjack');
  if(type==='roulette') showModal('roulette');
  if(type==='slots') showModal('slots');
  if(type==='door'){
    // animate door open then goto h.html
    window.location.href = 'h.html';
  }
}

// UI helpers
function showModal(id){ document.getElementById(id).style.display='block'; controls.unlock && controls.unlock(); document.body.style.cursor='auto'; }
function closeModal(id){ document.getElementById(id).style.display='none'; }

// Blackjack logic (very simplified)
document.getElementById('bjPlay').addEventListener('click', ()=>{
  const bet = Number(document.getElementById('bjBet').value)||1;
  if(bet>pekepoints){ document.getElementById('bjResult').textContent='No tienes suficientes pekepoints.'; return; }
  // Simplified: player and dealer random 1-21 (no real rules)
  const player = Math.floor(Math.random()*11)+11; // 11-21
  const dealer = Math.floor(Math.random()*11)+11;
  let result='Empate';
  if(player>21) result='Has perdido';
  else if(player>dealer) { result='Has ganado'; pekepoints += bet; }
  else if(player<dealer) { result='Has perdido'; pekepoints -= bet; }
  else { result='Empate'; }
  document.getElementById('bjResult').textContent = `Tu: ${player} — Crupier: ${dealer} — ${result}`;
  updatePP();
});
document.getElementById('bjClose').addEventListener('click', ()=> closeModal('blackjack'));

// Roulette logic
document.getElementById('rPlay').addEventListener('click', ()=>{
  const num = Number(document.getElementById('rNum').value)||0;
  const bet = Number(document.getElementById('rBet').value)||1;
  if(bet>pekepoints){ document.getElementById('rResult').textContent='Dinero insuficiente'; return; }
  const outcome = Math.floor(Math.random()*37);
  let text = `Sale ${outcome}. `;
  if(outcome===num){ pekepoints += bet*35; text += '¡Has ganado el pleno!'; }
  else { pekepoints -= bet; text += 'Has perdido.'; }
  document.getElementById('rResult').textContent = text;
  updatePP();
});
document.getElementById('rClose').addEventListener('click', ()=> closeModal('roulette'));

// Slots logic
document.getElementById('sPlay').addEventListener('click', ()=>{
  const bet = Number(document.getElementById('sBet').value)||1;
  if(bet>pekepoints){ document.getElementById('sResult').textContent='Dinero insuficiente'; return; }
  const symbols = ['🍒','🔔','⭐','7'];
  const a = symbols[Math.floor(Math.random()*symbols.length)];
  const b = symbols[Math.floor(Math.random()*symbols.length)];
  const c = symbols[Math.floor(Math.random()*symbols.length)];
  const res = `${a} ${b} ${c}`;
  let text = res + '. ';
  if(a===b && b===c){ pekepoints += bet*10; text += 'Gran premio!'; }
  else if(a===b || b===c || a===c){ pekepoints += bet*2; text += 'Pequeña victoria'; }
  else { pekepoints -= bet; text += 'Perdiste'; }
  document.getElementById('sResult').textContent = text;
  updatePP();
});
document.getElementById('sClose').addEventListener('click', ()=> closeModal('slots'));

function updatePP(){ ppValue.textContent = pekepoints; }

// Animation loop and physics
function animate(){
  requestAnimationFrame(animate);
  const time = performance.now();
  const delta = (time - prevTime) / 1000;

  // simple gravity and movement when pointer locked
  if(controls.isLocked === true){
    const speed = move.run ? 10 : 4.0;
    velocity.x -= velocity.x * 10.0 * delta;
    velocity.z -= velocity.z * 10.0 * delta;
    velocity.y -= 9.8 * 5.0 * delta; // gravity

    if(move.forward) velocity.z -= speed * delta;
    if(move.back) velocity.z += speed * delta;
    if(move.left) velocity.x -= speed * delta;
    if(move.right) velocity.x += speed * delta;

    // update position
    controls.getObject().translateX(velocity.x);
    controls.getObject().translateY(velocity.y * delta);
    controls.getObject().translateZ(velocity.z);

    // simple floor collision
    if(controls.getObject().position.y < playerHeight){ velocity.y = 0; controls.getObject().position.y = playerHeight; canJump = true; }
  }

  prevTime = time;
  renderer.render(scene, camera);
  updateInteractionPrompt();
  drawMiniMap();
}

// Interaction prompt display
function updateInteractionPrompt(){
  const origin = controls.getObject().position;
  let found=false;
  for(const it of objects){
    const d = it.pos.distanceTo(origin);
    if(d < it.range){ found=true; break; }
  }
  const p = document.getElementById('prompt');
  p.style.display = found ? 'block' : 'none';
}

// --- MINIMAP ---
let mapCanvas, mapCtx;
function setupMiniMap(){ mapCanvas = document.getElementById('mapCanvas'); mapCtx = mapCanvas.getContext('2d'); }
function drawMiniMap(){
  if(!mapCtx) return;
  const w = mapCanvas.width; const h = mapCanvas.height;
  mapCtx.fillStyle = '#0b0b0b'; mapCtx.fillRect(0,0,w,h);
  // transform world coords to map coords (center)
  const scale = 6; // world units -> pixels
  const cx = w/2; const cy = h/2;
  // draw room boundaries
  mapCtx.strokeStyle = '#666'; mapCtx.lineWidth=2;
  mapCtx.strokeRect(cx-60, cy-60, 120, 120);
  // draw objects
  for(const it of objects){
    const x = cx + it.pos.x * scale;
    const y = cy + -it.pos.z * scale; // invert z
    mapCtx.fillStyle = it.type==='blackjack'? '#0f0': it.type==='roulette'?'#ff0': it.type==='slots'?'#f0f':'#fff';
    mapCtx.beginPath(); mapCtx.arc(x,y,6,0,Math.PI*2); mapCtx.fill();
  }
  // draw player
  const pPos = controls.getObject().position;
  const px = cx + pPos.x * scale; const py = cy + -pPos.z * scale;
  mapCtx.fillStyle = '#00f'; mapCtx.beginPath(); mapCtx.arc(px,py,6,0,Math.PI*2); mapCtx.fill();
}

</script>
</body>
</html>
