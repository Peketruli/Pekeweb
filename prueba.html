<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Casino 3D â€” Mejorado</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
html,body{height:100%;margin:0;background:#030612;color:#fff;font-family:Arial,Helvetica,sans-serif;overflow:hidden}
#wrap{position:relative;height:100vh;overflow:hidden}
canvas{display:block}

.hud{position:absolute;right:12px;top:12px;z-index:40;max-width:380px}
.panel{background:rgba(0,0,0,0.7);padding:12px;border-radius:10px;margin-bottom:10px}
.info-row{display:flex;justify-content:space-between;align-items:center;margin:6px 0;font-size:13px}
#prompt{position:absolute;left:50%;transform:translateX(-50%);bottom:92px;background:rgba(0,0,0,0.7);padding:8px 12px;border-radius:8px;display:none;z-index:45}
#interaction-panel{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:420px;background:rgba(8,10,12,0.96);border-radius:10px;box-shadow:0 10px 40px rgba(0,0,0,0.7);color:#ddd;padding:16px;z-index:50;display:none}
#interaction-panel h3{margin-top:0;}
.btn{background:#d95d00;color:white;padding:8px 10px;border-radius:8px;border:none;cursor:pointer;margin-top:8px}
.card{display:inline-block;background:#111;padding:6px 8px;border-radius:6px;border:1px solid #333;margin-right:4px}
.log-entry{margin:2px 0;font-size:12px}
#minimap{position:absolute;left:12px;top:12px;width:120px;height:120px;background:rgba(255,255,255,0.02);border-radius:8px;z-index:30}
.highlight{box-shadow:0 0 15px 5px rgba(255,200,0,0.6);}
</style>
</head>
<body>
<div id="wrap">
  <div id="minimap"></div>
  <div class="hud">
    <div class="panel">
      <h3>Casino 3D Mejorado</h3>
      <div class="info-row"><span>Saldo</span><strong id="balance">1000</strong></div>
      <div class="info-row"><span>Apuesta</span><strong id="bet">0</strong></div>
      <div style="font-size:13px;margin-top:6px">Controles: <strong>W A S D</strong> moverse Â· <strong>Flechas</strong> girar cÃ¡mara Â· <strong>E</strong> interactuar</div>
    </div>
    <div class="panel">
      <h4>Historial</h4>
      <div id="log" style="max-height:120px;overflow:auto;font-size:12px;background:rgba(255,255,255,0.02);padding:6px;border-radius:6px"></div>
    </div>
  </div>
  <div id="prompt">[E] Interactuar</div>
  <div id="interaction-panel">
    <h3 id="panel-title">Juego</h3>
    <div id="panel-content"></div>
    <button class="btn" onclick="closePanel()">Cerrar</button>
  </div>
</div>

<script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
<script>
// ==================== CONFIGURACIÃ“N GENERAL ====================
const wrap = document.getElementById('wrap');
const balanceEl = document.getElementById('balance');
const betEl = document.getElementById('bet');
const logEl = document.getElementById('log');
const prompt = document.getElementById('prompt');
const panel = document.getElementById('interaction-panel');
const panelTitle = document.getElementById('panel-title');
const panelContent = document.getElementById('panel-content');

let balance = 1000; 
let currentBet = 0;
let playerPos = new THREE.Vector3(0,0,15);
let yaw = 0, pitch = 0;

function updateHUD(){ balanceEl.textContent=balance; betEl.textContent=currentBet; }
function addLog(msg){ 
  const div=document.createElement('div'); 
  div.className='log-entry'; 
  div.textContent=msg; 
  logEl.prepend(div); 
}
updateHUD();

// ==================== ESCENA THREE ====================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x041018);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(wrap.clientWidth, wrap.clientHeight);
wrap.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(72, wrap.clientWidth/wrap.clientHeight, 0.1, 1000);
camera.position.set(0,1.7,15);

// luces
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
dirLight.position.set(10,20,10); 
scene.add(dirLight);

// suelo y paredes
const floor = new THREE.Mesh(new THREE.PlaneGeometry(50,50), new THREE.MeshStandardMaterial({color:0x091217, roughness:0.95}));
floor.rotation.x=-Math.PI/2; 
scene.add(floor);

function wall(w,h,d,x,y,z,rotY){ 
  const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({color:0x071018})); 
  m.position.set(x,y,z); 
  if(rotY)m.rotation.y=rotY; 
  scene.add(m);
}

wall(50,10,2,0,5,-25);
wall(50,10,2,0,5,25);
wall(2,10,50,-25,5,0);
wall(2,10,50,25,5,0);

// ==================== RULETA 3D ====================
const wheelRadius = 4;
const pockets = [0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23,10,5,24,16,33,1,20,14,31,9,22,18,29,7,28,12,35,3,26];
const anglePerPocket = (Math.PI*2) / pockets.length;

// CreaciÃ³n textura de rueda
function createWheelCanvas(size=512){
  const c=document.createElement('canvas'); 
  c.width=c.height=size;
  const ctx=c.getContext('2d'); 
  const cx=size/2, cy=size/2, r=size*0.45;

  ctx.fillStyle='#072b22';
  ctx.fillRect(0,0,size,size);

  for(let i=0;i<pockets.length;i++){
    const a0=i*anglePerPocket-Math.PI/2;
    const a1=(i+1)*anglePerPocket-Math.PI/2;

    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,r,a0,a1);
    ctx.closePath();

    ctx.fillStyle = 
      pockets[i] === 0 ? "#1b8b41" : 
      (i % 2 === 0 ? "#b71c1c" : "#000");

    ctx.fill();

    ctx.save();
    const mid = a0 + (a1-a0)/2;
    ctx.translate(cx + Math.cos(mid)*r*0.66, cy + Math.sin(mid)*r*0.66);
    ctx.rotate(mid+Math.PI/2);
    ctx.fillStyle="#fff";
    ctx.font = `${Math.floor(size*0.04)}px sans-serif`;
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillText(pockets[i],0,0);
    ctx.restore();
  }

  ctx.beginPath();
  ctx.fillStyle="#111";
  ctx.arc(cx,cy,r*0.45,0,Math.PI*2);
  ctx.fill();

  return c;
}

const wheelTexture = new THREE.CanvasTexture(createWheelCanvas());
const wheelMesh = new THREE.Mesh(
  new THREE.CylinderGeometry(wheelRadius,wheelRadius,1.4,64),
  new THREE.MeshStandardMaterial({ map: wheelTexture })
);
wheelMesh.position.set(0,0.3,0);
wheelMesh.rotation.x = 2*Math.PI;
scene.add(wheelMesh);

// bola de ruleta
const ballMesh = new THREE.Mesh(
  new THREE.SphereGeometry(0.22,16,16),
  new THREE.MeshStandardMaterial({color:0xffffff})
);
ballMesh.position.set(0,1.2, wheelRadius - 0.8);
scene.add(ballMesh);

let spinning = false;
let wheelSpeed = 0;
let ballSpeed = 0;
let wheelAngle = 0;
let ballAngle = 0;

// ==================== RULETA â€” UI ====================
function openRouletteUI(){
  const html = `
    <label>Apuesta (nÃºmeros separados por coma):</label><br>
    <input type="text" id="rouletteInput" placeholder="0,7,14" style="width:90%"><br><br>
    <label>$ A apostar:</label><br>
    <input type="number" id="rouletteBet" value="10"><br><br>
    <button class="btn" onclick="spinRoulette()">Girar Ruleta</button>
  `;
  panelTitle.textContent='Ruleta';
  panelContent.innerHTML = html;
  panel.style.display = 'block';
}

function spinRoulette() {
    if (spinning) return;

    // --- LÃ³gica de Apuesta y ComprobaciÃ³n ---
    const nums = document.getElementById("rouletteInput").value
        .split(",")
        .map(n => parseInt(n.trim()))
        .filter(n => !isNaN(n));

    const bet = parseInt(document.getElementById("rouletteBet").value);

    if (balance < bet) {
        addLog("Ruleta: saldo insuficiente");
        return;
    }

    panel.style.display = "none";
    balance -= bet;
    updateHUD();

    spinning = true;

    // --- CÃLCULO DEL ÃNGULO DE PARADA OBJETIVO (MEJORADO) ---
    
    // Elegir nÃºmero ganador
    const chosen = pockets[Math.floor(Math.random() * pockets.length)];
    const pocketIndex = pockets.indexOf(chosen);
    
    // El punto de aterrizaje de la bola estÃ¡ en la posiciÃ³n frontal (Ã¡ngulo 0 o 2*PI).
    // Queremos que el centro de la casilla ganadora (pocketIndex) rote hasta allÃ­.
    // Esto requiere una rotaciÃ³n igual al Ã¡ngulo de la casilla.
    const requiredStopAngle = pocketIndex * anglePerPocket;

    // 1. NÃºmero de vueltas para un efecto visual realista (ej. 10 vueltas)
    const totalRevolutions = 10;
    
    // 2. Ãngulo base total de rotaciÃ³n (vueltas completas)
    const baseRotation = Math.PI * 2 * totalRevolutions;
    
    // 3. PequeÃ±a variaciÃ³n para que no siempre caiga en el centro exacto de la casilla
    const finalAlignmentOffset = (Math.random() - 0.5) * anglePerPocket * 0.8;

    // 4. Ãngulo final de la RUEDA: (Vueltas) - (Ãngulo para alinear la casilla) + (Offset visual)
    const finalWheelRotation = baseRotation - requiredStopAngle + finalAlignmentOffset;
    
    // --- VARIABLES DE ANIMACIÃ“N ---
    let wheelSpeed = 8;
    let ballSpeed = 30;
    let wheelAngle = 0; // Se inicializa a 0. Rastrea la rotaciÃ³n actual.
    let remainingRotation = finalWheelRotation; // Rastrea la distancia restante para el objetivo.
    let ballRadius = wheelRadius - 0.3; // La bola estÃ¡ en un radio alto al inicio.
    
    // PosiciÃ³n angular de la bola, se mueve independientemente de la rueda al inicio.
    let ballAngle = Math.random() * Math.PI * 2; 

    // --- INTERVALO DE GIRO ---
    const spinInterval = setInterval(() => {
        const dt = 0.016;

        // 1. CÃLCULO DE FRENADO (RUEDA)
        // La velocidad de la rueda es proporcional a la rotaciÃ³n restante (frenado suave)
        if (remainingRotation > 0) {
            const brakeFactor = remainingRotation / (Math.PI * 2 * totalRevolutions); // Normaliza (1.0 al inicio, 0 al final)
            wheelSpeed = Math.max(0, 8 * Math.sqrt(brakeFactor)); // La velocidad disminuye suavemente
        } else {
            wheelSpeed = 0; // Se ha detenido
        }

        // 2. GIRO DE RUEDA
        const rotationDelta = wheelSpeed * dt;
        if (remainingRotation > 0) {
            wheelAngle += rotationDelta;
            remainingRotation -= rotationDelta;

            if (remainingRotation < 0) {
                wheelAngle += remainingRotation; // Ajuste final si pasa el objetivo
                remainingRotation = 0;
            }
        }
        wheelMesh.rotation.y = wheelAngle;

        // 3. GIRO Y CAÃDA DE LA BOLA
        // La bola sigue girando y frenando independientemente
        ballSpeed *= 0.99; 
        ballAngle += ballSpeed * dt; 

        // La bola desciende (el radio se acerca al final) a medida que la rueda se acerca a detenerse
        if (remainingRotation < Math.PI * 2 * 3) { // Cuando le quedan 3 vueltas para detenerse
             // Interpolamos el radio entre 0.3 (inicio) y 1.5 (final)
             const fallProgress = 1 - (remainingRotation / (Math.PI * 2 * 3));
             ballRadius = THREE.MathUtils.lerp(wheelRadius - 0.3, 1.5, fallProgress);
        }
        
        ballMesh.position.x = Math.cos(ballAngle) * ballRadius;
        ballMesh.position.z = Math.sin(ballAngle) * ballRadius;
        // Ajustamos la altura de la bola para que parezca que cae en la base
        ballMesh.position.y = 1.2 * (ballRadius / (wheelRadius - 0.3)) + 0.3;


        // 4. DETECCIÃ“N DE PARADA
        if (remainingRotation <= 0) {
            clearInterval(spinInterval);
            spinning = false;

            // Fija la rotaciÃ³n de la RUEDA al Ã¡ngulo exacto de parada
            wheelMesh.rotation.y = finalWheelRotation;
            
            // Fija la BOLA en la posiciÃ³n de aterrizaje, que ahora debe coincidir con el nÃºmero ganador
            const finalBallRadius = 1.5; // El radio mÃ­nimo (donde se detiene)
            
            // La bola debe estar en la posiciÃ³n frontal de la rueda (Angulo 0 o 2*PI)
            // Ya que hemos garantizado que el nÃºmero ganador estÃ¡ bajo este punto.
            ballMesh.position.set(
                Math.cos(finalWheelRotation) * finalBallRadius, // Usamos la rotaciÃ³n final de la rueda para la posiciÃ³n X
                0.3 + 0.05, // La altura final
                Math.sin(finalWheelRotation) * finalBallRadius // Usamos la rotaciÃ³n final de la rueda para la posiciÃ³n Z
            );
            
            // Ya que la ruleta estÃ¡ en el centro, la posiciÃ³n de aterrizaje debe ser (0, Z=Radio_Final)
            ballMesh.position.set(0, 0.3 + 0.05, finalBallRadius);


            addLog(`Ruleta saliÃ³ ${chosen}`);

            if (nums.includes(chosen)) {
                const win = bet * 35;
                balance += win;
                addLog(`Ganaste $${win}!`);
            } else {
                 addLog(`Ruleta: Perdiste. El nÃºmero ganador fue ${chosen}.`);
            }

            updateHUD();
        }

    }, 16);
}


// ==================== BLACKJACK (igual que tu cÃ³digo) ====================
let bjPlayerCards=[], bjDealerCards=[], bjCurrentBet=0;
function resetBlackjack(){ bjPlayerCards=[]; bjDealerCards=[]; }
function getCard(){ 
  const suits=['â™ ','â™¥','â™¦','â™£'], ranks=['A','2','3','4','5','6','7','8','9','10','J','Q','K']; 
  return ranks[Math.floor(Math.random()*ranks.length)]+suits[Math.floor(Math.random()*suits.length)]; 
}
function handValue(cards){
  let sum=0, aces=0;
  for(const c of cards){
    const rank=c.slice(0,-1);
    if(rank==='A'){ sum+=11; aces++; }
    else if(['J','Q','K'].includes(rank)) sum+=10;
    else sum+=parseInt(rank);
  }
  while(sum>21 && aces>0){ sum-=10; aces--; }
  return sum;
}
function openBlackjackUI(){
  if(balance<10){ addLog('Necesitas al menos 10$ para apostar'); return; }
  bjCurrentBet = 10;
  balance -= bjCurrentBet; updateHUD();
  resetBlackjack();
  bjPlayerCards.push(getCard(), getCard());
  bjDealerCards.push(getCard(), getCard());
  renderBlackjackPanel();
  panel.style.display='block';
}
function renderBlackjackPanel(){
  let html = `Tus cartas: ${bjPlayerCards.map(c=>'<span class="card">'+c+'</span>').join(' ')} (Total: ${handValue(bjPlayerCards)})<br>`;
  html += `Dealer: <span class="card">${bjDealerCards[0]}</span> ??<br>`;
  html += `<button class="btn" onclick="hitBlackjack()">Pedir</button>`;
  html += `<button class="btn" onclick="standBlackjack()">Plantarse</button>`;
  html += `<button class="btn" onclick="doubleBlackjack()">Doblar</button>`;
  panelContent.innerHTML = html;
}
function hitBlackjack(){
  bjPlayerCards.push(getCard());
  const total = handValue(bjPlayerCards);
  if(total>21){ addLog(`Blackjack: Perdiste con ${total}`); panel.style.display='none'; } 
  else renderBlackjackPanel();
}
function standBlackjack(){
  let dealerTotal = handValue(bjDealerCards);
  while(dealerTotal<17){ bjDealerCards.push(getCard()); dealerTotal=handValue(bjDealerCards); }
  const playerTotal = handValue(bjPlayerCards);
  if(playerTotal>21){ addLog('Blackjack: Perdiste!'); }
  else if(dealerTotal>21 || playerTotal>dealerTotal){ balance+=bjCurrentBet*2; addLog('Blackjack: Ganaste!'); }
  else if(playerTotal===dealerTotal){ balance+=bjCurrentBet; addLog('Blackjack: Empate'); }
  else{ addLog('Blackjack: Perdiste!'); }
  updateHUD(); panel.style.display='none';
}
function doubleBlackjack(){
  if(balance<bjCurrentBet){ addLog('No tienes suficiente para doblar'); return; }
  balance -= bjCurrentBet; bjCurrentBet*=2; updateHUD();
  hitBlackjack();
  if(handValue(bjPlayerCards)<=21) standBlackjack();
}

// ==================== TRAGAPERRAS (igual que tu cÃ³digo) ====================
const symbols = ['ðŸ’','â­','7','ðŸ‹','ðŸ””','ðŸ‰'];
const reelCanvases=[], reelTexes=[];

for(let i=0;i<3;i++){
  const c=document.createElement('canvas'); 
  c.width=128; 
  c.height=192;
  const ctx=c.getContext('2d'); 
  ctx.fillStyle='#070707'; 
  ctx.fillRect(0,0,128,192);
  ctx.fillStyle='#fff'; 
  ctx.font='64px sans-serif'; 
  ctx.textAlign='center'; 
  ctx.textBaseline='middle';
  ctx.fillText(symbols[Math.floor(Math.random()*symbols.length)],64,96);

  reelCanvases.push(c); 
  reelTexes.push(new THREE.CanvasTexture(c));
}

const slotBody = new THREE.Mesh(
  new THREE.BoxGeometry(2,4,1.5),
  new THREE.MeshStandardMaterial({color:0x8a0f05})
);
slotBody.position.set(10,2,-5);
scene.add(slotBody);

function openSlotsUI(){
  const html = `
    <label>$ A apostar:</label><br>
    <input type="number" id="slotBet" value="10"><br><br>
    <button class="btn" onclick="spinSlots()">Girar</button>
  `;
  panelTitle.textContent='Tragaperras'; 
  panelContent.innerHTML=html; 
  panel.style.display='block';
}

function spinSlots(){
  const amt = parseInt(document.getElementById('slotBet').value);
  if(balance<amt){ addLog('No tienes suficiente saldo'); return; }
  balance-=amt; 
  updateHUD(); 
  panel.style.display='none';

  const results = [];
  for(let i=0;i<3;i++){
    const sym = symbols[Math.floor(Math.random()*symbols.length)];
    const ctx = reelCanvases[i].getContext('2d');
    ctx.fillStyle='#070707';
    ctx.fillRect(0,0,128,192);
    ctx.fillStyle='#fff';
    ctx.font='64px sans-serif';
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.fillText(sym,64,96);
    reelTexes[i].needsUpdate = true;
    results.push(sym);
  }

  const counts={};
  results.forEach(s=>counts[s]=(counts[s]||0)+1);

  let win=0;
  if(Object.values(counts).includes(3)) win=amt*5;
  else if(Object.values(counts).includes(2)) win=amt*2;

  if(win>0){ 
    balance+=win; 
    addLog(`Tragaperras: ganaste $${win}!`); 
  } else addLog('Tragaperras: perdiste');

  updateHUD();
}

// ==================== ZONAS DE INTERACCIÃ“N ====================
const zones=[
  {x:0,z:0,label:'Ruleta',action:openRouletteUI},
  {x:-10,z:-5,label:'Blackjack',action:openBlackjackUI},
  {x:10,z:-5,label:'Tragaperras',action:openSlotsUI}
];

let currentZone = null;
function detectZones(){
  currentZone = null;
  for(const z of zones){
    const dx = playerPos.x - z.x, dz = playerPos.z - z.z;
    if(Math.sqrt(dx*dx+dz*dz) < 3){
      currentZone = z;
      prompt.style.display = 'block';
      prompt.textContent = '[E] ' + z.label;
      return;
    }
  }
  prompt.style.display='none';
}

// ==================== MOVIMIENTO ====================
const keys={w:false,a:false,s:false,d:false,ArrowLeft:false,ArrowRight:false,ArrowUp:false,ArrowDown:false};
window.addEventListener("keydown",e=>{ if(e.key in keys) keys[e.key]=true; });
window.addEventListener("keyup",e=>{ if(e.key in keys) keys[e.key]=false; });

const speed=5;

function computeDelta(dt){
  const rotSpeed=1.5*dt;

  if(keys.ArrowLeft) yaw+=rotSpeed; 
  if(keys.ArrowRight) yaw-=rotSpeed;
  if(keys.ArrowUp) pitch+=rotSpeed*0.5; 
  if(keys.ArrowDown) pitch-=rotSpeed*0.5;

  pitch=Math.max(-1.2,Math.min(1.2,pitch));

  const e=new THREE.Euler(pitch,yaw,0,'YXZ');
  const q=new THREE.Quaternion().setFromEuler(e);

  const forward=new THREE.Vector3(0,0,-1).applyQuaternion(q);
  forward.y=0; forward.normalize();

  const right=new THREE.Vector3(1,0,0).applyQuaternion(q);
  right.y=0; right.normalize();

  let mf=0,mr=0;
  if(keys.w) mf+=1;
  if(keys.s) mf-=1;
  if(keys.a) mr-=1;
  if(keys.d) mr+=1;

  const len=Math.hypot(mf,mr);
  if(len>0){ mf/=len; mr/=len; }

  const delta=new THREE.Vector3();
  delta.addScaledVector(forward,mf*speed*dt);
  delta.addScaledVector(right,mr*speed*dt);
  return delta;
}

// ==================== PANEL ====================
document.addEventListener("keydown",(e)=>{
  if(e.key.toLowerCase()==='e' && currentZone) currentZone.action();
  if(e.key==='Escape') panel.style.display='none';
});

function closePanel(){ panel.style.display='none'; }

// ==================== ANIMACIÃ“N ====================
let lastTime=0;

function animate(ts){
  requestAnimationFrame(animate);

  const dt=(ts-lastTime)*0.001; 
  lastTime=ts;

  detectZones();

  const delta=computeDelta(dt);
  playerPos.add(delta);

  camera.position.copy(playerPos);
  camera.position.y=1.7;
  camera.rotation.set(pitch,yaw,0,'YXZ');

  if(spinning){
    wheelAngle += wheelSpeed * dt;
    ballAngle  += ballSpeed  * dt;

    wheelMesh.rotation.y = wheelAngle;
    ballMesh.position.x = Math.cos(ballAngle) * (wheelRadius - 0.3);
    ballMesh.position.z = Math.sin(ballAngle) * (wheelRadius - 0.3);
  }

  renderer.render(scene,camera);
}
requestAnimationFrame(animate);

// ==================== RESIZE ====================
window.addEventListener("resize",()=>{
  camera.aspect = wrap.clientWidth / wrap.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(wrap.clientWidth, wrap.clientHeight);
});
</script>
</body>
</html>
