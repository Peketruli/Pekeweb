<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Casino 3D ‚Äî Ruleta corregida (WASD, FPS)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#030612;color:#fff;font-family:Inter,Arial,Helvetica}
  #wrap{position:relative;height:100vh;overflow:hidden}
  canvas{display:block}
  .hud{position:absolute;right:12px;top:12px;z-index:40;max-width:380px}
  .panel{background:rgba(0,0,0,0.56);padding:10px;border-radius:10px;margin-bottom:10px}
  .info-row{display:flex;justify-content:space-between;align-items:center;margin:6px 0;font-size:13px}
  #prompt{position:absolute;left:50%;transform:translateX(-50%);bottom:92px;background:rgba(0,0,0,0.7);padding:8px 12px;border-radius:8px;display:none;z-index:45}
  #overlay{position:absolute;left:0;top:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;z-index:60}
  #overlay .ui{background:rgba(8,10,12,0.96);padding:14px;border-radius:10px;width:420px;box-shadow:0 10px 40px rgba(0,0,0,0.7);color:#ddd}
  .btn{background:#d95d00;color:white;padding:8px 10px;border-radius:8px;border:none;cursor:pointer}
  footer{position:absolute;left:12px;bottom:12px;color:#bbb;font-size:13px}
  #minimap{position:absolute;left:12px;top:12px;width:120px;height:120px;background:rgba(255,255,255,0.02);border-radius:8px;z-index:30}
</style>
</head>
<body>
  <div id="wrap">
    <div id="minimap"></div>

    <div class="hud">
      <div class="panel">
        <h3>Casino ‚Äî Ruleta corregida</h3>
        <div class="info-row"><span>Saldo</span><strong id="balance">1000</strong></div>
        <div class="info-row"><span>Apuesta</span><strong id="bet">0</strong></div>
        <div style="font-size:13px;margin-top:6px">
          Controles: <strong>W A S D</strong> moverse ¬∑ <strong>Flechas</strong> girar c√°mara ¬∑ <strong>E</strong> interactuar
        </div>
      </div>
      <div class="panel">
        <h4>Interact√∫a</h4>
        <div id="interact-info" style="font-size:13px">Ac√©rcate y pulsa <strong>E</strong> (o usa UI).</div>
      </div>
      <div class="panel">
        <h4>Historial</h4>
        <div id="log" style="max-height:120px;overflow:auto;font-size:12px;background:rgba(255,255,255,0.02);padding:6px;border-radius:6px"></div>
      </div>
    </div>

    <div id="prompt">[E] Interactuar</div>
    <div id="overlay"><div class="ui" id="ui-box"></div></div>

    <footer>Primera persona ¬∑ Ruleta europea (0‚Äì36) ¬∑ Tragaperras</footer>
  </div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>

  <script>
  (function(){
    // ---------- Setup ----------
    const wrap = document.getElementById('wrap');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x041018);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(wrap.clientWidth, wrap.clientHeight);
    wrap.appendChild(renderer.domElement);

    // Camera = player (FPS)
    const camera = new THREE.PerspectiveCamera(72, wrap.clientWidth / wrap.clientHeight, 0.1, 1000);
    camera.position.set(0, 1.7, 12);
    const playerPos = new THREE.Vector3(0,0,12);
    let yaw = 0, pitch = 0;

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff,0.35));
    const dir = new THREE.DirectionalLight(0xffffff,0.9); dir.position.set(8,20,10); scene.add(dir);
    const bulb = new THREE.PointLight(0xfff3d6,0.9,200); bulb.position.set(0,20,0); scene.add(bulb);

    // Floor & room
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(90,90), new THREE.MeshStandardMaterial({color:0x091217,roughness:0.95}));
    floor.rotation.x = -Math.PI/2; floor.position.y = 0; scene.add(floor);
    function wall(w,h,d,x,y,z,rotY){ const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({color:0x071018})); m.position.set(x,y,z); if(rotY) m.rotation.y = rotY; scene.add(m); return m; }
    wall(50,10,2,0,5,-40); wall(2,10,50,-24,5,0); wall(2,10,50,24,5,0); wall(50,10,2,0,5,40);
    const rug = new THREE.Mesh(new THREE.CircleGeometry(14,32), new THREE.MeshStandardMaterial({color:0x183430}));
    rug.rotation.x = -Math.PI/2; rug.position.y = 0.01; scene.add(rug);

   // ---------- TABLE + RUEDA ----------
const table = new THREE.Group();
table.position.set(0,0,0);

// table top slightly lower so the wheel is visible above it
const tableTop = new THREE.Mesh(
  new THREE.CylinderGeometry(8.5,8.5,0.9,36),
  new THREE.MeshStandardMaterial({color:0x214f3d})
);
tableTop.position.y = -3;
table.add(tableTop);

const pedestal = new THREE.Mesh(
  new THREE.CylinderGeometry(2.2,2.2,1.2,12),
  new THREE.MeshStandardMaterial({color:0x163826})
);
pedestal.position.y = 0;
table.add(pedestal);

// wheel geometry and texture
const wheelRadius = 6;
const pockets = [0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23,10,5,24,16,33,1,20,14,31,9,22,18,29,7,28,12,35,3,26];
const pocketCount = pockets.length;
const anglePerPocket = (Math.PI*2) / pocketCount;

function createWheelCanvas(size=2048){
  const c = document.createElement('canvas'); c.width = c.height = size;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#072b22'; ctx.fillRect(0,0,size,size);
  const cx = size/2, cy = size/2, r = size*0.45;
  for(let i=0;i<pocketCount;i++){
    const a0 = i*anglePerPocket - Math.PI/2;
    const a1 = (i+1)*anglePerPocket - Math.PI/2;
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,r,a0,a1); ctx.closePath();
    ctx.fillStyle = (pockets[i]===0)?'#1b8b41':((i%2===0)?'#b71c1c':'#000');
    ctx.fill();
    const mid = a0 + (a1-a0)/2;
    ctx.save(); ctx.translate(cx+Math.cos(mid)*(r*0.66), cy+Math.sin(mid)*(r*0.66));
    ctx.rotate(mid+Math.PI/2); ctx.fillStyle='#fff'; ctx.font=`${Math.floor(size*0.04)}px sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(pockets[i],0,0); ctx.restore();
  }
  ctx.beginPath(); ctx.fillStyle='#111'; ctx.arc(cx,cy,r*0.45,0,Math.PI*2); ctx.fill();
  return c;
}

const wheelTex = new THREE.CanvasTexture(createWheelCanvas(2048));
wheelTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
const wheelMesh = new THREE.Mesh(
  new THREE.CylinderGeometry(wheelRadius,wheelRadius,1.4,128),
  new THREE.MeshStandardMaterial({map:wheelTex})
);
wheelMesh.position.y = 0.1;
table.add(wheelMesh);

// rim
const rim = new THREE.Mesh(
  new THREE.TorusGeometry(wheelRadius+0.6,0.45,12,50),
  new THREE.MeshStandardMaterial({color:0x6b3b1b})
);
rim.rotation.x = Math.PI/2;
rim.position.y = 0.3;
table.add(rim);

// ---------- FIX: add table (with ruleta) to scene ----------
scene.add(table);

// ---------- BALL ----------
const ball = new THREE.Mesh(
  new THREE.SphereGeometry(0.20,16,16),
  new THREE.MeshStandardMaterial({color:0xffffff, metalness:0.8, roughness:0.2})
);
ball.position.set(wheelRadius-0.6,0.55,0);
scene.add(ball);

    // ---------- Chairs ----------
    function makeChair(x,z){
      const g=new THREE.Group();
      const seat=new THREE.Mesh(new THREE.BoxGeometry(1.1,0.35,1.1), new THREE.MeshStandardMaterial({color:0x6b3b1b}));
      const back=new THREE.Mesh(new THREE.BoxGeometry(1.1,1.0,0.28), new THREE.MeshStandardMaterial({color:0x6b3b1b}));
      seat.position.y=0.42; back.position.set(0,0.9,-0.45);
      g.add(seat); g.add(back); g.position.set(x,0,z); g.lookAt(0,0,0); scene.add(g);
    }
    for(let i=0;i<6;i++){ const a=(i/6)*Math.PI*2; makeChair(Math.cos(a)*10, Math.sin(a)*10); }

    // ---------- Slot machine (kept simple) ----------
    const slotGroup = new THREE.Group(); slotGroup.position.set(14,0,-6);
    const slotBody = new THREE.Mesh(new THREE.BoxGeometry(2.6, 4.2, 1.6)), new THREE.MeshStandardMaterial({color:0x8a0f05,metalness:0.12,roughness:0.36}));
    slotBody.position.y=4.2; slotGroup.add(slotBody);
    const panel = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.55, 0.55), new THREE.MeshStandardMaterial({color:0x050506}));
    panel.position.set(14, 3.1, -5.3); scene.add(panel);
    // reels (canvas textures)
    const reelCanvases = []; const reelTexes = []; const reelPlanes = [];
    const symbols = ['üçí','‚≠ê','7','üçã','üîî','üçâ'];
    for(let i=0;i<3;i++){
      const c=document.createElement('canvas'); c.width=128; c.height=192;
      const ctx=c.getContext('2d'); ctx.fillStyle='#070707'; ctx.fillRect(0,0,c.width,c.height);
      ctx.fillStyle='#fff'; ctx.font='64px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(symbols[Math.floor(Math.random()*symbols.length)], c.width/2, c.height/2);
      reelCanvases.push(c);
      const t=new THREE.CanvasTexture(c); reelTexes.push(t);
      const p=new THREE.Mesh(new THREE.PlaneGeometry(0.55, 0.9), new THREE.MeshBasicMaterial({map:t}));
      p.position.set(14 + (i-1)*0.55, 3.1, -5.2); scene.add(p); reelPlanes.push(p);
    }
    const lever = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.3, 8), new THREE.MeshStandardMaterial({color:0x8b5a2b}));
    lever.position.set(15.5, 3, -6); lever.rotation.z=Math.PI/8; scene.add(lever);
    scene.add(slotGroup);

    // ---------- Colliders (NO MESH, Box3-only) ----------
    // Use Box3 instances for collisions, don't add any visible mesh to scene
    const colliders = [];
    // table collider - positioned slightly under table top, low height so it doesn't block view
    const tableColliderBox = new THREE.Box3(new THREE.Vector3(30, 0, 4), new THREE.Vector3(-4, 0, -4));
    colliders.push(tableColliderBox);
    // slot collider
    const slotColliderBox = new THREE.Box3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0));
    colliders.push(slotColliderBox);

    // ---------- Interaction zones ----------
    const ruletaZone = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(0,0,0), new THREE.Vector3(22,3,12));
    const slotZone = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(14,3.5,-6), new THREE.Vector3(14,6,6));

    // ---------- Movement & Camera control ----------
    const keys = {w:false,a:false,s:false,d:false,ArrowLeft:false,ArrowRight:false,ArrowUp:false,ArrowDown:false};
    const speed = 5.6;
    window.addEventListener('keydown', (e)=>{ const k=e.key; if(k in keys) keys[k]=true; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(k)) e.preventDefault(); });
    window.addEventListener('keyup', (e)=>{ const k=e.key; if(k in keys) keys[k]=false; });

    function computeDelta(dt){
      const e = new THREE.Euler(pitch, yaw, 0, 'YXZ');
      const q = new THREE.Quaternion().setFromEuler(e);
      const forward = new THREE.Vector3(0,0,-1).applyQuaternion(q); forward.y = 0; forward.normalize();
      const right = new THREE.Vector3(1,0,0).applyQuaternion(q); right.y = 0; right.normalize();
      let mf=0, mr=0; if(keys.w) mf += 1; if(keys.s) mf -= 1; if(keys.a) mr -= 1; if(keys.d) mr += 1;
      const len = Math.hypot(mf,mr); if(len>0){ mf/=len; mr/=len; }
      const delta = new THREE.Vector3();
      delta.addScaledVector(forward, mf * speed * dt);
      delta.addScaledVector(right, mr * speed * dt);
      return delta;
    }

    function checkCollision(pos){
      // pos is Vector3 (player feet). We'll check against Box3 colliders.
      const r = 0.45;
      for(const b of colliders){
        // expand the box by r and test
        const expanded = b.clone().expandByScalar(r);
        if(expanded.containsPoint(pos)) return true;
      }
      if(Math.abs(pos.x) > 28 || Math.abs(pos.z) > 28) return true;
      return false;
    }

    // ---------- HUD / state ----------
    const balanceEl = document.getElementById('balance'), betEl = document.getElementById('bet'), logEl = document.getElementById('log');
    let balance = 1000, currentBet = 0;
    function updateHUD(){ balanceEl.textContent = balance.toFixed(0); betEl.textContent = currentBet.toFixed(0); }
    function appendLog(t){ const d=new Date(); const el=document.createElement('div'); el.textContent = `[${d.toLocaleTimeString()}] ${t}`; logEl.prepend(el); }

    // ---------- Zone detection & UI ----------
    const prompt = document.getElementById('prompt'); let nearZone = null;
    function detectZones(){
      const eye = playerPos.clone(); eye.y = camera.position.clone();
      if(ruletaZone.containsPoint(eye)){ nearZone='ruleta'; prompt.style.display='block'; prompt.textContent='[E] Interactuar: Ruleta'; return; }
      if(slotZone.containsPoint(eye)){ nearZone='slot'; prompt.style.display='block'; prompt.textContent='[E] Interactuar: Tragaperras'; return; }
      nearZone=null; prompt.style.display='none';
    }

    const overlay = document.getElementById('overlay'), uiBox = document.getElementById('ui-box'); let activeUI=null;
    const ruletaState = {
      bets: [],
      spinning: false,
      wheelVel: 0,
      ballVel: 0,
      ballAngle: Math.random()*Math.PI*2,
      // We'll compute winner at finalize phase based on current rotation & ballAngle
    };
    const slotState = {credits:0};

    function openRuletaUI(){
      activeUI='ruleta'; overlay.style.display='flex';
      uiBox.innerHTML = `<h3 style="margin:0 0 8px 0;color:#fff">Ruleta</h3>
        <div style="margin-bottom:8px;color:#ddd">Saldo: <strong id="ui-balance">${balance}</strong></div>
        <div style="margin-bottom:8px;color:#ddd">√çndice (0-36): <input id="ui-num" type="number" min="0" max="36" value="0" style="width:80px"/> Monto: <input id="ui-amt" type="number" min="1" value="5" style="width:100px"/></div>
        <div style="text-align:right"><button class="btn" id="ui-place">Colocar</button> <button class="btn" id="ui-spin">Girar</button> <button class="btn" id="ui-close">Cerrar</button></div>`;
      document.getElementById('ui-place').addEventListener('click', ()=>{
        const idx = parseInt(document.getElementById('ui-num').value||0);
        const amt = parseInt(document.getElementById('ui-amt').value||1);
        if(isNaN(idx) || idx<0 || idx>36) return alert('√çndice inv√°lido (0-36)');
        if(amt<=0 || amt>balance) return alert('Monto inv√°lido o saldo insuficiente');
        balance -= amt; currentBet += amt; ruletaState.bets.push({idx, amt}); updateHUD(); appendLog(`Apuesta ${amt} √≠ndice ${idx} (ruleta)`); document.getElementById('ui-balance').textContent = balance;
      });
      document.getElementById('ui-spin').addEventListener('click', ()=>{ if(ruletaState.spinning) return alert('Ya girando'); if(ruletaState.bets.length===0) return alert('Sin apuestas'); startRuletaSpin(); closeUI(); });
      document.getElementById('ui-close').addEventListener('click', closeUI);
    }

    function openSlotUI(){
      activeUI='slot'; overlay.style.display='flex';
      uiBox.innerHTML = `<h3 style="margin:0 0 8px 0;color:#fff">Tragaperras</h3>
        <div style="margin-bottom:8px;color:#ddd">Saldo: <strong id="ui-balance2">${balance}</strong></div>
        <div style="margin-bottom:8px;color:#ddd">Cr√©ditos: <strong id="ui-credits">${slotState.credits}</strong></div>
        <div style="text-align:right"><button class="btn" id="ui-insert">Insertar (1)</button> <button class="btn" id="ui-play">Jugar</button> <button class="btn" id="ui-close2">Cerrar</button></div>`;
      document.getElementById('ui-insert').addEventListener('click', ()=>{ if(balance<1) return alert('Saldo insuficiente'); balance-=1; slotState.credits+=1; updateHUD(); appendLog('Ficha insertada (slot)'); document.getElementById('ui-balance2').textContent=balance; document.getElementById('ui-credits').textContent=slotState.credits; });
      document.getElementById('ui-play').addEventListener('click', ()=>{ if(slotState.credits<=0) return alert('Inserta fichas'); spinSlot(); closeUI(); });
      document.getElementById('ui-close2').addEventListener('click', closeUI);
    }

    function closeUI(){ activeUI=null; overlay.style.display='none'; uiBox.innerHTML=''; }
    window.addEventListener('keydown', (e)=>{ if((e.key==='e' || e.key==='E') && !activeUI){ if(nearZone==='ruleta') openRuletaUI(); else if(nearZone==='slot') openSlotUI(); } if(e.key==='Escape' && activeUI) closeUI(); });

    // ---------- Ruleta spin logic (improved) ----------
    function startRuletaSpin(){
      // start rotating both wheel and ball; we will determine winner by final geometry
      ruletaState.spinning = true;
      ruletaState.wheelVel = 6 + Math.random()*5; // initial wheel angular speed
      ruletaState.ballVel = 14 + Math.random()*8;  // initial ball angular speed
      // ballAngle already present; leave it as world angle and animate its decay
      appendLog('Ruleta: girando...');
    }

    function finalizeRuleta(){
      // Compute winner using current wheel rotation and ball world angle:
      // localAngle = (ballAngle - wheelRotation) mod 2œÄ
      const totalRot = wheelMesh.rotation.y; // wheel rotation in radians
      let localAngle = (ruletaState.ballAngle - totalRot) % (Math.PI*2);
      if(localAngle < 0) localAngle += Math.PI*2;
      // shift so sector 0 starts at -PI/2 like our canvas mapping
      // our wheel drawing used offset: each pocket i placed at angle = i*anglePerPocket - PI/2
      // So to find index: we align localAngle + PI/2 to [0,2PI)
      let norm = localAngle + Math.PI/2;
      norm = norm % (Math.PI*2);
      // Sector donde ha ca√≠do la bola
      const idx = Math.floor(norm / anglePerPocket) % pocketCount;

      // N√∫mero real seg√∫n la ruleta europea
      const resultNumber = pockets[idx];

      appendLog(`Ruleta resultado: ${resultNumber}`);

      // payouts: bets stored as index on pockets[] (we used the index scheme in UI)
      let payout = 0;
      ruletaState.bets.forEach(b => {
      if(b.idx === resultNumber) payout += b.amt * 36;
      });
      if(payout > 0){ balance += payout; appendLog(`Has ganado ${payout} en la ruleta!`); } else appendLog('Sin premio en la ruleta.');
      ruletaState.bets = []; currentBet = 0; updateHUD();
      ruletaState.spinning = false;
      // ensure ball visually sits on the winning sector
      // compute absolute world angle where the winning sector is located:
      const winningSectorAngle = idx * anglePerPocket - Math.PI/2; // this is angle in wheel-local coords
      // world space position = rotate by wheel rotation + winningSectorAngle
      const worldAngle = totalRot + winningSectorAngle;
      const r = wheelRadius - 0.6;
      ball.position.set(Math.cos(worldAngle) * r, 0.45, Math.sin(worldAngle) * r);
      // small visual settle
      wheelMesh.rotation.y = totalRot; // snap to current
      rim.rotation.x = Math.PI/2;
    }

    // ---------- Slot (unchanged logic) ----------
    function randSym(){ return symbols[Math.floor(Math.random()*symbols.length)]; }
    function spinSlot(){
      slotState.credits -= 1;
      const start = lever.rotation.z; lever.rotation.z = start + 0.6;
      setTimeout(()=> lever.rotation.z = start, 280);
      const res = [randSym(), randSym(), randSym()];
      appendLog(`Tragaperras: ${res.join(' | ')}`);
      for(let i=0;i<3;i++){
        const c=reelCanvases[i]; const ctx=c.getContext('2d'); ctx.fillStyle='#070707'; ctx.fillRect(0,0,c.width,c.height); ctx.fillStyle='#fff'; ctx.font='64px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(res[i], c.width/2, c.height/2);
        reelTexes[i].needsUpdate = true;
      }
      let payout=0;
      if(res[0]===res[1] && res[1]===res[2]) payout=50;
      else if(res[0]===res[1] || res[1]===res[2] || res[0]===res[2]) payout=5;
      if(payout>0){ balance += payout; appendLog(`Tragaperras: ganas ${payout}`); updateHUD(); } else appendLog('Tragaperras: sin premio');
    }

    // ---------- Minimap ----------
    const minimap = document.getElementById('minimap');
    const mmC = document.createElement('canvas'); mmC.width = mmC.height = 120; minimap.appendChild(mmC);
    const mm = mmC.getContext('2d');
    function drawMinimap(){ mm.fillStyle='#041018'; mm.fillRect(0,0,120,120); const scale=2; const px=60 + playerPos.x/scale, pz=60 + playerPos.z/scale; mm.fillStyle='#1d7cf0'; mm.beginPath(); mm.arc(px,pz,4,0,Math.PI*2); mm.fill(); mm.fillStyle='#a2d9c8'; mm.fillRect(60-6,60-6,12,12); mm.fillStyle='#f0c050'; mm.fillRect(60 + 14/scale -4, 60 + (-6)/scale -6,8,12); }

    // ---------- Animation loop ----------
    const clock = new THREE.Clock();
    (function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      // camera rotation with arrows
      if(keys.ArrowLeft) yaw += 1.8 * dt;
      if(keys.ArrowRight) yaw -= 1.8 * dt;
      if(keys.ArrowUp) pitch = Math.max(-Math.PI/6, pitch + 1.2 * dt);
      if(keys.ArrowDown) pitch = Math.min(Math.PI/6, pitch - 1.2 * dt);

      // movement (W forward, S back) computed from camera quaternion
      const delta = computeDelta(dt);
      const newPos = playerPos.clone().add(delta);
      if(!checkCollision(newPos)) playerPos.copy(newPos);

      // update camera pose
      camera.position.set(playerPos.x, playerPos.y + 1.7, playerPos.z);
      const euler = new THREE.Euler(pitch, yaw, 0, 'YXZ');
      camera.quaternion.setFromEuler(euler);

      // detect zones
      detectZones();

      // RUETA animation: update wheel rotation & ball angle; when velocities low, finalize
      if(ruletaState.spinning){
        // integrate rotation
        wheelMesh.rotation.y += ruletaState.wheelVel * dt;
        // slow down wheel
        ruletaState.wheelVel *= Math.max(0.995, 1 - 0.35 * dt);
        // ball moves opposite relative to wheel (ballAngle is world angle)
        ruletaState.ballAngle += ruletaState.ballVel * dt;
        ruletaState.ballVel *= Math.max(0.99, 1 - 0.6 * dt);

        // update ball world position (orbit)
        const r = wheelRadius - 0.6;
        const bx = Math.cos(ruletaState.ballAngle) * r;
        const bz = Math.sin(ruletaState.ballAngle) * r;
        ball.position.set(bx, 0.45, bz);

        // When both are slow enough, compute final index
        if(Math.abs(ruletaState.wheelVel) < 0.02 && Math.abs(ruletaState.ballVel) < 0.06){
          // small timeout to simulate ball bouncing, then finalize
          setTimeout(finalizeRuleta, 700);
        }
      } else {
        // idle subtle spin
        wheelMesh.rotation.y += Math.sin(clock.elapsedTime*0.5)*0.0004;
      }

      // render
      drawMinimap();
      renderer.render(scene, camera);
    })();

    // ---------- Resize ----------
    window.addEventListener('resize', ()=>{ renderer.setSize(wrap.clientWidth, wrap.clientHeight); camera.aspect = wrap.clientWidth / wrap.clientHeight; camera.updateProjectionMatrix(); });

    // ---------- HUD init ----------
    updateHUD(); appendLog('Ruleta corregida: √≠ndices 0‚Äì36 disponibles. Pulsa E cerca de la ruleta o tragaperras.');

    // debug reposition
    window.addEventListener('keydown', (e)=> { if(e.key==='r' || e.key==='R'){ playerPos.set(0,0,12); updateHUD(); appendLog('Player reposicionado'); } });

    // expose for debug
    window.__casino = { playerPos, camera, scene, pockets };

  })();
  </script>
</body>
</html>
