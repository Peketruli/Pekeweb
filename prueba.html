<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Casino — Pasillo y Sala (puerta con bisagras + sonido)</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;background:#111;font-family:Inter,Arial,Helvetica,sans-serif}
  canvas{display:block;width:100vw;height:100vh}
  /* HUD prompt centrado */
  #prompt {
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -120%);
    background: rgba(0,0,0,0.72);
    color: #fff;
    padding: 10px 16px;
    border-radius: 8px;
    font-size: 18px;
    pointer-events: none;
    display: none;
    z-index: 20;
    box-shadow: 0 4px 18px rgba(0,0,0,0.6);
  }
  #hint {
    position: fixed;
    right: 12px;
    top: 12px;
    color: #fff;
    z-index: 10;
    background: rgba(0,0,0,0.45);
    padding: 8px;
    border-radius: 6px;
    font-size: 13px;
  }
</style>
</head>
<body>
<div id="prompt">Presiona <b>E</b> para abrir</div>
<div id="hint">W/S mover • A/D girar • Shift correr • Espacio saltar • Acércate a la puerta</div>
<canvas id="c"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script>
/* ---------------------------
   Setup básico: renderer/scene
   --------------------------- */
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xebe6dc); // tono general suave

/* ---------------------------
   Cámara: altura ~1.7 m
   --------------------------- */
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 400);
camera.position.set(0, 1.7, 2.2); // spawn cerca del inicio del pasillo, mirando -Z
scene.add(camera);

/* ---------------------------
   Materiales "seguros" (MeshBasic)
   --------------------------- */
const wallMat = new THREE.MeshBasicMaterial({ color: 0xD3C6B2 }); // beige suave
const floorMat = new THREE.MeshBasicMaterial({ color: 0x7a7a7a }); // suelo pasillo gris
const ceilingMat = new THREE.MeshBasicMaterial({ color: 0x3b3b3b });
const doorMat = new THREE.MeshBasicMaterial({ color: 0x3f2a18 }); // marrón oscuro
const frameMat = new THREE.MeshBasicMaterial({ color: 0x2e1d12 });
const roomFloorMat = new THREE.MeshBasicMaterial({ color: 0x5a0b0b }); // moqueta burdeos
const lampMat = new THREE.MeshBasicMaterial({ color: 0xffe6c6 });

/* ---------------------------
   Parámetros del pasillo
   --------------------------- */
const L = 4.5;   // longitud aprox 4-5 m
const W = 2.0;   // anchura normal
const H = 2.8;   // altura

/* Suelo del pasillo */
const floorGeo = new THREE.PlaneGeometry(W + 2, L + 2);
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI/2;
floor.position.set(0, 0, - (L/2) + 1);
scene.add(floor);

/* Paredes laterales */
const wallThickness = 0.12;
const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, H, L + 0.2), wallMat);
leftWall.position.set(-W/2 - wallThickness/2, H/2, -L/2);
scene.add(leftWall);
const rightWall = leftWall.clone();
rightWall.position.set(W/2 + wallThickness/2, H/2, -L/2);
scene.add(rightWall);

/* Pared posterior (spawn) */
const backWall = new THREE.Mesh(new THREE.BoxGeometry(W + 0.4, H, wallThickness), wallMat);
backWall.position.set(0, H/2, 1.02);
scene.add(backWall);

/* Techo */
const ceiling = new THREE.Mesh(new THREE.BoxGeometry(W + 0.4, wallThickness, L + 0.2), ceilingMat);
ceiling.position.set(0, H - wallThickness/2, -L/2);
scene.add(ceiling);

/* Lámparas visuales en pared */
const lampL = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.02), lampMat);
lampL.position.set(-W/2 + 0.14, H - 0.6, -L/2 + 0.6);
scene.add(lampL);
const lampR = lampL.clone(); lampR.position.set(W/2 - 0.14, H - 0.6, -L/2 + 0.6); scene.add(lampR);

/* Decor simples */
const decoMat = new THREE.MeshBasicMaterial({ color: 0x9a9a9a });
const deco1 = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.6, 0.28), decoMat);
deco1.position.set(-0.64, 0.3, -1.6);
scene.add(deco1);
const deco2 = deco1.clone(); deco2.position.set(0.64, 0.3, -3.1); scene.add(deco2);

/* ---------------------------
   Puerta con bisagra (lado izquierdo)
   --------------------------- */
const doorW = 1.0, doorH = 2.0, doorD = 0.12;
const hingeX = -doorW/2;
const hingeZ = -L - 0.02;
const hingeY = doorH/2;

// pivot para bisagra
const doorPivot = new THREE.Object3D();
doorPivot.position.set(hingeX, hingeY, hingeZ);
scene.add(doorPivot);

// puerta (offset respecto pivot)
const doorMesh = new THREE.Mesh(new THREE.BoxGeometry(doorW, doorH, doorD), doorMat);
doorMesh.position.set(doorW/2, 0, 0); // de modo que el borde izquierdo quede en x=0 del pivot
doorPivot.add(doorMesh);

// marco
const frameLeft = new THREE.Mesh(new THREE.BoxGeometry(0.12, doorH + 0.12, 0.2), frameMat);
frameLeft.position.set(hingeX - 0.06, hingeY, hingeZ - 0.06);
scene.add(frameLeft);
const frameRight = new THREE.Mesh(new THREE.BoxGeometry(0.12, doorH + 0.12, 0.2), frameMat);
frameRight.position.set(hingeX + doorW + 0.06, hingeY, hingeZ - 0.06);
scene.add(frameRight);
const frameTop = new THREE.Mesh(new THREE.BoxGeometry(doorW + 0.24, 0.12, 0.2), frameMat);
frameTop.position.set(hingeX + doorW/2, doorH + 0.06, hingeZ - 0.06);
scene.add(frameTop);

/* ---------------------------
   Sala del casino (vacía por ahora)
   --------------------------- */
const roomW = 12, roomL = 10, roomH = 3.2;
const roomFloor = new THREE.Mesh(new THREE.PlaneGeometry(roomW, roomL), roomFloorMat);
roomFloor.rotation.x = -Math.PI/2;
roomFloor.position.set(0, 0, -L - roomL/2 - 0.2);
scene.add(roomFloor);
/* algunas paredes visibles (sólo para referencia) */
const roomWallMat = new THREE.MeshBasicMaterial({ color: 0xCFC0B0 });
const roomBack = new THREE.Mesh(new THREE.BoxGeometry(roomW, roomH, 0.2), roomWallMat);
roomBack.position.set(0, roomH/2, -L - roomL + 0.1 - 0.2);
scene.add(roomBack);
const roomLeft = new THREE.Mesh(new THREE.BoxGeometry(0.2, roomH, roomL), roomWallMat);
roomLeft.position.set(-roomW/2 + 0.1, roomH/2, -L - roomL/2 - 0.2);
scene.add(roomLeft);
const roomRight = roomLeft.clone(); roomRight.position.set(roomW/2 - 0.1, roomH/2, -L - roomL/2 - 0.2);
scene.add(roomRight);

/* ---------------------------
   Estados y animación de puerta
   --------------------------- */
let doorState = 'closed'; // closed, opening, open, closing
const openAngle = -Math.PI*0.45; // aprox -81° *0.56; ajustado suave
const closedAngle = 0;
let animT = 0;
const animDur = 0.7; // segs
let autoCloseTimeout = null;

/* ---------------------------
   Audio: sintetizar sonido suave de madera (Web Audio)
   --------------------------- */
let audioCtx = null;
function ensureAudio(){
  if(!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}
function playDoorSound(opening=true){
  ensureAudio();
  // simple creak using noise + filtered sine transient
  const now = audioCtx.currentTime;
  // noise burst
  const bufferSize = audioCtx.sampleRate * 0.2;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++){
    // noise shaped to creak
    data[i] = (Math.random()*2 - 1) * Math.exp(-3*i/bufferSize) * 0.6;
  }
  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;
  const noiseFilter = audioCtx.createBiquadFilter();
  noiseFilter.type = 'lowpass';
  noiseFilter.frequency.value = opening ? 1200 : 900;
  const env = audioCtx.createGain();
  env.gain.setValueAtTime(opening?0.0001:0.0001, now);
  env.gain.linearRampToValueAtTime(opening?0.6:0.5, now + 0.01);
  env.gain.exponentialRampToValueAtTime(0.0001, now + (opening?0.35:0.28));
  noise.connect(noiseFilter);
  noiseFilter.connect(env);
  env.connect(audioCtx.destination);
  noise.start(now);
  noise.stop(now + 0.2);

  // metallic-ish low body (sine) for weight
  const sine = audioCtx.createOscillator();
  sine.type = 'sine';
  sine.frequency.setValueAtTime(opening?220:200, now);
  const sineGain = audioCtx.createGain();
  sineGain.gain.setValueAtTime(0.0001, now);
  sineGain.gain.linearRampToValueAtTime(opening?0.15:0.12, now + 0.02);
  sineGain.gain.exponentialRampToValueAtTime(0.0001, now + (opening?0.5:0.45));
  sine.connect(sineGain);
  sineGain.connect(audioCtx.destination);
  sine.start(now);
  sine.stop(now + 0.5);
}

/* ---------------------------
   Movimiento del jugador (cámara) - controles sin PointerLock
   --------------------------- */
const keys = {};
window.addEventListener('keydown', (e) => {
  keys[e.code] = true;
  // primer gesto del usuario: arrancar audio context (necesario para autoplay policies)
  if(!audioCtx) {
    // resume/create on user gesture
    try { ensureAudio(); if(audioCtx.state === 'suspended') audioCtx.resume(); } catch(e){/* ignorable */ }
  }
});
window.addEventListener('keyup', (e) => { keys[e.code] = false; });

let velY = 0;
let canJump = true;
const walkSpeed = 0.12;
const runSpeed = 0.26;
const rotSpeed = 0.05;

/* proximidad a la puerta */
function distToDoor(){
  const dx = camera.position.x - (doorPivot.position.x + doorMesh.position.x * doorPivot.scale.x);
  const dz = camera.position.z - doorPivot.position.z;
  const dy = camera.position.y - (doorMesh.position.y + doorPivot.position.y - doorH/2);
  return Math.sqrt(dx*dx + dy*dy + dz*dz);
}

/* Mostrar prompt si cerca */
const promptEl = document.getElementById('prompt');
function updatePrompt(){
  if(distToDoor() < 2.0) promptEl.style.display = 'block'; else promptEl.style.display = 'none';
}

/* abrir/cerrar puerta (iniciadores) */
function triggerDoor(){
  if(distToDoor() < 2.0){
    if(doorState === 'closed' || doorState === 'closing'){
      doorState = 'opening'; animT = 0;
      playDoorSound(true);
      // comenzar autocierre cuando termine de abrir (3s después de abierta)
      if(autoCloseTimeout) { clearTimeout(autoCloseTimeout); autoCloseTimeout = null; }
      setTimeout(()=> {
        if(doorState === 'open') {
          autoCloseTimeout = setTimeout(()=> { if(doorState==='open'){ doorState='closing'; animT=0; playDoorSound(false); } }, 3000);
        }
      }, animDur*1000 + 50);
    } else if(doorState === 'open'){
      // cerrar a mano
      doorState = 'closing'; animT = 0;
      playDoorSound(false);
      if(autoCloseTimeout){ clearTimeout(autoCloseTimeout); autoCloseTimeout = null; }
    }
  }
}

/* ligar tecla E al trigger */
window.addEventListener('keydown', (e) => { if(e.code === 'KeyE') triggerDoor(); });

/* ---------------------------
   Loop animación
   --------------------------- */
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  // rotación con A/D
  if(keys['KeyA']) camera.rotation.y += rotSpeed;
  if(keys['KeyD']) camera.rotation.y -= rotSpeed;

  // movimiento forward/back sin componente Y
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  dir.y = 0; dir.normalize();

  const speed = (keys['ShiftLeft'] || keys['ShiftRight']) ? runSpeed : walkSpeed;
  if(keys['KeyW']) camera.position.addScaledVector(dir, speed);
  if(keys['KeyS']) camera.position.addScaledVector(dir, -speed);

  // salto y gravedad
  if(keys['Space'] && canJump){ velY = 0.32; canJump = false; }
  velY -= 0.02;
  camera.position.y += velY;
  if(camera.position.y < 1.7){ camera.position.y = 1.7; velY = 0; canJump = true; }

  // actualizar prompt HUD
  updatePrompt();

  // animar puerta
  if(doorState === 'opening'){
    animT += dt;
    const t = Math.min(1, animT / animDur);
    const ease = t * (2 - t);
    doorPivot.rotation.y = closedAngle + (openAngle - closedAngle) * ease;
    if(t >= 1) doorState = 'open';
  } else if(doorState === 'closing'){
    animT += dt;
    const t = Math.min(1, animT / animDur);
    const ease = t * (2 - t);
    doorPivot.rotation.y = openAngle + (closedAngle - openAngle) * ease;
    if(t >= 1) doorState = 'closed';
  }

  renderer.render(scene, camera);
}
animate();

/* ---------------------------
   Resize handling
   --------------------------- */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
