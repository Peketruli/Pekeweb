<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Casino 3D â€” Mejorado</title>
<style>
  :root{--bg:#0b0f1a;--panel:#101625;--accent:#f5b642;--muted:#9aa5b1}
  html,body{height:100%;margin:0;font-family:Arial;background:var(--bg);color:white;overflow:hidden}
  #container{width:100%;height:100%}
  #ui{position:absolute;top:10px;left:10px;z-index:5}
  .panel{background:rgba(0,0,0,0.4);padding:10px;border-radius:8px;margin-bottom:8px}
  #modal{position:absolute;right:20px;top:20px;width:380px;background:var(--panel);padding:14px;border-radius:12px;display:none;z-index:10;max-height:70vh;overflow:auto}
  #npcMsg{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.6);padding:10px;border-radius:8px;display:none}
  button,input,select{background:#182034;color:white;border:1px solid #334;padding:6px;border-radius:6px;margin:4px 0}
  .gameUI h2{margin:0 0 8px 0}
</style>
</head>
<body>
<div id="container"></div>
<div id="ui">
  <div class="panel">Saldo: <span id="balance">1000</span> â‚¬</div>
  <div class="panel">Pulsa <b>E</b> para interactuar</div>
</div>
<div id="modal"></div>
<div id="npcMsg">Pulsa E para recoger fichas diarias</div>

<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>

<script>
  // CONFIG SUPABASE
  const SUPABASE_URL = 'https://jdvwlfogkzrzovepzjqa.supabase.co';
  const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpkdndsZm9na3pyem92ZXB6anFhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwMzY1MjEsImV4cCI6MjA3MzYxMjUyMX0.IwVFrvuluY0tfgE82XnqYSsRjFPsDYnlfyirHjKu1TI';

  if(!window.supabase || !window.supabase.createClient){
    alert('Falta el SDK de Supabase. AÃ±ade: <script src="https://unpkg.com/@supabase/supabase-js"></script> antes de este script.');
    return;
  }
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

  // Helper random
  function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

  // DOM refs
  const container = document.getElementById('container');
  const balanceSpan = document.getElementById('balance'); // muestra en UI
  const pekepuntosEl = document.getElementById('pekepuntos'); // opcional (si existe)
  const npcMsgEl = document.getElementById('npcMsg');

  // USUARIO (desde localStorage â€” tu flow de login lo pone ahÃ­)
  let currentUser = null;
  try {
    currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
  } catch(e){
    currentUser = null;
  }
  if(!currentUser){
    alert('Debes iniciar sesiÃ³n para jugar (currentUser no encontrado en localStorage).');
    // no hacemos throw para que la UI no se rompa por completo; salimos.
    return;
  }

  // Balance inicial
  let balance = Number(currentUser.pekepuntos || 0);
  function refreshBalanceUI(){
    if(balanceSpan) balanceSpan.textContent = balance;
    if(pekepuntosEl) pekepuntosEl.textContent = `Pekepuntos: ${balance}`;
  }
  refreshBalanceUI();

  // Guardar balance en Supabase + localStorage
  async function saveBalance(){
    try{
      const { error } = await supabase
        .from('usuarios')
        .update({ pekepuntos: balance })
        .eq('id', currentUser.id);
      if(error) throw error;
      currentUser.pekepuntos = balance;
      localStorage.setItem('currentUser', JSON.stringify(currentUser));
      refreshBalanceUI();
    } catch(err){
      alert('Error guardando balance: ' + (err.message || err));
    }
  }

  // Claim diario (protecciÃ³n: una vez al dÃ­a)
  async function claimDaily(){
    try{
      const today = new Date().toISOString().slice(0,10);
      const last = currentUser.last_claim ? currentUser.last_claim.slice(0,10) : null;
      if(last === today){
        alert('Ya has reclamado las fichas diarias hoy.');
        return;
      }
      balance += 100;
      currentUser.last_claim = new Date().toISOString();
      // guardamos
      const { error } = await supabase
        .from('usuarios')
        .update({ pekepuntos: balance, last_claim: currentUser.last_claim })
        .eq('id', currentUser.id);
      if(error) throw error;
      localStorage.setItem('currentUser', JSON.stringify(currentUser));
      refreshBalanceUI();
      if(npcMsgEl){ npcMsgEl.innerText = 'Â¡Has recogido tus fichas diarias!'; npcMsgEl.style.display = 'block'; setTimeout(()=> npcMsgEl.style.display='none',1400); }
      alert('Â¡Has reclamado +100 Pekepuntos!');
    } catch(err){
      alert('Error al reclamar diario: ' + (err.message || err));
    }
  }

  // --------------------
  // Juegos (simples)
  // --------------------
  async function playBlackjack(bet = 50){
    if(balance < bet){ alert('No tienes suficientes Pekepuntos.'); return; }
    // mecÃ¡nica simplificada (simulaciÃ³n)
    const player = rand(15,21);
    const dealer = rand(16,21);
    let result;
    if(player > 21) result = 'lose';
    else if(dealer > 21 || player > dealer) result = 'win';
    else if(player === dealer) result = 'tie';
    else result = 'lose';

    if(result === 'win'){ balance += bet; alert(`Â¡Ganaste Blackjack!\nTu: ${player} â€” Dealer: ${dealer}\n+${bet} Pekepuntos`); }
    else if(result === 'lose'){ balance -= bet; alert(`Perdiste Blackjack.\nTu: ${player} â€” Dealer: ${dealer}\n-${bet} Pekepuntos`); }
    else { alert(`Empate Blackjack.\nTu: ${player} â€” Dealer: ${dealer}\nSin cambios.`); }

    await saveBalance();
  }

  async function playRoulette(bet = 50){
    if(balance < bet){ alert('No tienes suficientes Pekepuntos.'); return; }
    const chosen = prompt('Apuesta a un nÃºmero (0-36):');
    if(chosen === null) return;
    const pick = Number(chosen);
    if(Number.isNaN(pick) || pick < 0 || pick > 36){ alert('NÃºmero invÃ¡lido.'); return; }

    const result = rand(0,36);
    if(pick === result){
      const payout = bet * 35;
      balance += payout;
      alert(`Â¡Ha salido ${result}! Ganaste ${payout} Pekepuntos (x35).`);
    } else {
      balance -= bet;
      alert(`SaliÃ³ ${result}. Pierdes ${bet} Pekepuntos.`);
    }
    await saveBalance();
  }

  async function playSlots(bet = 50){
    if(balance < bet){ alert('No tienes suficientes Pekepuntos.'); return; }
    const symbols = ['ðŸ’','ðŸ‹','ðŸŠ','ðŸ‡','ðŸ’Ž','7ï¸âƒ£'];
    const r = [rand(0,5), rand(0,5), rand(0,5)];
    const res = r.map(i => symbols[i]).join(' | ');
    let won = false;
    if(r[0] === r[1] && r[1] === r[2]) won = true;

    if(won){
      const payout = bet * 5;
      balance += payout;
      alert(`${res}\nÂ¡Jackpot! Ganaste ${payout} Pekepuntos (x5).`);
    } else {
      balance -= bet;
      alert(`${res}\nNo hay combinaciÃ³n. Pierdes ${bet} Pekepuntos.`);
    }
    await saveBalance();
  }

  // --------------------
  // THREE.JS escena
  // --------------------
  if(!window.THREE){
    alert('Falta Three.js â€” incluye <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script> antes de este script.');
    return;
  }
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0f1a);

  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, 1.6, 5);
  camera.rotation.order = 'YXZ';

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  // poner renderer en tu contenedor
  container.appendChild(renderer.domElement);

  // luces
  const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.8); hemi.position.set(0,50,0); scene.add(hemi);
  scene.add(new THREE.AmbientLight(0xffffff, 0.25));
  const dir = new THREE.DirectionalLight(0xfff6d6, 0.6); dir.position.set(5,10,5); scene.add(dir);

  // texturas simples con canvas
  function canvasTextureGradient(a,b,size=512){
    const c = document.createElement('canvas');
    c.width = c.height = size;
    const ctx = c.getContext('2d');
    const g = ctx.createLinearGradient(0,0,size,size);
    g.addColorStop(0,a); g.addColorStop(1,b);
    ctx.fillStyle = g; ctx.fillRect(0,0,size,size);
    return new THREE.CanvasTexture(c);
  }

  // suelo
  const floorMat = new THREE.MeshStandardMaterial({ map: canvasTextureGradient('#2a0033','#550077'), roughness: 0.9 });
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(30,30), floorMat);
  floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

  // crear mesas/objetos interactuables
  const interactables = [];

  function addTable(x,z,type){
    const mat = new THREE.MeshStandardMaterial({ map: canvasTextureGradient('#222','#550') });
    const geom = (type === 'slots') ? new THREE.BoxGeometry(1,2,1) : new THREE.CylinderGeometry(1.5,1.5,0.3,32);
    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.set(x, (type==='slots'?1:0.3), z);
    mesh.userData.type = type;
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    interactables.push(mesh);
    return mesh;
  }

  const tableBJ = addTable(-4, 0, 'blackjack');
  const tableR  = addTable(0, 0, 'roulette');
  const tableS  = addTable(4, 0, 'slots');

  // NPC (cofre diario)
  const npcGeom = new THREE.CylinderGeometry(0.4,0.4,1.6,16);
  const npcMat = new THREE.MeshStandardMaterial({ color: 0x999999 });
  const npcMesh = new THREE.Mesh(npcGeom, npcMat);
  npcMesh.position.set(0,1,5);
  npcMesh.userData.type = 'npc';
  scene.add(npcMesh);
  interactables.push(npcMesh);

  // cÃ¡mara movimiento
  const keys = {};
  document.addEventListener('keydown', e=> keys[e.code] = true);
  document.addEventListener('keyup', e=> keys[e.code] = false);

  let yaw = 0, pitch = 0;
  function updateCamera(dt){
    const yawSpeed = 1.8, pitchSpeed = 1.2;
    if(keys['ArrowLeft']) yaw += yawSpeed * dt;
    if(keys['ArrowRight']) yaw -= yawSpeed * dt;
    if(keys['ArrowUp']) pitch += pitchSpeed * dt;
    if(keys['ArrowDown']) pitch -= pitchSpeed * dt;
    const pitchLimit = Math.PI/2 - 0.05;
    pitch = Math.max(-pitchLimit, Math.min(pitchLimit, pitch));
    camera.rotation.y = yaw;
    camera.rotation.x = pitch;

    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();
    const right = new THREE.Vector3();
    right.crossVectors(forward, camera.up).normalize();
    const move = new THREE.Vector3();
    if(keys['KeyW']) move.add(forward);
    if(keys['KeyS']) move.sub(forward);
    if(keys['KeyD']) move.add(right);
    if(keys['KeyA']) move.sub(right);
    move.multiplyScalar(3 * dt);
    camera.position.add(move);
  }

  // raycast interaccion
  const ray = new THREE.Raycaster();
  let lookingAt = null;
  function checkInteraction(){
    ray.set(camera.position, camera.getWorldDirection(new THREE.Vector3()));
    const hits = ray.intersectObjects(interactables, false);
    if(hits.length === 0 || hits[0].distance > 4){
      lookingAt = null;
      if(npcMsgEl) npcMsgEl.style.display = 'none';
      return;
    }
    lookingAt = hits[0].object;
    if(lookingAt.userData.type === 'npc'){
      if(npcMsgEl){ npcMsgEl.style.display = 'block'; npcMsgEl.innerText = 'Pulsa E para recoger fichas diarias'; }
    } else {
      if(npcMsgEl) npcMsgEl.style.display = 'none';
    }
  }

  // tecla E => acciones
  document.addEventListener('keydown', async (e) => {
    if(e.code !== 'KeyE') return;
    if(!lookingAt) return;
    const t = lookingAt.userData.type;
    try{
      if(t === 'npc') await claimDaily();
      else if(t === 'blackjack') await playBlackjack(50);
      else if(t === 'roulette') await playRoulette(50);
      else if(t === 'slots') await playSlots(50);
    } catch(err){
      alert('Error en la acciÃ³n: ' + (err && err.message ? err.message : err));
    }
  });

  // animaciÃ³n
  const clock = new THREE.Clock();
  function animate(){
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    updateCamera(dt);
    checkInteraction();
    renderer.render(scene, camera);
  }
  animate();

  // resize
  window.addEventListener('resize', ()=> {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

</script>
</body>
</html>
