<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Casino 3D - Ruleta y Mesas</title>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<style>
body { margin:0; overflow:hidden; background:#000; font-family:Arial, Helvetica, sans-serif; }
#hint { position:absolute; left:12px; top:12px; z-index:5; background:rgba(0,0,0,0.6); color:#fff; padding:8px 10px; border-radius:8px; font-size:13px; }
#credits { position:absolute; right:12px; top:12px; z-index:5; background:rgba(0,0,0,0.45); color:#ddd; padding:6px 8px; border-radius:6px; font-size:12px; }
</style>
</head>
<body>
<div id="hint">ðŸŽ° Mover: W A S D â€” Mirar: ratÃ³n</div>
<div id="credits">Casino clÃ¡sico â€” texturas libres (online)</div>

<script>
// ---------- Escena ----------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);
scene.fog = new THREE.FogExp2(0x202020, 0.02);

const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(0, 1.7, 10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// ---------- Cargador ----------
const loader = new THREE.TextureLoader();

// ---------- Suelo tipo alfombra roja ----------
const carpetCanvas = document.createElement('canvas');
carpetCanvas.width = carpetCanvas.height = 512;
const ctx = carpetCanvas.getContext('2d');
ctx.fillStyle = '#7a0000';
ctx.fillRect(0, 0, 512, 512);
ctx.strokeStyle = 'rgba(255, 50, 50, 0.15)';
ctx.lineWidth = 2;
for (let i = 0; i < 512; i += 32) {
  ctx.beginPath();
  ctx.moveTo(i, 0);
  ctx.lineTo(i, 512);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0, i);
  ctx.lineTo(512, i);
  ctx.stroke();
}
const carpetTex = new THREE.CanvasTexture(carpetCanvas);
carpetTex.wrapS = carpetTex.wrapT = THREE.RepeatWrapping;
carpetTex.repeat.set(8, 8);
carpetTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
carpetTex.colorSpace = THREE.SRGBColorSpace;

const floorMat = new THREE.MeshStandardMaterial({
  map: carpetTex,
  roughness: 0.9,
  metalness: 0.05
});
const floor = new THREE.Mesh(new THREE.PlaneGeometry(80, 80), floorMat);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

// ---------- IluminaciÃ³n ----------
const ambientLight = new THREE.AmbientLight(0xffffff, 0.45);
scene.add(ambientLight);
const spot = new THREE.SpotLight(0xffffff, 1.2, 100, Math.PI / 4, 0.6);
spot.position.set(0, 20, 10);
spot.castShadow = true;
scene.add(spot);

// ---------- Paredes ----------
const wallTex = loader.load('https://cdn.pixabay.com/photo/2017/06/21/07/30/marble-2426312_1280.jpg');
wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;
wallTex.repeat.set(4, 2);
const wallMat = new THREE.MeshStandardMaterial({ map: wallTex, roughness: 0.8, metalness: 0.2 });

function wall(x, y, z, sx, sy, sz) {
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz), wallMat);
  mesh.position.set(x, y, z);
  mesh.receiveShadow = true;
  scene.add(mesh);
}
wall(0, 5, -40, 80, 10, 0.8);
wall(0, 5, 40, 80, 10, 0.8);
wall(-40, 5, 0, 0.8, 10, 80);
wall(40, 5, 0, 0.8, 10, 80);

// ---------- Mesa blackjack ----------
const tableGroup = new THREE.Group();

function createFeltTexture() {
  const c = document.createElement('canvas');
  c.width = c.height = 512;
  const ctx = c.getContext('2d');
  const grad = ctx.createLinearGradient(0, 0, 512, 512);
  grad.addColorStop(0, '#0b5b35');
  grad.addColorStop(1, '#0e7041');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, 512, 512);
  ctx.strokeStyle = '#ffd27f';
  ctx.lineWidth = 12;
  ctx.strokeRect(0, 0, 512, 512);
  const tex = new THREE.CanvasTexture(c);
  return tex;
}
const feltTex2 = createFeltTexture();

const tableTop = new THREE.Mesh(
  new THREE.CylinderGeometry(4.2, 4.2, 0.3, 32),
  new THREE.MeshStandardMaterial({ map: feltTex2, roughness: 0.7, metalness: 0.05 })
);
tableTop.position.y = 0.15;
tableTop.castShadow = true;
tableGroup.add(tableTop);

const rim = new THREE.Mesh(
  new THREE.TorusGeometry(4.35, 0.25, 16, 100),
  new THREE.MeshStandardMaterial({ color: 0x4a2b12 })
);
rim.rotation.x = Math.PI / 2;
rim.position.y = 0.3;
tableGroup.add(rim);

// Sillas
const numSillas = 6;
for (let i = 0; i < numSillas; i++) {
  const angle = (i / numSillas) * Math.PI * 1.2 - Math.PI / 2.4;
  const r = 4.9;
  const sx = Math.sin(angle) * r;
  const sz = Math.cos(angle) * r;
  const seat = new THREE.Mesh(
    new THREE.CylinderGeometry(0.35, 0.35, 0.3, 16),
    new THREE.MeshStandardMaterial({ color: 0x2b1508 })
  );
  seat.position.set(sx, 0.15, sz);
  seat.castShadow = true;
  tableGroup.add(seat);
}
tableGroup.position.set(0, 0, 0);
scene.add(tableGroup);

// ---------- Ruleta ----------
const wheelGroup = new THREE.Group();
const wheelBase = new THREE.Mesh(
  new THREE.CylinderGeometry(2.2, 2.2, 0.4, 48),
  new THREE.MeshStandardMaterial({ color: 0x2f1608 })
);
wheelBase.position.y = 0.2;
wheelGroup.add(wheelBase);

const wheelCanvas = document.createElement('canvas');
wheelCanvas.width = wheelCanvas.height = 1024;
const ctx2 = wheelCanvas.getContext('2d');
const cx = 512, cy = 512, r = 420;
for (let i = 0; i < 18; i++) {
  ctx2.beginPath();
  const start = (i / 18) * Math.PI * 2;
  const end = ((i + 1) / 18) * Math.PI * 2;
  ctx2.moveTo(cx, cy);
  ctx2.arc(cx, cy, r, start, end);
  ctx2.closePath();
  ctx2.fillStyle = i % 2 === 0 ? '#9b0000' : '#000';
  ctx2.fill();
}
ctx2.beginPath();
ctx2.fillStyle = '#d1c6b3';
ctx2.arc(cx, cy, r * 0.1, 0, Math.PI * 2);
ctx2.fill();

const wheelTex = new THREE.CanvasTexture(wheelCanvas);
const wheelPlate = new THREE.Mesh(
  new THREE.CylinderGeometry(1.9, 1.9, 0.05, 64),
  new THREE.MeshStandardMaterial({ map: wheelTex })
);
wheelPlate.position.y = 0.45;
wheelGroup.add(wheelPlate);

const rimMesh = new THREE.Mesh(
  new THREE.TorusGeometry(2.4, 0.18, 16, 100),
  new THREE.MeshStandardMaterial({ color: 0x8b4513 })
);
rimMesh.rotation.x = Math.PI / 2;
rimMesh.position.y = 0.45;
wheelGroup.add(rimMesh);

wheelGroup.position.set(-10, 0, 8);
scene.add(wheelGroup);

function spin() {
  wheelGroup.rotation.y += 0.02;
  requestAnimationFrame(spin);
}
spin();

// ---------- Movimiento cÃ¡mara ----------
let yaw = 0, pitch = 0;
const sens = 0.0026;
window.addEventListener('mousemove', e => {
  yaw -= e.movementX * sens;
  pitch -= e.movementY * sens;
  pitch = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, pitch));
});

const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

const vel = new THREE.Vector3();
const clock = new THREE.Clock();
function move(dt) {
  camera.rotation.set(pitch, yaw, 0, "YXZ");
  const dir = new THREE.Vector3();
  const fwd = new THREE.Vector3();
  camera.getWorldDirection(fwd);
  fwd.y = 0;
  fwd.normalize();
  const right = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0, 1, 0)).negate();
  if (keys["KeyW"]) dir.add(fwd);
  if (keys["KeyS"]) dir.sub(fwd);
  if (keys["KeyA"]) dir.add(right);
  if (keys["KeyD"]) dir.sub(right);
  if (dir.lengthSq() > 0) dir.normalize();
  vel.addScaledVector(dir, dt * 20);
  vel.multiplyScalar(0.9);
  camera.position.addScaledVector(vel, dt);
}

function animate() {
  requestAnimationFrame(animate);
  move(clock.getDelta());
  renderer.render(scene, camera);
}
animate();

// ---------- Resize ----------
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
