<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Casino Deluxe — Pasillo y Sala</title>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<style>
body { margin:0; overflow:hidden; background:#111; font-family:Arial, Helvetica, sans-serif; }
#hint { position:absolute; left:12px; top:12px; z-index:5;
       background:rgba(255,255,255,0.06); color:#fff;
       padding:8px 10px; border-radius:8px; font-size:13px; }
</style>
</head>
<body>
<div id="hint">W A S D para moverse, ratón para mirar, E para abrir la puerta</div>
<script>
// -------------------- Escena y cámara --------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xe0dcd1); // color cálido y suave

const corridorHeight = 12;
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 200);
camera.position.set(0, 1.7, -12);
let yaw = Math.PI; // mirando hacia la sala
let pitch = 0;

// -------------------- Renderer --------------------
const renderer = new THREE.WebGLRenderer({ antialias:false });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(1, window.devicePixelRatio));
document.body.appendChild(renderer.domElement);

// -------------------- Luces --------------------
scene.add(new THREE.AmbientLight(0xffffff,0.7));
const sun = new THREE.DirectionalLight(0xfff2cc,0.5);
sun.position.set(40,50,40);
scene.add(sun);

// -------------------- Materiales --------------------
const carpetMat = new THREE.MeshBasicMaterial({color:0x7d0a0a});
const wallMatSoft = new THREE.MeshBasicMaterial({ color: 0xd3c6b0 });
const woodMat = new THREE.MeshBasicMaterial({color:0x5a3719});
const greenMat = new THREE.MeshBasicMaterial({color:0x0b5b35});
const redMat = new THREE.MeshBasicMaterial({color:0xb20d0d});
const blackMat = new THREE.MeshBasicMaterial({color:0x111111});
const whiteMat = new THREE.MeshBasicMaterial({color:0xffffff});

// -------------------- Función para paredes --------------------
function wall(x,y,z,sx,sy,sz, mat=wallMatSoft){
  const w = new THREE.Mesh(new THREE.BoxGeometry(sx,sy,sz), mat);
  w.position.set(x,y,z);
  scene.add(w);
}

// -------------------- PASILLO --------------------
const corridorLength = 20; 
const corridorWidth = 18;

// Suelo y techo
const floor = new THREE.Mesh(new THREE.PlaneGeometry(corridorWidth, corridorLength), carpetMat);
floor.rotation.x = -Math.PI/2;
floor.position.z = -corridorLength/2;
scene.add(floor);

const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(corridorWidth, corridorLength), woodMat);
ceiling.rotation.x = Math.PI/2;
ceiling.position.y = corridorHeight;
ceiling.position.z = -corridorLength/2;
scene.add(ceiling);

// Paredes laterales
wall(-corridorWidth/2, corridorHeight/2, -corridorLength/2, 1, corridorHeight, corridorLength);
wall(corridorWidth/2, corridorHeight/2, -corridorLength/2, 1, corridorHeight, corridorLength);

// Pared trasera del pasillo
wall(0, corridorHeight/2, -corridorLength-0.75, corridorWidth, corridorHeight, 1);

// -------------------- Puerta interactiva --------------------
const doorMat = new THREE.MeshBasicMaterial({color:0x8a5a2b});
const doorLeft = new THREE.Mesh(new THREE.BoxGeometry(1.2,3.8,0.15), doorMat);
doorLeft.position.set(-0.6,1.9,-corridorLength);
scene.add(doorLeft);
const doorRight = new THREE.Mesh(new THREE.BoxGeometry(1.2,3.8,0.15), doorMat);
doorRight.position.set(0.6,1.9,-corridorLength);
scene.add(doorRight);

// -------------------- SALA --------------------
const roomSize = 30;
const roomZ = 0;

// Suelo y techo sala
const roomFloor = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), carpetMat);
roomFloor.rotation.x = -Math.PI/2;
roomFloor.position.z = roomZ + roomSize/2;
scene.add(roomFloor);

const roomCeiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), woodMat);
roomCeiling.rotation.x = Math.PI/2;
roomCeiling.position.y = corridorHeight;
roomCeiling.position.z = roomZ + roomSize/2;
scene.add(roomCeiling);

// Paredes sala
wall(-roomSize/2, corridorHeight/2, roomZ + roomSize/2, 1, corridorHeight, roomSize);
wall(roomSize/2, corridorHeight/2, roomZ + roomSize/2, 1, corridorHeight, roomSize);
wall(0, corridorHeight/2, roomZ + roomSize, roomSize, corridorHeight, 1);

// Pared trasera dividida y movida más hacia afuera
const gap = corridorWidth/2; 
const extra = 2;
wall(-gap-0.5-extra, corridorHeight/2, roomZ, (roomSize-gap*2)/2, corridorHeight, 1);
wall(gap+0.5+extra, corridorHeight/2, roomZ, (roomSize-gap*2)/2, corridorHeight, 1);

// -------------------- MESA BLACKJACK MEJORADA --------------------
const tableGroup = new THREE.Group();
const tableTop = new THREE.Mesh(new THREE.CylinderGeometry(3,3,0.3,32), greenMat);
tableTop.position.set(6,1.05,roomZ+15);
tableGroup.add(tableTop);

const rim = new THREE.Mesh(new THREE.TorusGeometry(3.3,0.2,12,48), woodMat);
rim.rotation.x = Math.PI/2;
rim.position.set(6,1.2,roomZ+15);
tableGroup.add(rim);

// patas robustas
const legMat = new THREE.MeshStandardMaterial({color:0x3b2b19});
for(let dx=-1; dx<=1; dx+=2){
  const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,1.1,12), legMat);
  leg.position.set(6 + dx*1.5,0.55,roomZ+15);
  tableGroup.add(leg);
}
scene.add(tableGroup);

// -------------------- RULETA NUEVA --------------------
const wheelGroup = new THREE.Group();

// soporte
const stand = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.9,1,16), woodMat);
stand.position.set(-6,0.75,roomZ+10);
wheelGroup.add(stand);

const base = new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.6,0.2,24), woodMat);
base.position.set(-6,0.1,roomZ+10);
wheelGroup.add(base);

// plato ruleta: segmentos sólidos rojo y negro, borde y centro
const wheelRadius = 1.8;
const segments = 18;
const wheelPlate = new THREE.Group();

for(let i=0;i<segments;i++){
  const angleStart = (i/segments)*Math.PI*2;
  const angleEnd = ((i+1)/segments)*Math.PI*2;
  const shape = new THREE.Shape();
  shape.moveTo(0,0);
  shape.absarc(0,0,wheelRadius,angleStart,angleEnd,false);
  const geom = new THREE.ExtrudeGeometry(shape,{depth:0.08,bevelEnabled:false});
  const mat = (i%2===0)? redMat : blackMat;
  const seg = new THREE.Mesh(geom, mat);
  seg.rotation.x = -Math.PI/2;
  seg.position.set(-6,1.2,roomZ+10);
  wheelPlate.add(seg);
}

// borde exterior más grueso
const border = new THREE.Mesh(new THREE.TorusGeometry(wheelRadius+0.05,0.08,8,64), woodMat);
border.rotation.x=Math.PI/2;
border.position.set(-6,1.23,roomZ+10);
wheelPlate.add(border);

// centro destacado
const center = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,0.08,16), redMat);
center.position.set(-6,1.23,roomZ+10);
wheelPlate.add(center);

wheelGroup.add(wheelPlate);
scene.add(wheelGroup);

// -------------------- Movimiento --------------------
const keys={};
const sens=0.002;
window.addEventListener('mousemove',e=>{
  yaw-=e.movementX*sens;
  pitch-=e.movementY*sens;
  pitch=Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, pitch));
});
window.addEventListener('keydown',e=>{keys[e.code]=true;});
window.addEventListener('keyup',e=>{keys[e.code]=false;});

function move(dt){
  camera.rotation.set(pitch,yaw,0,"ZYX");
  const forward=new THREE.Vector3(); camera.getWorldDirection(forward); forward.y=0; forward.normalize();
  const right=new THREE.Vector3().crossVectors(forward,new THREE.Vector3(0,1,0)).negate();
  let dir=new THREE.Vector3();
  if(keys['KeyW']) dir.add(forward);
  if(keys['KeyS']) dir.addScaledVector(forward,-1);
  if(keys['KeyA']) dir.add(right);
  if(keys['KeyD']) dir.addScaledVector(right,-1);
  if(dir.lengthSq()>0) dir.normalize();
  camera.position.addScaledVector(dir,dt*8);
  if(camera.position.y<1.6) camera.position.y=1.7;
}

// -------------------- Puerta interactiva --------------------
window.addEventListener('keydown',e=>{
  if(e.key.toLowerCase()==='e'){
    const d=camera.position.distanceTo(new THREE.Vector3(0,2,-corridorLength));
    if(d<3.5) window.location.href='h.html';
  }
});

// -------------------- Animación --------------------
function animate(){
  requestAnimationFrame(animate);
  move(0.016);
  renderer.render(scene,camera);
}
animate();

// -------------------- Resize --------------------
window.addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
