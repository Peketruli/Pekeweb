<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Casino Deluxe — Pasillo y Sala</title>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<style>
body { margin:0; overflow:hidden; background:#111; font-family:Arial, Helvetica, sans-serif; }
#hint { position:absolute; left:12px; top:12px; z-index:5;
       background:rgba(255,255,255,0.06); color:#fff;
       padding:8px 10px; border-radius:8px; font-size:13px; }
</style>
</head>
<body>
<div id="hint">W A S D para moverse, ratón para mirar, E para abrir la puerta</div>
<script>
// -------------------- Escena y cámara --------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xe0dcd1); // color cálido y suave

const corridorHeight = 12;
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 200);
camera.position.set(0, 1.7, -12);
let yaw = Math.PI; // mirando hacia la sala
let pitch = 0;

// -------------------- Renderer --------------------
const renderer = new THREE.WebGLRenderer({ antialias:false });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(1, window.devicePixelRatio));
document.body.appendChild(renderer.domElement);

// -------------------- Luces --------------------
scene.add(new THREE.AmbientLight(0xffffff,0.7));
const sun = new THREE.DirectionalLight(0xfff2cc,0.5);
sun.position.set(40,50,40);
scene.add(sun);

// -------------------- Materiales --------------------
const carpetMat = new THREE.MeshBasicMaterial({color:0x7d0a0a});
const wallMatSoft = new THREE.MeshBasicMaterial({ color: 0xd3c6b0 });
const woodMat = new THREE.MeshBasicMaterial({color:0x5a3719});
const greenMat = new THREE.MeshBasicMaterial({color:0x0b5b35});
const redMat = new THREE.MeshBasicMaterial({color:0xb20d0d});
const blackMat = new THREE.MeshBasicMaterial({color:0x111111});
const whiteMat = new THREE.MeshBasicMaterial({color:0xffffff});

// -------------------- Función para paredes --------------------
function wall(x,y,z,sx,sy,sz, mat=wallMatSoft){
  const w = new THREE.Mesh(new THREE.BoxGeometry(sx,sy,sz), mat);
  w.position.set(x,y,z);
  scene.add(w);
}

// -------------------- PASILLO --------------------
const corridorLength = 20; 
const corridorWidth = 18;

// Suelo y techo
const floor = new THREE.Mesh(new THREE.PlaneGeometry(corridorWidth, corridorLength), carpetMat);
floor.rotation.x = -Math.PI/2;
floor.position.z = -corridorLength/2;
scene.add(floor);

const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(corridorWidth, corridorLength), woodMat);
ceiling.rotation.x = Math.PI/2;
ceiling.position.y = corridorHeight;
ceiling.position.z = -corridorLength/2;
scene.add(ceiling);

// Paredes laterales
wall(-corridorWidth/2, corridorHeight/2, -corridorLength/2, 1, corridorHeight, corridorLength);
wall(corridorWidth/2, corridorHeight/2, -corridorLength/2, 1, corridorHeight, corridorLength);

// Pared trasera del pasillo
wall(0, corridorHeight/2, -corridorLength-0.75, corridorWidth, corridorHeight, 1);

// -------------------- Puerta interactiva --------------------
const doorMat = new THREE.MeshBasicMaterial({color:0x8a5a2b});
const doorLeft = new THREE.Mesh(new THREE.BoxGeometry(1.2,3.8,0.15), doorMat);
doorLeft.position.set(-0.6,1.9,-corridorLength);
scene.add(doorLeft);
const doorRight = new THREE.Mesh(new THREE.BoxGeometry(1.2,3.8,0.15), doorMat);
doorRight.position.set(0.6,1.9,-corridorLength);
scene.add(doorRight);

// -------------------- SALA --------------------
const roomSize = 30;
const roomZ = 0;

// Suelo y techo sala
const roomFloor = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), carpetMat);
roomFloor.rotation.x = -Math.PI/2;
roomFloor.position.z = roomZ + roomSize/2;
scene.add(roomFloor);

const roomCeiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), woodMat);
roomCeiling.rotation.x = Math.PI/2;
roomCeiling.position.y = corridorHeight;
roomCeiling.position.z = roomZ + roomSize/2;
scene.add(roomCeiling);

// Paredes sala
wall(-roomSize/2, corridorHeight/2, roomZ + roomSize/2, 1, corridorHeight, roomSize);
wall(roomSize/2, corridorHeight/2, roomZ + roomSize/2, 1, corridorHeight, roomSize);
wall(0, corridorHeight/2, roomZ + roomSize, roomSize, corridorHeight, 1);

// Pared trasera dividida y movida más hacia afuera
const gap = corridorWidth/2; 
const extra = 2;
wall(-gap-0.5-extra, corridorHeight/2, roomZ, (roomSize-gap*2)/2, corridorHeight, 1);
wall(gap+0.5+extra, corridorHeight/2, roomZ, (roomSize-gap*2)/2, corridorHeight, 1);

// -------------------- MESA BLACKJACK MEJORADA --------------------
const tableGroup = new THREE.Group();
const tableTop = new THREE.Mesh(new THREE.CylinderGeometry(3,3,0.3,32), greenMat);
tableTop.position.set(6,1.05,roomZ+15);
tableGroup.add(tableTop);

const rim = new THREE.Mesh(new THREE.TorusGeometry(3.3,0.2,12,48), woodMat);
rim.rotation.x = Math.PI/2;
rim.position.set(6,1.2,roomZ+15);
tableGroup.add(rim);

// patas robustas
const legMat = new THREE.MeshStandardMaterial({color:0x3b2b19});
for(let dx=-1; dx<=1; dx+=2){
  const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,1.1,12), legMat);
  leg.position.set(6 + dx*1.5,0.55,roomZ+15);
  tableGroup.add(leg);
}
scene.add(tableGroup);

// Ruleta SOLIDA con canvas
function createRoulette(x, y, z) {
  const group = new THREE.Group();

  // Base soporte
  const stand = new THREE.Mesh(
    new THREE.CylinderGeometry(0.6, 0.9, 1, 16),
    woodMat
  );
  stand.position.set(x, y-0.15, z);
  group.add(stand);

  const base = new THREE.Mesh(
    new THREE.CylinderGeometry(1.6, 1.6, 0.2, 24),
    woodMat
  );
  base.position.set(x, y-0.85, z);
  group.add(base);

  // Plato de la ruleta
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = 1024;
  const ctx = canvas.getContext('2d');
  const cx = 512, cy = 512, r = 420;
  const segments = 18;

  for (let i = 0; i < segments; i++) {
    const start = (i/segments)*2*Math.PI;
    const end = ((i+1)/segments)*2*Math.PI;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, r, start, end);
    ctx.closePath();
    ctx.fillStyle = (i%2===0) ? '#b20d0d' : '#111111';
    ctx.fill();
  }

  // borde
  ctx.beginPath();
  ctx.arc(cx, cy, r*0.95, 0, Math.PI*2);
  ctx.lineWidth = 18;
  ctx.strokeStyle = '#5a3719';
  ctx.stroke();

  // centro
  ctx.beginPath();
  ctx.arc(cx, cy, r*0.15, 0, Math.PI*2);
  ctx.fillStyle = '#d1c6b3';
  ctx.fill();

  const texture = new THREE.CanvasTexture(canvas);
  texture.encoding = THREE.sRGBEncoding;

  const wheel = new THREE.Mesh(
    new THREE.CylinderGeometry(r/100, r/100, 0.06, 64),
    new THREE.MeshStandardMaterial({ map: texture })
  );
  wheel.rotation.x = -Math.PI/2;
  wheel.position.set(x, y, z);
  group.add(wheel);

  return group;
}

// Crear la ruleta
const wheelGroup = createRoulette(-6, 1.2, roomZ + 10);
scene.add(wheelGroup);


// -------------------- Movimiento --------------------
const keys={};
const sens=0.002;
window.addEventListener('mousemove',e=>{
  yaw-=e.movementX*sens;
  pitch-=e.movementY*sens;
  pitch=Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, pitch));
});
window.addEventListener('keydown',e=>{keys[e.code]=true;});
window.addEventListener('keyup',e=>{keys[e.code]=false;});

function move(dt){
  camera.rotation.set(pitch,yaw,0,"ZYX");
  const forward=new THREE.Vector3(); camera.getWorldDirection(forward); forward.y=0; forward.normalize();
  const right=new THREE.Vector3().crossVectors(forward,new THREE.Vector3(0,1,0)).negate();
  let dir=new THREE.Vector3();
  if(keys['KeyW']) dir.add(forward);
  if(keys['KeyS']) dir.addScaledVector(forward,-1);
  if(keys['KeyA']) dir.add(right);
  if(keys['KeyD']) dir.addScaledVector(right,-1);
  if(dir.lengthSq()>0) dir.normalize();
  camera.position.addScaledVector(dir,dt*8);
  if(camera.position.y<1.6) camera.position.y=1.7;
}

// -------------------- Puerta interactiva --------------------
window.addEventListener('keydown',e=>{
  if(e.key.toLowerCase()==='e'){
    const d=camera.position.distanceTo(new THREE.Vector3(0,2,-corridorLength));
    if(d<3.5) window.location.href='h.html';
  }
});

// -------------------- Animación --------------------
function animate(){
  requestAnimationFrame(animate);
  move(0.016);
  renderer.render(scene,camera);
}
animate();

// -------------------- Resize --------------------
window.addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
