<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Casino 3D - Paseo</title>

<!-- Three.js + PointerLockControls -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/PointerLockControls.js"></script>

<style>
  /* --- P√°gina / HUD --- */
  html,body{ height:100%; margin:0; font-family: Inter, system-ui, Arial; background:#000; color:#fff; }
  #container{ width:100%; height:100vh; overflow:hidden; position:relative; }

  /* HUD */
  .hud {
    position: absolute;
    left: 16px;
    top: 16px;
    z-index: 20;
    text-align: left;
    pointer-events: none;
  }
  .panel {
    background: rgba(10,6,15,0.6);
    border: 1px solid rgba(255,111,0,0.14);
    padding: 10px 12px;
    border-radius: 10px;
    box-shadow: 0 0 20px rgba(181, 23, 255, 0.08);
    pointer-events: auto;
  }
  #pekepuntos { font-weight:700; font-size:1rem; color: #00ff9d; text-shadow: 0 0 8px #00ff9d; }
  #info { margin-top:8px; font-size:0.9rem; color:#ddd; }

  /* Center instruction to enter pointer lock */
  #enterHint {
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    z-index: 30;
    background: linear-gradient(90deg,#1a001a,#2b002b);
    padding:14px 20px;
    border-radius:10px;
    border:1px solid rgba(255,111,0,0.2);
    box-shadow: 0 0 40px rgba(181,23,255,0.08);
    cursor:pointer;
  }

  /* Interaction hint when near machine */
  #interactHint {
    position: absolute;
    bottom: 18px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 25;
    background: rgba(30, 0, 30, 0.75);
    padding: 8px 12px;
    border-radius: 8px;
    border: 1px solid rgba(255,111,0,0.12);
    display: none;
    font-weight:600;
    color:#fff;
  }

  /* Tiny minimap placeholder */
  #minimap {
    position: absolute;
    right: 16px;
    top: 16px;
    width: 160px;
    height: 120px;
    background: rgba(0,0,0,0.4);
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.04);
    z-index: 20;
    pointer-events: none;
    font-size:12px;
    color:#ddd;
    padding:6px;
  }

  /* Small responsive */
  @media (max-width:600px){
    #enterHint { padding:10px 12px; font-size:14px; }
    #minimap { display:none; }
  }
</style>
</head>
<body>
<div id="container"></div>

<div class="hud panel" id="hud">
  <div id="pekepuntos">Pekepuntos: <span id="points">1000</span></div>
  <div id="info">Instrucciones: Mover <strong>W/A/S/D</strong>, mirar con rat√≥n. Presiona <strong>E</strong> para interactuar con m√°quinas.</div>
</div>

<div id="minimap" class="panel">Minimap (en desarrollo)</div>

<div id="enterHint" class="panel">Haz clic aqu√≠ para entrar al casino (activar control). Usa W/A/S/D para moverte.</div>
<div id="interactHint" class="panel">Presiona <strong>E</strong> para jugar a la m√°quina</div>

<script>
/* ---------------------------
   Casino 3D - Three.js Scene
   ---------------------------
   - Primera versi√≥n: recorrido navegable con m√°quinas y mesas
   - Controles: PointerLockControls (click + mouse)
   - Interacci√≥n b√°sica: E para jugar m√°quina si est√°s cerca
*/

// GLOBALS
let scene, camera, renderer, controls;
let clock = new THREE.Clock();
let mixers = [];
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let interactableObjects = []; // m√°quinas, mesas...
let activeMachine = null;
let pekepuntos = 1000; // valor inicial (puedes sincronizar con supabase)
const INTERACT_DISTANCE = 2.2;

// DOM
const container = document.getElementById('container');
const enterHint = document.getElementById('enterHint');
const interactHint = document.getElementById('interactHint');
const pointsLabel = document.getElementById('points');

// Basic init
function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0010);

  // Camera
  camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 200);
  camera.position.set(0, 1.6, 6); // altura ojos

  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);

  // Lights - ambiente + ne√≥n
  const ambient = new THREE.AmbientLight(0x404050, 0.8);
  scene.add(ambient);

  const keyLight = new THREE.DirectionalLight(0xffd6a5, 0.25);
  keyLight.position.set(5, 10, 7);
  scene.add(keyLight);

  // Two neon area lights (PointLights with small glowing planes)
  addNeon( -6, 2.8, -2, 0xff6f00, 1.6 ); // left
  addNeon( 6, 2.8, -2, 0xb517ff, 1.2 ); // right

  // Floor & room
  buildRoom();

  // Add objects: rows of slot machines + tables
  placeSlotsRow(-4, -6, 6); // row startX, z, count
  placeSlotsRow(4, -6, 6, true); // mirrored row
  placeTables();

  // Add some decorative neon signs
  addNeonSign(0, 3.6, -14, "CASINO", 0xff6f00);
  addNeonSign(0, 3.6, 14, "WELCOME", 0xb517ff);

  // Controls (PointerLock)
  controls = new THREE.PointerLockControls(camera, renderer.domElement);

  // Hookup pointer lock
  enterHint.addEventListener('click', () => {
    controls.lock();
  });

  controls.addEventListener('lock', () => {
    enterHint.style.display = 'none';
  });
  controls.addEventListener('unlock', () => {
    enterHint.style.display = 'block';
  });

  // Movement input
  setupMovement();

  // Resize
  window.addEventListener('resize', onWindowResize);

  // Interaction keys
  window.addEventListener('keydown', onKeyDown);

  // Start render loop
  animate();
}

/* ---------- ROOM & DECOR ---------- */
function buildRoom() {
  // Floor (textured with procedural checker)
  const floorSize = 80;
  const floorGeo = new THREE.PlaneGeometry(floorSize, floorSize, 4, 4);
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x0b0010, roughness: 0.9, metalness: 0.05 });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI/2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Add subtle reflective stripes on floor using planes with emissive
  for (let i=-3;i<=3;i++){
    const stripe = new THREE.Mesh(new THREE.PlaneGeometry(2, floorSize), new THREE.MeshBasicMaterial({ color:0x16000a, transparent:true, opacity:0.22 }));
    stripe.rotation.x = -Math.PI/2;
    stripe.position.set(i*2.5, 0.01, 0);
    scene.add(stripe);
  }

  // Walls
  const wallMat = new THREE.MeshStandardMaterial({ color: 0x0f0016, roughness:1 });
  const backWall = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, 12), wallMat);
  backWall.position.set(0,6,-floorSize/2 + 0.1);
  scene.add(backWall);
  const frontWall = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, 12), wallMat);
  frontWall.position.set(0,6,floorSize/2 - 0.1);
  frontWall.rotation.y = Math.PI;
  scene.add(frontWall);
  const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, 12), wallMat);
  leftWall.position.set(-floorSize/2 + 0.1,6,0);
  leftWall.rotation.y = Math.PI/2;
  scene.add(leftWall);
  const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, 12), wallMat);
  rightWall.position.set(floorSize/2 - 0.1,6,0);
  rightWall.rotation.y = -Math.PI/2;
  scene.add(rightWall);

  // Ceiling
  const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, floorSize), new THREE.MeshStandardMaterial({ color:0x050006 }));
  ceiling.position.set(0,12,0);
  ceiling.rotation.x = Math.PI/2;
  scene.add(ceiling);
}

// Add a neon light (point + thin glowing panel)
function addNeon(x,y,z,color,intensity=1.0){
  const p = new THREE.PointLight(color, intensity, 12);
  p.position.set(x,y,z);
  scene.add(p);
  // Add small glowing plane
  const plane = new THREE.Mesh(
    new THREE.PlaneGeometry(1.6, 0.4),
    new THREE.MeshBasicMaterial({ color: color, transparent:true, opacity:0.13 })
  );
  plane.position.set(x, y-0.4, z);
  plane.lookAt(0, y-0.4, z+1);
  scene.add(plane);
}

// Add text-like neon sign (simple boxes composing letters feel)
function addNeonSign(x,y,z,text,color=0xff6f00){
  const group = new THREE.Group();
  const spacing = 0.8;
  const geom = new THREE.BoxGeometry(0.6, 0.2, 0.08);
  for(let i=0;i<text.length;i++){
    const ch = text[i];
    const mat = new THREE.MeshBasicMaterial({ color: color, emissive: color, emissiveIntensity: 0.6 });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.set(x + (i - text.length/2) * spacing, y, z);
    group.add(mesh);
  }
  scene.add(group);
}

/* ---------- SLOTS & TABLES ---------- */

// Create a slot machine mesh (simple box with a "screen" canvas texture)
function createSlotMachine() {
  const group = new THREE.Group();

  // Body
  const bodyGeo = new THREE.BoxGeometry(1.2, 1.8, 0.9);
  const bodyMat = new THREE.MeshStandardMaterial({ color: 0x120016, metalness:0.2, roughness:0.5 });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 1.0;
  body.castShadow = true;
  group.add(body);

  // Screen using canvas texture (three reels)
  const canvas = document.createElement('canvas');
  canvas.width = 256; canvas.height = 256;
  const ctx = canvas.getContext('2d');
  drawSlotScreen(ctx, ["üçí","‚≠ê","7","üîî","üçã"], 0);
  const tex = new THREE.CanvasTexture(canvas);
  const screenGeo = new THREE.PlaneGeometry(0.88, 0.88);
  const screenMat = new THREE.MeshBasicMaterial({ map: tex });
  const screen = new THREE.Mesh(screenGeo, screenMat);
  screen.position.set(0, 1.05, 0.46);
  group.add(screen);

  // Lever (visual)
  const lever = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.7,8), new THREE.MeshStandardMaterial({ color:0xff6f00 }));
  lever.rotation.z = Math.PI/4;
  lever.position.set(0.6, 0.6, 0.46);
  group.add(lever);

  // Small neon trim
  const trim = new THREE.Mesh(new THREE.BoxGeometry(1.25, 0.06, 0.94), new THREE.MeshBasicMaterial({ color:0xff6f00, transparent:true, opacity:0.05 }));
  trim.position.set(0,1.9,0);
  group.add(trim);

  // store metadata
  group.userData = {
    type: 'slot',
    screenCanvas: canvas,
    screenCtx: ctx,
    screenTexture: tex,
    spinning: false,
    reels: ["üçí","‚≠ê","7","üîî","üçã"]
  };

  return group;
}

// Draw slot "screen" on canvas context (reelSymbols array and centerIndex)
function drawSlotScreen(ctx, reelSymbols, centerIndex){
  ctx.clearRect(0,0,256,256);
  ctx.fillStyle = '#040004';
  ctx.fillRect(0,0,256,256);

  // draw three vertical slots
  ctx.textAlign = 'center';
  ctx.font = '48px serif';
  for(let col=0;col<3;col++){
    const symbol = reelSymbols[(centerIndex + col) % reelSymbols.length];
    ctx.fillStyle = '#fff';
    ctx.fillText(symbol, 42 + col*85, 130);
  }

  // decorative glow
  ctx.strokeStyle = 'rgba(255,111,0,0.25)';
  ctx.lineWidth = 6;
  ctx.strokeRect(8,8,240,240);
}

// Place a row of slot machines
function placeSlotsRow(startX, z, count, mirrored=false) {
  const gap = 1.8;
  for (let i=0;i<count;i++){
    const x = startX + (mirrored ? -i*gap : i*gap);
    const slot = createSlotMachine();
    slot.position.set(x, 0, z);
    slot.rotation.y = mirrored ? Math.PI/2 : -Math.PI/2;
    scene.add(slot);
    interactableObjects.push(slot);
  }
}

// Create simple tables (cylinder top + legs)
function createTable() {
  const g = new THREE.Group();
  const top = new THREE.Mesh(new THREE.CylinderGeometry(1.8,1.8,0.12,24), new THREE.MeshStandardMaterial({ color:0x07121a }));
  top.position.y = 0.9;
  g.add(top);
  const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,0.9,12), new THREE.MeshStandardMaterial({ color:0x2b0a2b }));
  leg.position.y = 0.45;
  g.add(leg);
  return g;
}

// Place tables in center area
function placeTables() {
  const positions = [
    {x:0, z:-4}, {x:-3.6, z:0}, {x:3.6, z:0}
  ];
  positions.forEach(p=>{
    const table = createTable();
    table.position.set(p.x,0,p.z);
    scene.add(table);
    // NOT interactable for now, but could be added
  });
}

/* ---------- MOVEMENT / CONTROLS ---------- */
const moveState = { forward:false, backward:false, left:false, right:false };
let velocity = new THREE.Vector3();

function setupMovement(){
  document.addEventListener('keydown', (e) => {
    if (e.code === 'KeyW') moveState.forward = true;
    if (e.code === 'KeyS') moveState.backward = true;
    if (e.code === 'KeyA') moveState.left = true;
    if (e.code === 'KeyD') moveState.right = true;
  });
  document.addEventListener('keyup', (e) => {
    if (e.code === 'KeyW') moveState.forward = false;
    if (e.code === 'KeyS') moveState.backward = false;
    if (e.code === 'KeyA') moveState.left = false;
    if (e.code === 'KeyD') moveState.right = false;
  });
}

/* ---------- INTERACTION ---------- */
function onKeyDown(e){
  // Interact
  if (e.key.toLowerCase() === 'e') {
    attemptInteract();
  }
}

// Raycast from camera to detect nearest interactable within distance
function findNearbyInteractable(){
  const camPos = controls.getObject().position;
  let nearest = null;
  let minD = Infinity;
  interactableObjects.forEach(obj => {
    const d = camPos.distanceTo(obj.position);
    if (d < INTERACT_DISTANCE && d < minD) {
      nearest = obj;
      minD = d;
    }
  });
  return nearest;
}

function attemptInteract(){
  const near = findNearbyInteractable();
  if (!near) return;
  if (near.userData.type === 'slot') {
    playSlotMachine(near);
  }
}

// Play slot machine: simple spin animation + random result awarding points
function playSlotMachine(slot) {
  if (slot.userData.spinning) return; // already spinning
  slot.userData.spinning = true;

  const canvas = slot.userData.screenCanvas;
  const ctx = slot.userData.screenCtx;
  const tex = slot.userData.screenTexture;
  const reels = slot.userData.reels;

  // simulate fast reel changes for 1.6s, then stop and pick result
  let elapsed = 0;
  const duration = 1.6;
  const frameRate = 40;

  const spinInterval = setInterval(()=> {
    // random center index for visuals
    const center = Math.floor(Math.random()*reels.length);
    drawSlotScreen(ctx, reels, center);
    tex.needsUpdate = true;
  }, 1000/frameRate);

  setTimeout(()=>{
    clearInterval(spinInterval);
    // determine final result (simple random)
    const resultIndex = Math.floor(Math.random()*reels.length);
    drawSlotScreen(ctx, reels, resultIndex);
    tex.needsUpdate = true;
    slot.userData.spinning = false;

    // Award points based on symbol (simple rules)
    const symbol = reels[resultIndex];
    let award = 0;
    if (symbol === '7') award = 400;
    else if (symbol === '‚≠ê') award = 150;
    else if (symbol === 'üîî') award = 100;
    else if (symbol === 'üçí') award = 60;
    else if (symbol === 'üçã') award = 30;
    else award = 10;

    // small chance for jackpot (bonus)
    if (Math.random() < 0.06) { award *= 3; showFloatingText(slot.position, "JACKPOT! x3"); }

    pekepuntos += award;
    updatePointsUI();
    showFloatingText(slot.position, `+${award} Pts`);
  }, duration*1000);
}

// Floating text (3D) to show points gained
function showFloatingText(position, text) {
  const sprite = makeTextSprite(text, { fontsize: 26, textColor: {r:255,g:255,b:255,a:1}, borderColor: {r:255,g:111,b:0,a:0.6} });
  sprite.position.set(position.x, position.y + 2.0, position.z);
  scene.add(sprite);
  // animate up + fade
  const start = performance.now();
  const lifetime = 1400;
  function floatAnim(t){
    const dt = t - start;
    const p = dt / lifetime;
    sprite.position.y = position.y + 2.0 + p*0.8;
    sprite.scale.setScalar(1 - p*0.6);
    if (p < 1) requestAnimationFrame(floatAnim);
    else scene.remove(sprite);
  }
  requestAnimationFrame(floatAnim);
}

// Simple sprite-maker from text using canvas
function makeTextSprite(message, parameters) {
  if (parameters === undefined) parameters = {};
  const fontsize = parameters.fontsize || 18;
  const padding = 8;
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.font = `${fontsize}px Arial`;
  const metrics = ctx.measureText(message);
  const textWidth = metrics.width;
  canvas.width = textWidth + padding*2;
  canvas.height = fontsize + padding*2;
  // background
  ctx.fillStyle = 'rgba(10,6,15,0.85)';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  // text
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = `${fontsize}px Arial`;
  ctx.fillText(message, canvas.width/2, canvas.height/2);
  const texture = new THREE.CanvasTexture(canvas);
  const mat = new THREE.SpriteMaterial({ map: texture, transparent: true });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(1.6, 0.6, 1);
  return sprite;
}

/* ---------- UI & HELPERS ---------- */
function updatePointsUI(){
  pointsLabel.textContent = pekepuntos.toLocaleString();
}

/* ---------- ANIMATE / LOOP ---------- */
function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  // Movement physics
  if (controls.isLocked === true) {
    // simple acceleration
    const speed = 4.2; // m/s
    const damping = 10.0;
    const forward = (moveState.forward ? 1 : 0) - (moveState.backward ? 1 : 0);
    const strafe = (moveState.right ? 1 : 0) - (moveState.left ? 1 : 0);

    // apply local forward/strafe
    const dir = new THREE.Vector3();
    controls.getDirection(dir);
    dir.y = 0; dir.normalize();
    const right = new THREE.Vector3();
    right.crossVectors(camera.up, dir).normalize();

    // velocity change
    velocity.add(dir.clone().multiplyScalar(forward * speed * dt));
    velocity.add(right.clone().multiplyScalar(strafe * speed * dt));

    // damping
    velocity.multiplyScalar(1 - Math.min(damping * dt, 0.9));

    // move the camera
    controls.getObject().position.add(velocity.clone().multiplyScalar(dt));

    // keep y constant (no flying)
    controls.getObject().position.y = 1.6;
  }

  // Show interact hint if near a machine
  const near = findNearbyInteractable();
  if (near) {
    interactHint.style.display = 'block';
    activeMachine = near;
  } else {
    interactHint.style.display = 'none';
    activeMachine = null;
  }

  // Update mixers if animations added later
  if (mixers.length) {
    mixers.forEach(m => m.update(dt));
  }

  renderer.render(scene, camera);
}

/* ---------- UTIL ---------- */
function onWindowResize(){
  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
}

init();
updatePointsUI();
</script>
</body>
</html>
