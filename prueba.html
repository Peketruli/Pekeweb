<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Casino 3D</title>
<style>
  :root{--bg:#0b0f1a;--panel:#101625;--accent:#f5b642;--muted:#9aa5b1}
  html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:white;overflow:hidden}
  #container{width:100%;height:100%}
  #ui{position:absolute;top:12px;left:12px;z-index:50}
  .panel{background:rgba(0,0,0,0.45);padding:10px;border-radius:8px;margin-bottom:8px;backdrop-filter:blur(4px)}
  #modal{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    width:460px;max-width:95vw;background:var(--panel);padding:18px;border-radius:12px;
    display:none;z-index:100;max-height:80vh;overflow:auto;box-shadow:0 8px 30px rgba(0,0,0,0.6)
  }
  #npcMsg{position:absolute;bottom:12px;left:50%;transform:translateX(-50%);
    background:rgba(0,0,0,0.6);padding:8px 12px;border-radius:8px;display:none}
  button,input,select{background:#182034;color:white;border:1px solid #334;padding:8px;border-radius:8px;margin:6px 0;cursor:pointer}
  .gameUI h2{margin:4px 0 10px 0;text-align:center}
  .gameUI{display:flex;flex-direction:column;align-items:center}
  .gameUI .row{width:100%;display:flex;gap:8px;justify-content:center}
  .gameResult{margin-top:10px;color:var(--accent);min-height:30px;text-align:center}
  label{font-size:0.95rem}
  input[type=number]{width:100px;padding:6px;border-radius:6px}
  .small{font-size:0.85rem;color:#c3cbd2}
</style>
</head>
<body>
<div id="container"></div>

<div id="ui" class="panel">
  <div>Pekepuntos: <strong id="balance">0</strong></div>
  <div class="small">Pulsa <b>E</b> para interactuar â€” mueve con WASD y rota con flechas</div>
</div>

<div id="modal" role="dialog" aria-modal="true"></div>
<div id="npcMsg">Pulsa E para recoger fichas diarias</div>

<!-- three.js -->
<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>

<script>

(async function(){

const SUPABASE_URL = 'https://jdvwlfogkzrzovepzjqa.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpkdndsZm9na3pyem92ZXB6anFhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwMzY1MjEsImV4cCI6MjA3MzYxMjUyMX0.IwVFrvuluY0tfgE82XnqYSsRjFPsDYnlfyirHjKu1TI';

let supabase = null;
async function loadSupabase(){
  if(window.supabase && typeof window.supabase.createClient === 'function'){
    try { supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY); return; } catch(e){}
  }
  try {
    await new Promise((res, rej) => {
      const s = document.createElement('script');
      s.src = 'https://unpkg.com/@supabase/supabase-js/dist/umd/supabase.min.js';
      s.onload = () => res();
      s.onerror = () => rej(new Error('No se pudo cargar supabase'));
      document.head.appendChild(s);
    });
    if(window.supabase && typeof window.supabase.createClient === 'function'){
      supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    }
  } catch(err){
    console.warn('Supabase no disponible (posiblemente bloqueado):', err);
    supabase = null;
  }
}
await loadSupabase();

/* ---------------------
   DOM refs + user init
   --------------------- */
const balanceEl = document.getElementById('balance');
const modalEl = document.getElementById('modal');
const container = document.getElementById('container');
const npcMsgEl = document.getElementById('npcMsg');

let currentUser = null;
try { currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null'); } catch(e){ currentUser = null; }
if(!currentUser){
  currentUser = { id: 1, username: 'Guest', pekepuntos: 1000, last_claim: null };
  localStorage.setItem('currentUser', JSON.stringify(currentUser));
}
let balance = Number(currentUser.pekepuntos || 0);
function refreshBalanceUI(){ balanceEl.textContent = Number(balance).toLocaleString(); }

// centralizado: guarda local + supabase
async function saveUser(balanceUpdate = true){
  if(balanceUpdate) currentUser.pekepuntos = balance;
  localStorage.setItem('currentUser', JSON.stringify(currentUser));
  refreshBalanceUI();

  if(supabase){
    try {
      await supabase.from('usuarios')
        .update({ pekepuntos: currentUser.pekepuntos, last_claim: currentUser.last_claim || null })
        .eq('id', currentUser.id);
      updateTop10();
    } catch(e){
      console.warn('Supabase save error:', e);
    }
  }
}

refreshBalanceUI();

/* ---------------------
   Helpers
   --------------------- */
const rand = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
const clamp = (v,a,b) => Math.max(a,Math.min(b,v));

/* ---------------------
   THREE scene setup
   --------------------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0f1a);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,1.6,5);
camera.rotation.order = 'YXZ';

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
try { renderer.outputColorSpace = THREE.SRGBColorSpace; } catch(e){}
container.appendChild(renderer.domElement);

const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.8); hemi.position.set(0,50,0); scene.add(hemi);
scene.add(new THREE.AmbientLight(0xffffff, 0.22));
const dir = new THREE.DirectionalLight(0xfff6d6, 0.6); dir.position.set(5,10,5); dir.castShadow = true; scene.add(dir);

/* ---------------------
   Canvas textures
   --------------------- */
function canvasTexture(size, drawFn){
  const c = document.createElement('canvas'); c.width = c.height = size;
  const ctx = c.getContext('2d');
  drawFn(ctx, size);
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.anisotropy = 4;
  tex.needsUpdate = true;
  return tex;
}

/* floor */
const floorTex = canvasTexture(1024, (ctx,s) => {
  ctx.fillStyle = '#1b0022'; ctx.fillRect(0,0,s,s);
  const grd = ctx.createLinearGradient(0,0,s,s); grd.addColorStop(0,'#22001f'); grd.addColorStop(1,'#0e0010');
  ctx.fillStyle = grd; ctx.globalAlpha = 0.7; ctx.fillRect(0,0,s,s); ctx.globalAlpha = 1;
  ctx.strokeStyle = 'rgba(255,255,255,0.02)'; ctx.lineWidth = 2;
  for(let i=0;i<s;i+=64){ ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,s); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(s,i); ctx.stroke(); }
});

/* walls */
const marbleTex = canvasTexture(1024, (ctx,s) => {
  ctx.fillStyle = '#222428'; ctx.fillRect(0,0,s,s);
  for(let i=0;i<300;i++){
    ctx.strokeStyle = `rgba(255,255,255,${0.02+Math.random()*0.03})`;
    ctx.beginPath();
    ctx.moveTo(Math.random()*s, Math.random()*s);
    ctx.quadraticCurveTo(Math.random()*s, Math.random()*s, Math.random()*s, Math.random()*s);
    ctx.stroke();
  }
});

/* blackjack */
const blackjackTex = canvasTexture(512, (ctx,s)=>{
  ctx.fillStyle = '#084b2f'; ctx.fillRect(0,0,s,s);
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  for(let i=0;i<200;i++) ctx.fillRect(Math.random()*s, Math.random()*s, 1, 1);
  ctx.strokeStyle = '#f2e7c9'; ctx.lineWidth = Math.max(1, s/160); ctx.strokeRect(6, s-120, s-12, 108);
  ctx.fillStyle = '#fff'; ctx.font = '18px Arial'; ctx.textAlign = 'center';
  ctx.fillText('BLACKJACK PAYS 3 TO 2', s/2, 26);
});

/* slot screen */
const slotScreenTex = canvasTexture(512, (ctx,s)=>{
  ctx.fillStyle = '#05050b'; ctx.fillRect(0,0,s,s);
  const g = ctx.createLinearGradient(0,0,s,0); g.addColorStop(0,'rgba(255,255,255,0.02)'); g.addColorStop(1,'rgba(0,0,0,0.15)');
  ctx.fillStyle = g; ctx.fillRect(0,0,s,s);
});

/* metal */
const metalTex = canvasTexture(256, (ctx,s)=>{ const g = ctx.createLinearGradient(0,0,s,s); g.addColorStop(0,'#777'); g.addColorStop(1,'#bcbcbc'); ctx.fillStyle=g; ctx.fillRect(0,0,s,s); });

/* ---------------------
   Room
   --------------------- */
const floorMat = new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.95, metalness: 0.02 });
const floor = new THREE.Mesh(new THREE.PlaneGeometry(30,30), floorMat);
floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

const wallMat = new THREE.MeshStandardMaterial({ map: marbleTex, roughness: 0.9 });
function makeWall(x,z,rotY=0){
  const wall = new THREE.Mesh(new THREE.BoxGeometry(30,6,0.2), wallMat);
  wall.position.set(x,3,z); wall.rotation.y = rotY; wall.receiveShadow = true; scene.add(wall);
}
makeWall(0,-15); makeWall(0,15,Math.PI); makeWall(-15,0,Math.PI/2); makeWall(15,0,-Math.PI/2);

/* ---------------------
   TOP 10 wall
   --------------------- */
let top10UpdateTimer = null;
async function updateTop10(){
  let rows=[];
  if(supabase){
    try{
      const { data,error } = await supabase.from('usuarios').select('username, pekepuntos').order('pekepuntos',{ascending:false}).limit(10);
      if(!error && data) rows=data;
    } catch(e){ console.warn('top10 supabase error',e);}
  }
  if(!rows.length) rows=[{username:currentUser.username, pekepuntos:currentUser.pekepuntos}];
  const s=1024;
  const tex=canvasTexture(s,(ctx)=>{
    ctx.fillStyle='#071018'; ctx.fillRect(0,0,s,s);
    ctx.fillStyle='#f5b642'; ctx.font='48px Arial'; ctx.textAlign='center'; ctx.fillText('TOP 10',s/2,70);
    ctx.font='28px Arial'; ctx.textAlign='left'; ctx.fillStyle='#fff';
    rows.forEach((r,i)=>{ const y=130+i*70; ctx.fillText(`${i+1}. ${r.username}`,60,y); ctx.fillText((r.pekepuntos||0).toLocaleString(),s-140,y); });
  });
  const name='top10Wall';
  const existing=scene.getObjectByName(name);
  if(!existing){
    const wall=new THREE.Mesh(new THREE.PlaneGeometry(8,5),new THREE.MeshStandardMaterial({ map:tex, side:THREE.DoubleSide }));
    wall.position.set(0,2,-14.9); wall.name=name; scene.add(wall);
  } else { existing.material.map=tex; existing.material.needsUpdate=true; }
}
await updateTop10(); setInterval(updateTop10,60000);

/* ---------------------
   Objects & interactables
   --------------------- */
const interactables = [];

/* Blackjack table */
const bjMat = new THREE.MeshStandardMaterial({ map: blackjackTex, roughness: 0.6, metalness: 0.02 });
const bjTable = new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.6,0.3,64), bjMat);
bjTable.position.set(-4,0.3,0); bjTable.userData.type='blackjack'; bjTable.castShadow=true; bjTable.receiveShadow=true;
scene.add(bjTable); interactables.push(bjTable);

/* Roulette */
const ruletaBase = new THREE.Mesh(new THREE.CylinderGeometry(1.2,1.2,0.4,64), new THREE.MeshStandardMaterial({ color:0x222222, metalness:0.45, roughness:0.25 }));
ruletaBase.position.set(0,0.2,0); ruletaBase.userData.type='roulette'; ruletaBase.castShadow=true; ruletaBase.receiveShadow=true;
scene.add(ruletaBase); interactables.push(ruletaBase);

const ruletaDisk = new THREE.Mesh(new THREE.CylinderGeometry(1.15,1.15,0.08,256), new THREE.MeshStandardMaterial({ map: null, metalness:0.25, roughness:0.45 }));
ruletaDisk.rotation.x = Math.PI;
ruletaDisk.position.set(0,0.45,0); ruletaDisk.castShadow=true; ruletaDisk.receiveShadow=true;
scene.add(ruletaDisk);

/* ---------------------
   Canvas roulette numbers
   --------------------- */
(function createRouletteTexture(){
  const s = 2048;
  const canv = document.createElement('canvas'); canv.width = canv.height = s;
  const ctx = canv.getContext('2d');
  ctx.translate(s/2, s/2);
  const cellCount = 37;
  const anglePer = (Math.PI*2)/cellCount;
  ctx.fillStyle = '#2f1b10'; ctx.beginPath(); ctx.arc(0,0,s/2,0,Math.PI*2); ctx.fill();
  const redSet = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
  for(let i=0;i<cellCount;i++){
    const start = i*anglePer - Math.PI/2;
    const end = start + anglePer;
    const isZero = (i===0);
    ctx.beginPath();
    ctx.fillStyle = isZero ? '#0b8a12' : (redSet.has(i) ? '#d22' : '#111');
    ctx.moveTo(0,0); ctx.arc(0,0,s*0.48,start,end); ctx.closePath(); ctx.fill();
    ctx.save();
    ctx.rotate(start + anglePer/2);
    ctx.fillStyle = '#fff';
    ctx.font = `${s*0.05}px Arial`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(i.toString(), 0, -s*0.35);
    ctx.restore();
  }
  ctx.beginPath(); ctx.fillStyle='#8b5a2b'; ctx.arc(0,0,s*0.18,0,Math.PI*2); ctx.fill();
  const tex = new THREE.CanvasTexture(canv); tex.needsUpdate = true;
  tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
  ruletaDisk.material.map = tex; ruletaDisk.material.needsUpdate = true;
})();

/* ---------------------
   Slots & NPC (igual)
   --------------------- */
const slotScreenTex2 = slotScreenTex; // reuse
function createSlotMachine(){
  const g = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(1.1,2.1,1.0), new THREE.MeshStandardMaterial({ color:0x222222, metalness:0.6, roughness:0.25 }));
  body.position.y = 1.05; g.add(body);
  const screen = new THREE.Mesh(new THREE.PlaneGeometry(0.7,0.45), new THREE.MeshStandardMaterial({ map: slotScreenTex2, emissive: 0x111111, emissiveIntensity: 0.9 }));
  screen.position.set(0,1.4,0.51); g.add(screen);
  const lever = new THREE.Mesh(new THREE.CylinderGeometry(0.04,0.04,0.9,12), new THREE.MeshStandardMaterial({ color:0xaa3333, metalness:0.4, roughness:0.4 }));
  lever.rotation.z = -Math.PI/2; lever.position.set(0.6,1.1,0); g.add(lever);
  const coin = new THREE.Mesh(new THREE.TorusGeometry(0.12, 0.03, 12, 24), new THREE.MeshStandardMaterial({ color:0xffdd66, metalness:0.9, roughness:0.2 }));
  coin.position.set(0.95,1.1,0); g.add(coin);
  return g;
}
const slotMachine = createSlotMachine(); slotMachine.position.set(4,0,0); scene.add(slotMachine);
const slotProxy = new THREE.Mesh(new THREE.BoxGeometry(1.05,2.05,1.05), new THREE.MeshBasicMaterial({ visible:false }));
slotProxy.position.copy(slotMachine.position); slotProxy.position.y = 1; slotProxy.userData.type = 'slots';
scene.add(slotProxy); interactables.push(slotProxy);

/* NPC */
const npc = new THREE.Mesh(new THREE.CylinderGeometry(0.42,0.42,1.6,16), new THREE.MeshStandardMaterial({ color:0xdddddd, metalness:0.7, roughness:0.25, map: metalTex }));
npc.position.set(0,1,5); npc.userData.type = 'npc'; npc.castShadow = true; scene.add(npc); interactables.push(npc);

/* ---------------------
   Movement
   --------------------- */
const keys = {};
document.addEventListener('keydown', e => { keys[e.code] = true; });
document.addEventListener('keyup', e => { keys[e.code] = false; });

let yaw = 0, pitch = 0;
function updateCamera(dt){
  const yawSpeed = 1.8, pitchSpeed = 1.2;
  if(keys['ArrowLeft']) yaw += yawSpeed * dt;
  if(keys['ArrowRight']) yaw -= yawSpeed * dt;
  if(keys['ArrowUp']) pitch += pitchSpeed * dt;
  if(keys['ArrowDown']) pitch -= pitchSpeed * dt;
  const limit = Math.PI/2 - 0.05;
  pitch = clamp(pitch, -limit, limit);
  camera.rotation.set(pitch, yaw, 0);

  const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
  const right = new THREE.Vector3(); right.crossVectors(forward, camera.up).normalize();
  const move = new THREE.Vector3();
  if(keys['KeyW']) move.add(forward);
  if(keys['KeyS']) move.sub(forward);
  if(keys['KeyD']) move.add(right);
  if(keys['KeyA']) move.sub(right);
  move.multiplyScalar(3 * dt);
  camera.position.add(move);
}

/* ---------------------
   Interactions
   --------------------- */
const ray = new THREE.Raycaster();
function checkInteractions(){
  ray.setFromCamera(new THREE.Vector2(0,0), camera);
  const intersects = ray.intersectObjects(interactables, true);
  if(intersects.length>0){
    const obj = intersects[0].object;
    const type = obj.userData.type;
    if(type==='npc'){ npcMsgEl.textContent='Habla con el NPC para Daily'; }
    else if(type==='blackjack'){ npcMsgEl.textContent='Blackjack disponible'; }
    else if(type==='roulette'){ npcMsgEl.textContent='Ruleta lista'; }
    else if(type==='slots'){ npcMsgEl.textContent='Slots disponibles'; }
  } else { npcMsgEl.textContent=''; }
}

/* ---------------------
   Daily claim
   --------------------- */
async function claimDaily(){
  const now = new Date();
  if(currentUser.last_claim){
    const last = new Date(currentUser.last_claim);
    const diff = now - last;
    if(diff < 24*3600*1000){ npcMsgEl.textContent='Ya reclamaste hoy'; return; }
  }
  balance += 100;
  currentUser.last_claim = now.toISOString();
  await saveUser();
  npcMsgEl.textContent='Daily reclamado +100';
}

/* ---------------------
   Blackjack
   --------------------- */
async function playBlackjack(){
  const won = Math.random() < 0.5;
  const change = won ? rand(50,150) : -rand(30,100);
  balance += change;
  await saveUser();
  npcMsgEl.textContent = `Blackjack ${won?'GANASTE':'PERDISTE'} ${change>0?'+':''}${change}`;
}

/* Roulette */
async function playRoulette(){
  const choice = rand(0,36);
  const won = Math.random()<0.5;
  const change = won ? rand(50,200) : -rand(30,120);
  balance += change;
  await saveUser();
  npcMsgEl.textContent = `Ruleta ${won?'GANASTE':'PERDISTE'} ${change>0?'+':''}${change}`;
}

/* Slots */
async function playSlots(){
  const won = Math.random()<0.4;
  const change = won ? rand(30,120) : -rand(20,80);
  balance += change;
  await saveUser();
  npcMsgEl.textContent = `Slots ${won?'GANASTE':'PERDISTE'} ${change>0?'+':''}${change}`;
}

/* ---------------------
   Mouse / click
   --------------------- */
document.addEventListener('click', async e=>{
  ray.setFromCamera(new THREE.Vector2(0,0), camera);
  const intersects = ray.intersectObjects(interactables, true);
  if(intersects.length===0) return;
  const obj = intersects[0].object;
  const type = obj.userData.type;
  if(type==='npc') await claimDaily();
  else if(type==='blackjack') await playBlackjack();
  else if(type==='roulette') await playRoulette();
  else if(type==='slots') await playSlots();
});

/* ---------------------
   Animation
   --------------------- */
let last = performance.now();
function animate(){
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt = (now-last)/1000;
  last = now;
  updateCamera(dt);
  checkInteractions();
  renderer.render(scene,camera);
}
animate();

})();
</script>
</body>
</html>
