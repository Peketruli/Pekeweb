<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Casino 3D - Ruleta y Mesas</title>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<style>
body { margin:0; overflow:hidden; background:#000; font-family:Arial, Helvetica, sans-serif; }
#hint { position:absolute; left:12px; top:12px; z-index:5; background:rgba(0,0,0,0.6); color:#fff; padding:8px 10px; border-radius:8px; font-size:13px; }
#credits { position:absolute; right:12px; top:12px; z-index:5; background:rgba(0,0,0,0.45); color:#ddd; padding:6px 8px; border-radius:6px; font-size:12px; }
</style>
</head>
<body>
<div id="hint">🎰 Mover: W A S D — Mirar: ratón</div>
<div id="credits">Casino clásico — texturas libres (online)</div>

<script>
// ---------- Escena ----------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020); // gris oscuro para que todo se vea
scene.fog = new THREE.FogExp2(0x202020,0.02);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 1.7, 10);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// ---------- Suelo con alfombra mejorada ----------
const carpetTex = loader.load('https://cdn.pixabay.com/photo/2016/11/21/15/55/pattern-1846866_1280.jpg'); // textura de alfombra
carpetTex.wrapS = carpetTex.wrapT = THREE.RepeatWrapping;
carpetTex.repeat.set(10, 10);
carpetTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
carpetTex.colorSpace = THREE.SRGBColorSpace;

// mapa de relieve para simular textura 3D
const carpetBump = loader.load('https://cdn.pixabay.com/photo/2016/11/21/15/55/pattern-1846866_1280.jpg');
carpetBump.wrapS = carpetBump.wrapT = THREE.RepeatWrapping;
carpetBump.repeat.set(10, 10);

const floorMat = new THREE.MeshStandardMaterial({
  map: carpetTex,
  bumpMap: carpetBump,
  bumpScale: 0.05,
  roughness: 0.8,
  metalness: 0.2,
});

const floor = new THREE.Mesh(new THREE.PlaneGeometry(80, 80), floorMat);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

// ---------- Paredes con mármol brillante ----------
const marbleTex = loader.load('https://cdn.pixabay.com/photo/2017/06/21/07/30/marble-2426312_1280.jpg');
marbleTex.wrapS = marbleTex.wrapT = THREE.RepeatWrapping;
marbleTex.repeat.set(6, 3);
marbleTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
marbleTex.colorSpace = THREE.SRGBColorSpace;

// mapa de reflejo
const marbleBump = loader.load('https://cdn.pixabay.com/photo/2017/06/21/07/30/marble-2426312_1280.jpg');
marbleBump.wrapS = marbleBump.wrapT = THREE.RepeatWrapping;
marbleBump.repeat.set(6, 3);

const wallMat = new THREE.MeshStandardMaterial({
  map: marbleTex,
  bumpMap: marbleBump,
  bumpScale: 0.1,
  roughness: 0.4,
  metalness: 0.4,
  envMapIntensity: 0.5,
});

// Crear las paredes
const backWall = new THREE.Mesh(new THREE.BoxGeometry(80, 10, 0.8), wallMat);
backWall.position.set(0, 5, -40);
scene.add(backWall);

const frontWall = backWall.clone();
frontWall.position.set(0, 5, 40);
scene.add(frontWall);

const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.8, 10, 80), wallMat);
leftWall.position.set(-40, 5, 0);
scene.add(leftWall);

const rightWall = leftWall.clone();
rightWall.position.set(40, 5, 0);
scene.add(rightWall);

// ---------- Iluminación ambiental suave ----------
const fillLight = new THREE.PointLight(0xffcc88, 0.6, 100);
fillLight.position.set(0, 5, -15);
scene.add(fillLight);

const rimLight = new THREE.PointLight(0x88bbff, 0.4, 100);
rimLight.position.set(0, 5, 15);
scene.add(rimLight);

// -------------------- Mesa de blackjack mejorada (alineada) --------------------
const tableGroup = new THREE.Group();

// Tapete con textura verde y degradado
function createFeltTexture(){
  const c = document.createElement('canvas'); c.width=c.height=512;
  const ctx = c.getContext('2d');
  const grad = ctx.createLinearGradient(0,0,512,512);
  grad.addColorStop(0,'#0b5b35');
  grad.addColorStop(1,'#0e7041');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,512,512);

  // Borde sutil dorado
  ctx.strokeStyle = '#ffd27f';
  ctx.lineWidth = 12;
  ctx.strokeRect(0,0,512,512);

  // Líneas de apuestas (simplificado)
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  for(let i=1;i<=3;i++){
    ctx.beginPath();
    ctx.moveTo(0, i*128);
    ctx.lineTo(512, i*128);
    ctx.stroke();
  }

  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(1,1);
  return tex;
}
const feltTex2 = createFeltTexture();

// Tablero principal
const tableTop = new THREE.Mesh(
  new THREE.CylinderGeometry(4.2,4.2,0.3,32),
  new THREE.MeshStandardMaterial({ map: feltTex2, roughness:0.7, metalness:0.05 })
);
tableTop.position.y = 0.6;
tableTop.castShadow = true;
tableTop.receiveShadow = true;
tableGroup.add(tableTop);

// Borde de madera
const rim = new THREE.Mesh(
  new THREE.TorusGeometry(4.35,0.25,16,100),
  new THREE.MeshStandardMaterial({ color:0x4a2b12, metalness:0.2, roughness:0.5 })
);
rim.rotation.x = Math.PI/2;
rim.position.y = 0.75;
rim.castShadow = true;
tableGroup.add(rim);

// Sillas mejor alineadas (más cerca del borde y a altura correcta)
const numSillas = 6;
for(let i=0;i<numSillas;i++){
  const angle = (i/numSillas) * Math.PI * 1.2 - Math.PI/2.4; // solo en semicírculo frontal
  const radius = 4.9; // más cerca de la mesa
  const sx = Math.sin(angle) * radius;
  const sz = Math.cos(angle) * radius;

  // Asiento
  const seat = new THREE.Mesh(
    new THREE.CylinderGeometry(0.35,0.35,0.3,16),
    new THREE.MeshStandardMaterial({ color:0x2b1508, roughness:0.6, metalness:0.1 })
  );
  seat.position.set(sx, 0.3, sz);
  seat.castShadow = true;
  tableGroup.add(seat);

  // Respaldo
  const back = new THREE.Mesh(
    new THREE.BoxGeometry(0.4,0.7,0.05),
    new THREE.MeshStandardMaterial({ color:0x2b1508, roughness:0.6, metalness:0.1 })
  );
  back.position.set(sx, 0.65, sz - 0.25);
  back.rotation.y = angle; // que mire hacia el centro
  tableGroup.add(back);
}

tableGroup.position.set(0,0,0);
scene.add(tableGroup);

  
// ---------- Ruleta horizontal con textura visible ----------
const wheelGroup = new THREE.Group();

// Base de la ruleta (madera)
const wheelBase = new THREE.Mesh(
  new THREE.CylinderGeometry(2.2, 2.2, 0.4, 48),
  new THREE.MeshStandardMaterial({ color: 0x2f1608, metalness: 0.6, roughness: 0.4 })
);
wheelBase.position.y = 0.3; // altura sobre la mesa
wheelGroup.add(wheelBase);

// Plato de la ruleta (textura visible en la parte superior)
const wheelCanvas = document.createElement('canvas');
wheelCanvas.width = wheelCanvas.height = 1024;
const ctx = wheelCanvas.getContext('2d');
const size = 1024, cx = size/2, cy = size/2, r = size*0.42;

// Fondo y segmentos rojo/negro
ctx.fillStyle = '#3b2b20';
ctx.fillRect(0,0,size,size);
for(let i=0;i<18;i++){
  ctx.beginPath();
  const start = (i/18)*Math.PI*2;
  const end = ((i+1)/18)*Math.PI*2;
  ctx.moveTo(cx,cy); ctx.arc(cx,cy,r,start,end);
  ctx.closePath();
  ctx.fillStyle = (i%2===0)?'#9b0000':'#000000';
  ctx.fill();
}

// Círculos interiores
ctx.beginPath(); ctx.fillStyle = '#222'; ctx.arc(cx,cy,r*0.55,0,Math.PI*2); ctx.fill();
ctx.beginPath(); ctx.fillStyle = '#d1c6b3'; ctx.arc(cx,cy,r*0.12,0,Math.PI*2); ctx.fill();

const wheelTex = new THREE.CanvasTexture(wheelCanvas);

// Crear cilindro fino solo para la “cara superior” con textura
const wheelPlate = new THREE.Mesh(
  new THREE.CylinderGeometry(1.9, 1.9, 0.05, 64, 1, false),
  new THREE.MeshStandardMaterial({ map: wheelTex })
);
wheelPlate.position.y = 0.55; // justo sobre la base
wheelGroup.add(wheelPlate);

// Borde de madera alrededor (opcional)
const rimMesh = new THREE.Mesh(
  new THREE.TorusGeometry(2.4, 0.18, 16, 100),
  new THREE.MeshStandardMaterial({ color: 0x8b4513, metalness: 0.3, roughness: 0.6 })
);
rimMesh.rotation.x = Math.PI/2;
rimMesh.position.y = 0.55; 
wheelGroup.add(rimMesh);

// Posición final sobre la mesa
wheelGroup.position.set(-10, 0.6, 8);
wheelGroup.castShadow = true;
scene.add(wheelGroup);

// Giro automático
function animateWheel(){
  wheelGroup.rotation.y += 0.02;
  requestAnimationFrame(animateWheel);
}
animateWheel();
  
// ---------- Movimiento cámara ----------
let yaw=0, pitch=0; const sens=0.0026;
window.addEventListener('mousemove',e=>{ yaw-=(e.movementX||0)*sens; pitch-=(e.movementY||0)*sens; const maxP=Math.PI/2-0.05; pitch=Math.max(-maxP,Math.min(maxP,pitch)); });
const keys={}; window.addEventListener('keydown',e=>keys[e.code]=true); window.addEventListener('keyup',e=>keys[e.code]=false);
const velocity=new THREE.Vector3(); const accel=20,damping=8;
const forward=new THREE.Vector3(); const right=new THREE.Vector3(); const up=new THREE.Vector3(0,1,0);
const clock=new THREE.Clock();

function updateMovement(dt){
  camera.rotation.set(pitch,yaw,0,"ZYX"); camera.updateMatrixWorld();
  camera.getWorldDirection(forward); forward.y=0; forward.normalize();
  right.copy(forward).cross(up).negate();
  let mx=0,mz=0; if(keys['KeyW']) mz+=1; if(keys['KeyS']) mz-=1; if(keys['KeyD']) mx-=1; if(keys['KeyA']) mx+=1;
  const dir=new THREE.Vector3(); dir.addScaledVector(forward,mz); dir.addScaledVector(right,mx); if(dir.lengthSq()>0) dir.normalize();
  velocity.addScaledVector(dir,accel*dt); velocity.multiplyScalar(1/(1+damping*dt));
  camera.position.addScaledVector(velocity,dt);
}

// ---------- Animación ----------
function animate(){
  requestAnimationFrame(animate);
  const dt=Math.min(clock.getDelta(),0.05);
  updateMovement(dt);
  wheelGroup.rotation.y+=0.02;
  renderer.render(scene,camera);
}
animate();

// ---------- Resize ----------
window.addEventListener('resize',()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });

</script>
</body>
</html>
