<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Casino 3D â€” Mejorado</title>
<style>
  :root{--bg:#0b0f1a;--panel:#101625;--accent:#f5b642;--muted:#9aa5b1}
  html,body{height:100%;margin:0;font-family:Arial;background:var(--bg);color:white;overflow:hidden}
  #container{width:100%;height:100%}
  #ui{position:absolute;top:10px;left:10px;z-index:5}
  .panel{background:rgba(0,0,0,0.4);padding:10px;border-radius:8px;margin-bottom:8px}
  #modal{position:absolute;right:20px;top:20px;width:380px;background:var(--panel);padding:14px;border-radius:12px;display:none;z-index:10;max-height:70vh;overflow:auto}
  #npcMsg{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.6);padding:10px;border-radius:8px;display:none}
  button,input,select{background:#182034;color:white;border:1px solid #334;padding:6px;border-radius:6px;margin:4px 0}
  .gameUI h2{margin:0 0 8px 0}
</style>
</head>
<body>
<div id="container"></div>
<div id="ui">
  <div class="panel">Saldo: <span id="balance">1000</span> â‚¬</div>
  <div class="panel">Pulsa <b>E</b> para interactuar</div>
</div>
<div id="modal"></div>
<div id="npcMsg">Pulsa E para recoger fichas diarias</div>

<script>
import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

// ---------- CONFIG SUPABASE ----------
const SUPABASE_URL = 'https://jdvwlfogkzrzovepzjqa.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpkdndsZm9na3pyem92ZXB6anFhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwMzY1MjEsImV4cCI6MjA3MzYxMjUyMX0.IwVFrvuluY0tfgE82XnqYSsRjFPsDYnlfyirHjKu1TI';
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

// ---------- DOM refs & helpers ----------
const modal = document.getElementById('modal');
const container = document.getElementById('container');
const npcMsg = document.getElementById('npcMsg');
const balanceEl = document.getElementById('balance');

function rand(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }
function isoDay(date = new Date()){ return date.toISOString().slice(0,10); }

// ---------- USER (from localStorage) ----------
let currentUser = null;
try { currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null'); }
catch(e){ currentUser = null; }

if(!currentUser){
  alert('Debes iniciar sesiÃ³n para acceder al casino (currentUser no encontrado).');
  // evitar romper la pÃ¡gina: mostramos 0 saldo y salimos.
  balanceEl.textContent = '0';
  throw new Error('Usuario no encontrado en localStorage');
}

let balance = Number(currentUser.pekepuntos || 0);
let lastDaily = currentUser.last_claim ? currentUser.last_claim.slice(0,10) : null;

// carga del balance real desde Supabase (por si hay cambios en otro cliente)
async function loadUserData(){
  try{
    const { data, error } = await supabase
      .from('usuarios')
      .select('pekepuntos, last_claim')
      .eq('id', currentUser.id)
      .single();
    if(error) throw error;
    balance = Number(data.pekepuntos || 0);
    lastDaily = data.last_claim ? data.last_claim.slice(0,10) : null;
    currentUser.pekepuntos = balance;
    currentUser.last_claim = data.last_claim || null;
    localStorage.setItem('currentUser', JSON.stringify(currentUser));
    refreshBalanceUI();
  } catch(err){
    alert('Error cargando datos usuario: ' + (err.message || err));
  }
}

async function saveBalance(){
  try{
    const { error } = await supabase
      .from('usuarios')
      .update({ pekepuntos: balance })
      .eq('id', currentUser.id);
    if(error) throw error;
    currentUser.pekepuntos = balance;
    localStorage.setItem('currentUser', JSON.stringify(currentUser));
    refreshBalanceUI();
  } catch(err){
    alert('Error guardando balance: ' + (err.message || err));
  }
}

function refreshBalanceUI(){
  balanceEl.textContent = String(Math.round(balance));
}

// ---------- DAILY CLAIM ----------
async function claimDaily(){
  try{
    const today = isoDay();
    if(lastDaily === today){
      alert('Ya has recogido tus fichas diarias hoy.');
      return;
    }
    // aÃ±adir 100 pekepuntos
    balance += 100;
    lastDaily = today;
    currentUser.last_claim = new Date().toISOString();
    // guardar en supabase y localStorage
    const { error } = await supabase
      .from('usuarios')
      .update({ pekepuntos: balance, last_claim: currentUser.last_claim })
      .eq('id', currentUser.id);
    if(error) throw error;
    currentUser.pekepuntos = balance;
    localStorage.setItem('currentUser', JSON.stringify(currentUser));
    refreshBalanceUI();
    if(npcMsg){ npcMsg.innerText = 'Â¡Has recogido tus fichas diarias!'; npcMsg.style.display = 'block'; setTimeout(()=> npcMsg.style.display='none',1400); }
    alert('Â¡Has recibido +100 Pekepuntos!');
  } catch(err){
    alert('Error al reclamar diario: ' + (err.message || err));
  }
}

// ---------- THREE.JS: escena, cÃ¡mara, renderer ----------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0f1a);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 1.6, 5);
camera.rotation.order = 'YXZ';

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
container.appendChild(renderer.domElement);

// luces
const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.85); hemi.position.set(0,50,0); scene.add(hemi);
scene.add(new THREE.AmbientLight(0xffffff, 0.22));
const dir = new THREE.DirectionalLight(0xfff6d6, 0.6); dir.position.set(5,10,5); dir.castShadow = true; scene.add(dir);

// ---------- Texturas (canvas) ----------
function createCanvasTexture(drawFn, size = 1024){
  const c = document.createElement('canvas');
  c.width = c.height = size;
  const ctx = c.getContext('2d');
  drawFn(ctx, size);
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(1,1);
  return tex;
}

// velvet (tapete)
const velvetTex = createCanvasTexture((ctx, s) => {
  ctx.fillStyle = '#123f2a';
  ctx.fillRect(0,0,s,s);
  ctx.globalAlpha = 0.06;
  ctx.fillStyle = '#000';
  for(let i=0;i<s;i+=14){
    ctx.fillRect(i, 0, 2, s);
  }
  ctx.globalAlpha = 1;
  ctx.strokeStyle = '#7a2f1f';
  ctx.lineWidth = Math.max(2, s/220);
  ctx.strokeRect(6,6,s-12,s-12);
});

// wood floor
const woodTex = createCanvasTexture((ctx,s) => {
  ctx.fillStyle = '#4b2f23'; ctx.fillRect(0,0,s,s);
  ctx.strokeStyle = '#553927'; ctx.lineWidth = Math.max(1, s/140);
  for(let y=0;y<s;y+=32){
    ctx.beginPath(); ctx.moveTo(0,y+6); ctx.lineTo(s,y+6); ctx.stroke();
  }
});

// fabric wall
const fabricTex = createCanvasTexture((ctx,s) => {
  ctx.fillStyle = '#11121a'; ctx.fillRect(0,0,s,s);
  ctx.globalAlpha = 0.03; ctx.fillStyle = '#fff';
  for(let i=0;i<s;i+=8){ ctx.fillRect(i,0,1,s); }
  ctx.globalAlpha = 1;
});

// slot screen
const slotScreenTex = createCanvasTexture((ctx,s) => {
  ctx.fillStyle = '#040405'; ctx.fillRect(0,0,s,s);
  const g = ctx.createLinearGradient(0,0,0,s); g.addColorStop(0,'rgba(255,255,255,0.02)'); g.addColorStop(1,'rgba(0,0,0,0.06)');
  ctx.fillStyle = g; ctx.fillRect(0,0,s,s);
});

// roulette disk (draw numbers around center)
const rouletteTex = createCanvasTexture((ctx,s) => {
  ctx.translate(s/2, s/2);
  const r = s/2;
  ctx.fillStyle = '#2f1d12';
  ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();

  const cellCount = 37; // 0..36
  const anglePer = (Math.PI*2) / cellCount;
  for(let i=0;i<cellCount;i++){
    const start = i*anglePer - Math.PI/2;
    const end = start + anglePer;
    const isZero = i === 0;
    ctx.beginPath();
    ctx.fillStyle = isZero ? '#0b8a12' : (i%2 === 0 ? '#d22' : '#111');
    ctx.moveTo(0,0);
    ctx.arc(0,0, r*0.92, start, end);
    ctx.closePath();
    ctx.fill();

    // numbers
    ctx.save();
    ctx.rotate(start + anglePer/2);
    ctx.fillStyle = isZero ? '#fff' : '#eee';
    ctx.font = `${Math.max(12, s*0.06)}px sans-serif`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(String(i), 0, -r*0.68);
    ctx.restore();
  }

  // center wood
  ctx.beginPath(); ctx.fillStyle = '#8b5a2b'; ctx.arc(0,0,r*0.20,0,Math.PI*2); ctx.fill();
});

// ---------- Suelo y paredes ----------
const floorMat = new THREE.MeshStandardMaterial({ map: woodTex, roughness: 0.92 });
const floor = new THREE.Mesh(new THREE.PlaneGeometry(40,40), floorMat);
floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

const wallMat = new THREE.MeshStandardMaterial({ map: fabricTex, roughness: 0.96 });
function makeWall(x,z,rotY=0){
  const w = new THREE.Mesh(new THREE.BoxGeometry(40,6,0.2), wallMat);
  w.position.set(x,3,z); w.rotation.y = rotY; w.receiveShadow = true; scene.add(w);
}
makeWall(0,-19); makeWall(0,19,Math.PI);
makeWall(-19,0,Math.PI/2); makeWall(19,0,-Math.PI/2);

// ---------- Objetos interactuables ----------
const interact = [];
function addObject(mesh, type){
  mesh.userData.type = type;
  mesh.castShadow = true; mesh.receiveShadow = true;
  interact.push(mesh); scene.add(mesh);
}

// blackjack table
const bjMat = new THREE.MeshStandardMaterial({ map: velvetTex, roughness: 0.6, metalness: 0.02 });
const bjTable = new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.6,0.34,32), bjMat);
bjTable.position.set(-6,0.34,0); addObject(bjTable,'blackjack');

// roulette base + disk
const ruletaBaseMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.6, roughness: 0.3 });
const ruletaBase = new THREE.Mesh(new THREE.CylinderGeometry(1.2,1.2,0.42,64), ruletaBaseMat);
ruletaBase.position.set(0,0.22,0); addObject(ruletaBase,'roulette');

const ruletaDisk = new THREE.Mesh(
  new THREE.CylinderGeometry(1.15,1.15,0.08,128),
  new THREE.MeshStandardMaterial({ map: rouletteTex, metalness:0.15, roughness:0.4 })
);
// orient the disk flat (face up). we rotate X = PI/2 so the cylinder's local Z is up; spin uses rotation.z
ruletaDisk.rotation.x = Math.PI/2;
// small rotation to align numbers correctly visually
ruletaDisk.rotation.z = 0;
ruletaDisk.position.set(0,0.48,0);
ruletaDisk.receiveShadow = true; ruletaDisk.castShadow = true;
scene.add(ruletaDisk);

// slots
const slotBodyMat = new THREE.MeshStandardMaterial({ map: velvetTex, metalness:0.25, roughness:0.5 });
const slot = new THREE.Mesh(new THREE.BoxGeometry(1.0,2.0,1.0), slotBodyMat);
slot.position.set(6,1,0); addObject(slot,'slots');

const slotScreen = new THREE.Mesh(new THREE.PlaneGeometry(0.75,0.4), new THREE.MeshStandardMaterial({ map: slotScreenTex, emissive: 0x000000 }));
slotScreen.position.set(6,1.45,0.51); scene.add(slotScreen);

// npc (daily chest)
const npc = new THREE.Mesh(new THREE.CylinderGeometry(0.42,0.42,1.6,16), new THREE.MeshStandardMaterial({ color: 0x999999 }));
npc.position.set(0,1.0,6); addObject(npc,'npc');

// lights above tables
function addTableLight(x,z){
  const l = new THREE.PointLight(0xffe7c6, 0.8, 6);
  l.position.set(x,3,z); scene.add(l);
}
addTableLight(-6,0); addTableLight(0,0); addTableLight(6,0);

// ---------- Controles (keyboard) ----------
const keys = {};
document.addEventListener('keydown', e => keys[e.code] = true);
document.addEventListener('keyup', e => keys[e.code] = false);

let yaw = 0, pitch = 0;
const yawSpeed = 1.8, pitchSpeed = 1.2;
function updateCameraRotation(dt){
  if(keys['ArrowLeft']) yaw += yawSpeed * dt;
  if(keys['ArrowRight']) yaw -= yawSpeed * dt;
  if(keys['ArrowUp']) pitch += pitchSpeed * dt;
  if(keys['ArrowDown']) pitch -= pitchSpeed * dt;
  const pitchLimit = Math.PI/2 - 0.05;
  pitch = Math.max(-pitchLimit, Math.min(pitchLimit, pitch));
  camera.rotation.y = yaw;
  camera.rotation.x = pitch;
}
function updateCameraPosition(dt){
  const speed = 3.0;
  const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
  const right = new THREE.Vector3(); right.crossVectors(forward, camera.up).normalize();
  const move = new THREE.Vector3();
  if(keys['KeyW']) move.add(forward);
  if(keys['KeyS']) move.sub(forward);
  if(keys['KeyD']) move.add(right);
  if(keys['KeyA']) move.sub(right);
  move.multiplyScalar(speed * dt); camera.position.add(move);
}

// ---------- Raycast interaction ----------
const ray = new THREE.Raycaster();
let lookingAt = null;
function checkInteraction(){
  ray.set(camera.position, camera.getWorldDirection(new THREE.Vector3()));
  const hits = ray.intersectObjects(interact, false);
  if(hits.length === 0 || hits[0].distance > 4){
    lookingAt = null; if(npcMsg) npcMsg.style.display = 'none'; return;
  }
  lookingAt = hits[0].object;
  if(lookingAt.userData.type === 'npc'){
    if(npcMsg){ npcMsg.style.display = 'block'; npcMsg.innerText = 'Pulsa E para recoger fichas diarias'; }
  } else {
    if(npcMsg) npcMsg.style.display = 'none';
  }
}

// ---------- Game logic (Blackjack / Roulette / Slots) ----------
function createDeck(){
  const vals = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  const suits = ['â™ ','â™¥','â™¦','â™£'];
  const d = [];
  for(const s of suits) for(const v of vals) d.push({v,s});
  for(let i=d.length-1;i>0;i--){ const j = rand(0,i); [d[i],d[j]] = [d[j],d[i]]; }
  return d;
}
function cardValue(c){ if(c.v==='A') return 11; if(['J','Q','K'].includes(c.v)) return 10; return parseInt(c.v); }
function handScore(hand){ let sum=0, aces=0; for(const c of hand){ if(c.v==='A') aces++; sum += cardValue(c); } while(sum>21 && aces>0){ sum-=10; aces--; } return sum; }

// ---------- Blackjack UI / logic ----------
function renderBlackjackUI(){
  modal.innerHTML = '';
  const el = document.createElement('div'); el.className = 'gameUI';
  el.innerHTML = `
    <h2>Blackjack</h2>
    <div>Saldo: <span id='bjBal'>${balance}</span> Pekepuntos</div>
    <label>Apuesta: <input id='bjBet' type='number' value='10' min='1' style='width:100px'></label>
    <div id='bjTable' style='margin-top:8px'></div>
    <div style='margin-top:10px'>
      <button id='bjDeal'>Repartir</button>
      <button id='bjHit' disabled>Pedir</button>
      <button id='bjStand' disabled>Plantarse</button>
      <button id='bjDouble' disabled>Doblar</button>
      <button id='bjSplit' disabled>Dividir</button>
      <button id='bjClose'>Cerrar</button>
    </div>
  `;
  modal.appendChild(el);

  const bjTable = el.querySelector('#bjTable');
  const bjBal = el.querySelector('#bjBal');
  const btnHit = el.querySelector('#bjHit');
  const btnStand = el.querySelector('#bjStand');
  const btnDouble = el.querySelector('#bjDouble');
  const btnSplit = el.querySelector('#bjSplit');

  let deck, player = [], player2 = [], dealer = [], bet = 0, inRound = false, splitMode = false;

  function updateTable(){
    const dealerDisplay = inRound ? (dealer[0].v + dealer[0].s + ' ?') : dealer.map(c=>c.v+c.s).join(' ');
    let playerDisplay = player.map(c=>c.v+c.s).join(' ');
    if(splitMode) playerDisplay += ` | ${player2.map(c=>c.v+c.s).join(' ')}`;
    bjTable.innerHTML = `<div>Jugador: ${playerDisplay} (${handScore(player)})</div>
                         <div>Dealer: ${dealerDisplay}</div>`;
    bjBal.textContent = balance;
  }

  function dealerPlay(){
    while(handScore(dealer) < 17) dealer.push(deck.pop());
  }

  function finishHandSingle(h){
    if(handScore(h) > 21) return 'Pierdes';
    dealerPlay();
    const ds = handScore(dealer), ps = handScore(h);
    if(ds > 21) return 'Ganas';
    if(ps > ds) return 'Ganas';
    if(ps === ds) return 'Empate';
    return 'Pierdes';
  }

  function endRound(){
    btnHit.disabled = true; btnStand.disabled = true; btnDouble.disabled = true; btnSplit.disabled = true;
    inRound = false;
    if(splitMode){
      const res1 = finishHandSingle(player), res2 = finishHandSingle(player2);
      let payout = 0;
      if(res1==='Ganas') payout += bet*2; else if(res1==='Empate') payout += bet;
      if(res2==='Ganas') payout += bet*2; else if(res2==='Empate') payout += bet;
      balance += payout; saveBalance();
      bjTable.innerHTML += `<div>Resultado Mano 1: ${res1}</div><div>Resultado Mano 2: ${res2}</div><div>Total ganado: ${payout}</div>`;
    } else {
      const res = finishHandSingle(player);
      if(res==='Ganas'){ balance += bet*2; } else if(res==='Empate'){ balance += bet; }
      saveBalance();
      bjTable.innerHTML += `<div>Resultado: ${res}</div>`;
    }
    updateTable();
  }

  el.querySelector('#bjDeal').onclick = () => {
    bet = Math.min(balance, Number(el.querySelector('#bjBet').value) || 0);
    if(bet <= 0){ alert('Apuesta invÃ¡lida'); return; }
    balance -= bet; saveBalance(); bjBal.textContent = balance;
    deck = createDeck();
    player = [deck.pop(), deck.pop()];
    dealer = [deck.pop(), deck.pop()];
    player2 = []; inRound = true; splitMode = false;
    btnHit.disabled = false; btnStand.disabled = false; btnDouble.disabled = false;
    btnSplit.disabled = !(player[0].v === player[1].v);
    updateTable();
  };

  btnHit.onclick = () => {
    if(!inRound) return;
    player.push(deck.pop());
    if(handScore(player) > 21) endRound();
    updateTable();
  };

  btnStand.onclick = () => { endRound(); updateTable(); };

  btnDouble.onclick = () => {
    if(balance < bet){ alert('Saldo insuficiente'); return; }
    balance -= bet; bet *= 2; saveBalance();
    player.push(deck.pop()); endRound(); updateTable();
  };

  btnSplit.onclick = () => {
    if(player[0].v !== player[1].v){ alert('No se puede dividir'); return; }
    if(balance < bet){ alert('Saldo insuficiente'); return; }
    balance -= bet; saveBalance();
    player2.push(player.pop());
    player.push(deck.pop());
    player2.push(deck.pop());
    splitMode = true; btnSplit.disabled = true; updateTable();
  };

  el.querySelector('#bjClose').onclick = () => { modal.style.display = 'none'; };
}

// ---------- Roulette UI & logic ----------
function isRed(n){ const reds = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]); return reds.has(n); }

let ruletaSpinVelocity = 0, ruletaSpinning = false, ruletaResolveTimer = null;

function renderRouletteUI(){
  modal.innerHTML = '';
  const el = document.createElement('div'); el.className = 'gameUI';
  el.innerHTML = `
    <h2>Ruleta</h2>
    <div>Saldo: <span id='rBal'>${balance}</span> Pekepuntos</div>
    <label>Apuesta: <input id='rBet' type='number' value='10' min='1' style='width:100px'></label>
    <label>Tipo: <select id='rType'><option value='number'>NÃºmero</option><option value='color'>Color</option><option value='par'>Par/Impar</option></select></label>
    <label id='rNumberWrap'><input id='rNumber' type='number' min='0' max='36' value='7' style='width:80px'></label>
    <label id='rColorWrap' style='display:none'><select id='rColor'><option value='red'>Rojo</option><option value='black'>Negro</option></select></label>
    <div style='margin-top:8px'><button id='rSpin'>Girar</button> <button id='rClose'>Cerrar</button></div>
    <div id='rOut' style='margin-top:8px'></div>
  `;
  modal.appendChild(el);

  const rBal = el.querySelector('#rBal');
  const rType = el.querySelector('#rType');
  const rNumberWrap = el.querySelector('#rNumberWrap');
  const rColorWrap = el.querySelector('#rColorWrap');
  const rOut = el.querySelector('#rOut');

  rType.onchange = () => {
    rNumberWrap.style.display = rType.value === 'number' ? 'inline-block' : 'none';
    rColorWrap.style.display = rType.value === 'color' ? 'inline-block' : 'none';
    if(rType.value === 'par') rColorWrap.style.display = 'inline-block';
  };

  el.querySelector('#rSpin').onclick = () => {
    const bet = Math.min(balance, Number(el.querySelector('#rBet').value) || 0);
    if(bet <= 0){ alert('Apuesta invÃ¡lida'); return; }
    el.querySelector('#rSpin').disabled = true;
    balance -= bet; saveBalance(); rBal.textContent = balance;

    // Empieza la animaciÃ³n de la ruleta (set velocity)
    ruletaSpinVelocity = 7 + Math.random()*6;
    ruletaSpinning = true;

    if(ruletaResolveTimer) clearTimeout(ruletaResolveTimer);
    // resolvemos el resultado tras un tiempo (suficiente para animaciÃ³n)
    ruletaResolveTimer = setTimeout(() => {
      const result = rand(0,36);
      const color = isRed(result) ? 'red' : 'black';
      let win = false, payout = 0;

      if(rType.value === 'number'){
        const pick = Number(el.querySelector('#rNumber').value);
        if(pick === result){ win = true; payout = bet * 35; }
      } else if(rType.value === 'color'){
        const pick = el.querySelector('#rColor').value;
        if(pick === color){ win = true; payout = bet * 2; }
      } else if(rType.value === 'par'){
        const pick = el.querySelector('#rColor').value;
        if(result !== 0){
          const isEven = (result % 2 === 0);
          if(pick === 'red' && !isEven){ win = true; payout = bet * 2; }
          if(pick === 'black' && isEven){ win = true; payout = bet * 2; }
        }
      }

      // esperar para que el usuario vea la animaciÃ³n
      setTimeout(async () => {
        if(win){ balance += payout; await saveBalance(); rOut.innerHTML = `<div>Sale ${result} (${result===0?'green':color})</div><div>Â¡Ganas ${payout} Pekepuntos!</div>`; }
        else { rOut.innerHTML = `<div>Sale ${result} (${result===0?'green':color})</div><div>Pierdes ${bet} Pekepuntos</div>`; }
        el.querySelector('#rSpin').disabled = false;
      }, 800);
    }, 1700);
  };

  el.querySelector('#rClose').onclick = () => { modal.style.display = 'none'; };
}

// ---------- Slots UI & logic ----------
function renderSlotsUI(){
  modal.innerHTML = '';
  const el = document.createElement('div'); el.className = 'gameUI';
  el.innerHTML = `
    <h2>Tragaperras</h2>
    <div>Saldo: <span id='sBal'>${balance}</span> Pekepuntos</div>
    <label>Apuesta: <input id='sBet' type='number' value='5' min='1' style='width:100px'></label>
    <div style='margin-top:8px'><div id='reels' style='font-size:40px;letter-spacing:12px;text-align:center'>â€¢ Â· â€¢</div></div>
    <div style='margin-top:8px'><button id='sSpin'>Girar</button> <button id='sClose'>Cerrar</button></div>
    <div id='sOut' style='margin-top:8px'></div>
  `;
  modal.appendChild(el);

  const sBal = el.querySelector('#sBal');
  const reels = el.querySelector('#reels');
  const sOut = el.querySelector('#sOut');
  const symbols = ['ðŸ’','ðŸ””','7ï¸âƒ£','â­','ðŸ‹'];

  el.querySelector('#sSpin').onclick = () => {
    const bet = Math.min(balance, Number(el.querySelector('#sBet').value) || 0);
    if(bet <= 0){ alert('Apuesta invÃ¡lida'); return; }
    balance -= bet; saveBalance(); sBal.textContent = balance;
    el.querySelector('#sSpin').disabled = true;

    let ticks = 0;
    let result = ['', '', ''];
    const interval = setInterval(() => {
      ticks++;
      result[0] = symbols[rand(0, symbols.length - 1)];
      result[1] = symbols[rand(0, symbols.length - 1)];
      result[2] = symbols[rand(0, symbols.length - 1)];
      reels.textContent = result.join('  ');

      if(ticks > 22){
        clearInterval(interval);
        let payout = 0;
        if(result[0] === result[1] && result[1] === result[2]) payout = bet * 10;
        else if(result[0] === result[1] || result[1] === result[2] || result[0] === result[2]) payout = bet * 2;

        if(payout > 0){
          balance += payout; saveBalance();
          sOut.innerHTML = `Â¡Ganaste ${payout} Pekepuntos!`;
        } else {
          sOut.innerHTML = `Sin premio`;
        }
        sBal.textContent = balance;
        el.querySelector('#sSpin').disabled = false;
      }
    }, 80);
  };

  el.querySelector('#sClose').onclick = () => { modal.style.display = 'none'; };
}

// ---------- Open UI by type ----------
function openUI(type){
  if(type === 'blackjack'){ modal.style.display = 'block'; renderBlackjackUI(); }
  else if(type === 'roulette'){ modal.style.display = 'block'; renderRouletteUI(); }
  else if(type === 'slots'){ modal.style.display = 'block'; renderSlotsUI(); }
  else if(type === 'npc'){ claimDaily(); }
}

// key E -> open UI for lookingAt
document.addEventListener('keydown', e => {
  if(e.code === 'KeyE' && lookingAt) openUI(lookingAt.userData.type);
});

// ---------- Animation loop (including roulette spin) ----------
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  updateCameraPosition(dt);
  updateCameraRotation(dt);
  checkInteraction();

  // ruleta visual damping (rotate around local Z because we set rotation.x = PI/2)
  if(ruletaSpinning){
    // rotate around disk's local Z: adjust rotation.z
    ruletaDisk.rotation.z += ruletaSpinVelocity * dt;
    ruletaSpinVelocity = Math.max(0, ruletaSpinVelocity - dt * 2.6);
    if(ruletaSpinVelocity <= 0.01){
      ruletaSpinning = false;
      // a little final nudge
      ruletaDisk.rotation.z += 0.04;
    }
  } else {
    // slow idle rotation
    ruletaDisk.rotation.z += 0.002;
  }

  renderer.render(scene, camera);
}
animate();

// ---------- Resize ----------
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// ---------- InicializaciÃ³n ----------
refreshBalanceUI();
loadUserData().catch(err => { alert('No se pudo sincronizar con servidor: ' + (err.message || err)); });

</script>
</body>
</html>
