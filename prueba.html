<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Casino 3D â€” FPS simple (WASD + Flechas)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#05060a;color:#fff;font-family:Inter,Arial,Helvetica}
  #wrap{position:relative;height:100vh;overflow:hidden}
  canvas{display:block}
  .hud{position:absolute;right:12px;top:12px;z-index:30;max-width:360px}
  .panel{background:rgba(0,0,0,0.55);padding:10px;border-radius:10px;margin-bottom:10px}
  .info-row{display:flex;justify-content:space-between;align-items:center;margin:6px 0;font-size:13px}
  #prompt{position:absolute;left:50%;transform:translateX(-50%);bottom:90px;background:rgba(0,0,0,0.6);padding:8px 12px;border-radius:8px;display:none}
  #overlay{position:absolute;left:0;top:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;z-index:60}
  #overlay .ui{background:rgba(8,10,12,0.95);padding:16px;border-radius:12px;width:420px;box-shadow:0 10px 40px rgba(0,0,0,0.7)}
  .btn{background:#1d7cf0;color:white;padding:8px 10px;border-radius:8px;border:none;cursor:pointer}
  footer{position:absolute;left:12px;bottom:12px;color:#ccc;font-size:13px}
  #minimap{position:absolute;left:12px;top:12px;width:120px;height:120px;background:rgba(255,255,255,0.03);border-radius:8px;z-index:20}
  .centerNotice{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:80;color:#fff;font-size:20px;text-align:center;display:none}
</style>
</head>
<body>
  <div id="wrap">
    <div id="minimap"></div>
    <div class="hud">
      <div class="panel">
        <h3>Casino 3D â€” Movimiento</h3>
        <div class="info-row"><span>Saldo</span><strong id="balance">1000</strong></div>
        <div class="info-row"><span>Apuesta actual</span><strong id="bet">0</strong></div>
        <div style="font-size:13px;margin-top:6px">
          Controles: <strong>W A S D</strong> moverse Â· <strong>Flechas</strong> girar cÃ¡mara Â· <strong>E</strong> interactuar
        </div>
      </div>
      <div class="panel">
        <h4>InteractÃºa</h4>
        <div id="interact-info" style="font-size:13px">AcÃ©rcate a una mÃ¡quina o mesa y pulsa <strong>E</strong>.</div>
      </div>
      <div class="panel">
        <h4>Historial</h4>
        <div id="log" style="max-height:120px;overflow:auto;font-size:12px;background:rgba(255,255,255,0.02);padding:6px;border-radius:6px"></div>
      </div>
    </div>

    <div id="prompt">[E] Interactuar</div>

    <div id="overlay">
      <div class="ui" id="ui-box">
        <!-- contenido dinÃ¡mico -->
      </div>
    </div>

    <div class="centerNotice" id="centerNotice"></div>

    <footer>Modo low-poly Â· InteracciÃ³n por zonas Â· CÃ¡mara con flechas</footer>
  </div>

  <!-- Three.js UMD -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>

  <script>
  (function(){
    // ---------- Setup Three.js ----------
    const wrap = document.getElementById('wrap');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x061014);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(wrap.clientWidth, wrap.clientHeight);
    wrap.appendChild(renderer.domElement);

    // player (camera attached to player)
    const camera = new THREE.PerspectiveCamera(70, wrap.clientWidth / wrap.clientHeight, 0.1, 1000);
    camera.position.set(0, 1.8, 10); // altura ojos ~1.8

    // We'll represent player as simple object for collisions
    const player = new THREE.Object3D();
    player.position.set(0,0,10);
    player.add(camera);
    scene.add(player);

    // Lights (simple, low poly look)
    const amb = new THREE.AmbientLight(0xffffff, 0.35); scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(10,20,10); scene.add(dir);

    // Floor
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({color:0x081217,roughness:0.95,metalness:0.02}));
    floor.rotation.x = -Math.PI/2; floor.position.y = 0; scene.add(floor);

    // Simple walls for the room (low poly boxes)
    function makeWall(w,h,d,x,y,z,rotY){
      const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({color:0x0e1620}));
      m.position.set(x,y,z);
      if(rotY) m.rotation.y = rotY;
      scene.add(m);
      return m;
    }
    makeWall(200,10,2,0,5,-100); // back
    makeWall(2,10,200,-100,5,0); // left
    makeWall(2,10,200,100,5,0); // right
    makeWall(200,10,2,0,5,100); // front

    // Decorative columns / lights (low poly)
    for(let i=-1;i<=1;i++){
      const col = new THREE.Mesh(new THREE.CylinderGeometry(1.2,1.2,8,8), new THREE.MeshStandardMaterial({color:0x2a2a2a}));
      col.position.set(i*30,4, -30); scene.add(col);
    }

    // ----- Mesa con ruleta (zona interactiva) -----
    const table = new THREE.Group();
    table.position.set(0,0,0);
    // base
    const base = new THREE.Mesh(new THREE.CylinderGeometry(8,8,1.2,18), new THREE.MeshStandardMaterial({color:0x154028}));
    base.position.y = 0.6; table.add(base);
    // wheel - simplified cylinder + canvas numbers
    const wheelRadius = 6;
    function createWheelCanvas(size=1024){
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d');
      ctx.fillStyle='#042b23'; ctx.fillRect(0,0,size,size);
      const pockets = [0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23];
      const count = pockets.length;
      const cx=size/2, cy=size/2, r=size*0.45;
      for(let i=0;i<count;i++){
        const a0 = (i/count)*Math.PI*2 - Math.PI/2;
        const a1 = ((i+1)/count)*Math.PI*2 - Math.PI/2;
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,r,a0,a1); ctx.closePath();
        ctx.fillStyle = (i%2===0)?'#b71c1c':'#000';
        ctx.fill();
        // text
        const mid = a0 + (a1-a0)/2;
        ctx.save(); ctx.translate(cx + Math.cos(mid)*(r*0.66), cy + Math.sin(mid)*(r*0.66));
        ctx.rotate(mid + Math.PI/2);
        ctx.fillStyle='#fff'; ctx.font = `${Math.floor(size*0.05)}px sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(pockets[i],0,0); ctx.restore();
      }
      ctx.beginPath(); ctx.fillStyle='#111'; ctx.arc(cx,cy,r*0.45,0,Math.PI*2); ctx.fill();
      return c;
    }
    const wheelTex = new THREE.CanvasTexture(createWheelCanvas());
    const wheel = new THREE.Mesh(new THREE.CylinderGeometry(wheelRadius,wheelRadius,1.2,36), new THREE.MeshStandardMaterial({map:wheelTex}));
    wheel.rotation.x = Math.PI/2; wheel.position.y = 1.8; table.add(wheel);

    // bola
    const ball = new THREE.Mesh(new THREE.SphereGeometry(0.18,8,8), new THREE.MeshStandardMaterial({metalness:0.9,roughness:0.2}));
    ball.position.set(wheelRadius-0.8,2.1,0); table.add(ball);

    scene.add(table);

    // create rectangle collider area around the ruleta for interaction
    const ruletaZone = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(0,1,0), new THREE.Vector3(12,4,12));

    // ----- Tragaperras (slot) -----
    const slot = new THREE.Group();
    slot.position.set(18,0, -6);
    const slotBody = new THREE.Mesh(new THREE.BoxGeometry(6,8,4), new THREE.MeshStandardMaterial({color:0x273238}));
    slotBody.position.y = 4; slot.add(slotBody);
    // reels as simple planes with text drawn on canvas
    const symbols = ['ðŸ’','â­','7','ðŸ‹','ðŸ””'];
    function makeReelCanvas(symbol){
      const c = document.createElement('canvas'); c.width=128; c.height=192;
      const ctx = c.getContext('2d'); ctx.fillStyle='#000'; ctx.fillRect(0,0,c.width,c.height); ctx.fillStyle='#fff'; ctx.font='60px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(symbol, c.width/2, c.height/2);
      return c;
    }
    const reels = [];
    for(let i=0;i<3;i++){
      const tex = new THREE.CanvasTexture(makeReelCanvas(symbols[Math.floor(Math.random()*symbols.length)]));
      const p = new THREE.Mesh(new THREE.PlaneGeometry(1.6,2.4), new THREE.MeshBasicMaterial({map:tex}));
      p.position.set(18,5.2, (i-1)*1.3);
      scene.add(p);
      reels.push({mesh:p,tex:tex});
    }

    // slot interaction zone
    const slotZone = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(18,2, -6), new THREE.Vector3(8,6,6));

    // ----- Objetos estÃ¡ticos para colisiones (mesas, mÃ¡quinas) -----
    const colliders = [];
    // add table collider as box
    const tableBox = new THREE.Mesh(new THREE.BoxGeometry(16,4,16), new THREE.MeshStandardMaterial({visible:false}));
    tableBox.position.copy(table.position); tableBox.position.y = 2;
    scene.add(tableBox); colliders.push(tableBox);
    // add slot collider
    const slotBox = new THREE.Mesh(new THREE.BoxGeometry(8,10,6), new THREE.MeshStandardMaterial({visible:false}));
    slotBox.position.set(18,5,-6); scene.add(slotBox); colliders.push(slotBox);

    // ----- Simple decorative objects (chairs) -----
    function makeChair(x,z){
      const g = new THREE.Group();
      const seat = new THREE.Mesh(new THREE.BoxGeometry(1.6,0.4,1.6), new THREE.MeshStandardMaterial({color:0x6b3b1b}));
      seat.position.y = 0.8; g.add(seat);
      const back = new THREE.Mesh(new THREE.BoxGeometry(1.6,1.4,0.3), new THREE.MeshStandardMaterial({color:0x6b3b1b}));
      back.position.set(0,1.5,-0.6); g.add(back);
      g.position.set(x,0,z); scene.add(g);
    }
    makeChair(-6,6); makeChair(6,6); makeChair(-6,-6);

    // ----- Player movement & camera control -----
    const keys = {w:false,a:false,s:false,d:false,ArrowLeft:false,ArrowRight:false,ArrowUp:false,ArrowDown:false};
    const speed = 6.0; // meters per second
    let yaw = 0; let pitch = 0; // camera angles in radians

    window.addEventListener('keydown', (e)=> {
      const k = e.key;
      if(k in keys) keys[k]=true;
      // prevent page scrolling when arrow keys used
      if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(k)) e.preventDefault();
    });
    window.addEventListener('keyup', (e)=> {
      const k = e.key;
      if(k in keys) keys[k]=false;
    });

    // collision helper: simple sphere-vs-box check
    function checkCollision(newPos){
      // approximate player as sphere radius
      const r = 0.5;
      for(const c of colliders){
        const box = new THREE.Box3().setFromObject(c);
        // expand box by player radius
        const expanded = box.clone().expandByScalar(r);
        if(expanded.containsPoint(newPos)) return true;
      }
      // also keep inside room bounds (Â±90)
      if(Math.abs(newPos.x) > 95 || newPos.z > 95 || newPos.z < -95) return true;
      // ground
      return false;
    }

    // HUD elements
    const balanceEl = document.getElementById('balance'), betEl = document.getElementById('bet'), logEl = document.getElementById('log');
    let balance = 1000, currentBet = 0;
    function updateHUD(){ balanceEl.textContent = balance.toFixed(0); betEl.textContent = currentBet.toFixed(0); }
    function appendLog(t){ const d=new Date(); const el=document.createElement('div'); el.textContent=`[${d.toLocaleTimeString()}] ${t}`; logEl.prepend(el); }

    // Interaction detection
    const prompt = document.getElementById('prompt');
    let nearZone = null; // "ruleta" or "slot" or null

    function detectZones(){
      // player's eye position
      const eye = new THREE.Vector3().copy(player.position); eye.y = 1.6;
      // ruleta
      if(ruletaZone.containsPoint(eye)) { nearZone='ruleta'; prompt.style.display='block'; prompt.textContent='[E] Interactuar con la ruleta'; return; }
      // slot
      if(slotZone.containsPoint(eye)) { nearZone='slot'; prompt.style.display='block'; prompt.textContent='[E] Interactuar con la tragaperras'; return; }
      nearZone = null; prompt.style.display='none';
    }

    // Interaction UI overlay
    const overlay = document.getElementById('overlay');
    const uiBox = document.getElementById('ui-box');
    let activeUI = null; // 'ruleta' or 'slot'
    let ruletaState = {bets:[], spinning:false, wheelVel:0, ballVel:0, ballAngle:0};
    let slotState = {credits:0};

    // Simple ruleta interaction UI: place bet on a number (simplified)
    function openRuletaUI(){
      activeUI='ruleta';
      overlay.style.display = 'flex';
      uiBox.innerHTML = `
        <h3>Ruleta</h3>
        <div style="margin:8px 0">Saldo: <strong id="ui-balance">${balance}</strong></div>
        <div style="margin-bottom:8px">
          <label>Apuesta num (0-17): <input id="ui-num" type="number" min="0" max="17" value="0" style="width:80px"/></label>
          <label style="margin-left:8px">Monto: <input id="ui-amt" type="number" min="1" value="5" style="width:100px"/></label>
        </div>
        <div style="display:flex;gap:8px;justify-content:flex-end">
          <button class="btn" id="ui-place">Colocar Apuesta</button>
          <button class="btn" id="ui-spin">Girar Ruleta</button>
          <button class="btn" id="ui-close">Cerrar</button>
        </div>
      `;
      document.getElementById('ui-place').addEventListener('click', ()=>{
        const idx = parseInt(document.getElementById('ui-num').value||0);
        const amt = parseInt(document.getElementById('ui-amt').value||1);
        if(isNaN(idx)||idx<0||idx>17){ alert('NÃºmero invÃ¡lido (0-17)'); return; }
        if(amt<=0 || amt>balance){ alert('Monto invÃ¡lido o saldo insuficiente'); return; }
        balance -= amt; currentBet += amt; updateHUD(); appendLog(`Apuesta ${amt} al nÃºmero ${idx} (ruleta)`); ruletaState.bets.push({idx,amt});
        document.getElementById('ui-balance').textContent = balance;
      });
      document.getElementById('ui-spin').addEventListener('click', ()=>{
        if(ruletaState.spinning) return alert('La ruleta ya estÃ¡ girando');
        if(ruletaState.bets.length===0) return alert('Sin apuestas');
        startRuletaSpin();
        closeUI();
      });
      document.getElementById('ui-close').addEventListener('click', ()=>{ closeUI(); });
    }

    function openSlotUI(){
      activeUI='slot';
      overlay.style.display = 'flex';
      uiBox.innerHTML = `
        <h3>Tragaperras</h3>
        <div style="margin:8px 0">Saldo: <strong id="ui-balance2">${balance}</strong></div>
        <div style="margin:6px 0">CrÃ©ditos insertados: <strong id="ui-credits">${slotState.credits}</strong></div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px">
          <button class="btn" id="ui-insert">Insertar ficha (1)</button>
          <button class="btn" id="ui-play">Jugar</button>
          <button class="btn" id="ui-close2">Cerrar</button>
        </div>
      `;
      document.getElementById('ui-insert').addEventListener('click', ()=>{
        if(balance<1) return alert('Saldo insuficiente');
        balance -= 1; slotState.credits += 1; updateHUD(); appendLog('Ficha insertada en tragaperras'); document.getElementById('ui-balance2').textContent = balance; document.getElementById('ui-credits').textContent = slotState.credits;
      });
      document.getElementById('ui-play').addEventListener('click', ()=>{ if(slotState.credits<=0) return alert('Inserta fichas'); spinSlot(); closeUI(); });
      document.getElementById('ui-close2').addEventListener('click', ()=>closeUI());
    }

    function closeUI(){
      activeUI=null; overlay.style.display='none'; uiBox.innerHTML='';
    }

    // open UI when press E inside zone
    window.addEventListener('keydown', (e)=> {
      if(e.key === 'e' || e.key === 'E'){
        if(nearZone === 'ruleta') openRuletaUI();
        else if(nearZone === 'slot') openSlotUI();
      }
      // quick close overlay with Escape
      if(e.key === 'Escape') { if(activeUI) closeUI(); }
    });

    // ----- Ruleta spin / physics simplified -----
    function startRuletaSpin(){
      ruletaState.spinning = true;
      ruletaState.wheelVel = 8 + Math.random()*6; // rad/s approx
      ruletaState.ballVel = 18 + Math.random()*8;
      ruletaState.ballAngle = Math.random()*Math.PI*2;
      appendLog('Ruleta: girando...');
    }

    function finalizeRuleta(){
      // determine pocket under ball
      const pockets = [0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23];
      const count = pockets.length;
      const totalRot = wheel.rotation.z;
      const localAngle = (ruletaState.ballAngle - totalRot) % (Math.PI*2);
      let norm = localAngle + Math.PI/2; while(norm<0) norm += Math.PI*2; while(norm>=Math.PI*2) norm -= Math.PI*2;
      const idx = Math.floor(norm / (Math.PI*2 / count));
      const resultNumber = pockets[idx];
      appendLog(`Ruleta resultado: ${resultNumber}`);
      // pay winners (we mapped bets indices 0..17 to pockets index)
      let payout = 0;
      ruletaState.bets.forEach(b=>{
        if(b.idx === idx) payout += b.amt * 36; // 35:1 payout
      });
      if(payout>0){ balance += payout; appendLog(`Has ganado ${payout} en la ruleta!`); } else appendLog('Sin premio en la ruleta.');
      // reset bets
      ruletaState.bets = []; currentBet = 0; updateHUD();
      ruletaState.spinning = false;
    }

    // ----- Tragaperras logic -----
    function spinSlot(){
      // choose 3 random symbols
      if(slotState.credits <= 0) { appendLog('No hay crÃ©ditos'); return; }
      slotState.credits -= 1;
      const r = [randSym(), randSym(), randSym()];
      // update reel canvases (we used textures per plane)
      for(let i=0;i<3;i++){
        const canvas = document.createElement('canvas'); canvas.width=128; canvas.height=192;
        const ctx = canvas.getContext('2d'); ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#fff'; ctx.font='60px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(r[i], canvas.width/2, canvas.height/2);
        reels[i].mesh.material.map = new THREE.CanvasTexture(canvas);
        reels[i].mesh.material.needsUpdate = true;
      }
      // payout rules
      let payout = 0;
      if(r[0]===r[1] && r[1]===r[2]) payout = 50;
      else if(r[0]===r[1] || r[1]===r[2] || r[0]===r[2]) payout = 5;
      if(payout>0){ balance += payout; appendLog(`Tragaperras: ganas ${payout}`); updateHUD(); } else appendLog('Tragaperras: sin premio');
    }
    function randSym(){ return symbols[Math.floor(Math.random()*symbols.length)]; }

    // ----- Minimap (simple 2D) -----
    const minimap = document.getElementById('minimap');
    const mmCtx = (()=>{ const c = document.createElement('canvas'); c.width=120; c.height=120; minimap.appendChild(c); return c.getContext('2d'); })();

    function drawMinimap(){
      mmCtx.clearRect(0,0,120,120);
      // background
      mmCtx.fillStyle='#081217'; mmCtx.fillRect(0,0,120,120);
      // center is (60,60), world scale ~ 1 unit => 1 pixel (small area)
      const scale = 2; // scale world to minimap
      // draw player
      mmCtx.fillStyle='#1d7cf0';
      const px = 60 + player.position.x/scale; const pz = 60 + player.position.z/scale;
      mmCtx.beginPath(); mmCtx.arc(px, pz, 4, 0, Math.PI*2); mmCtx.fill();
      // draw ruleta
      mmCtx.fillStyle='#a2d9c8'; mmCtx.fillRect(60-6, 60-6, 12, 12);
      // draw slot
      const sx = 60 + 18/scale, sz = 60 + (-6)/scale;
      mmCtx.fillStyle='#f0c050'; mmCtx.fillRect(sx-4, sz-6, 8, 12);
    }

    // ----- Main loop -----
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      // movement vector from keys and yaw
      let forward = 0, right = 0;
      if(keys.w) forward += 1;
      if(keys.s) forward -= 1;
      if(keys.a) right -= 1;
      if(keys.d) right += 1;
      // normalize
      const len = Math.hypot(forward, right);
      if(len>0){ forward/=len; right/=len; }
      // rotate by yaw
      // yaw increased by arrow left/right
      if(keys.ArrowLeft) yaw += 1.8 * dt; // radians/sec
      if(keys.ArrowRight) yaw -= 1.8 * dt;
      if(keys.ArrowUp) pitch = Math.max(-Math.PI/6, pitch + 1.2*dt);
      if(keys.ArrowDown) pitch = Math.min(Math.PI/6, pitch - 1.2*dt);
      // construct movement in world space
      const dx = (Math.sin(yaw)*forward + Math.cos(yaw)*right) * speed * dt;
      const dz = (Math.cos(yaw)*forward - Math.sin(yaw)*right) * speed * dt;
      const newPos = player.position.clone().add(new THREE.Vector3(dx,0,dz));
      // collision check
      if(!checkCollision(newPos)) {
        player.position.copy(newPos);
      }
      // update camera rotation (pitch on camera, yaw on player)
      player.rotation.y = yaw;
      camera.rotation.x = pitch;

      // detect zones based on updated player
      detectZones();

      // ruleta animation
      if(ruletaState.spinning){
        wheel.rotation.z += ruletaState.wheelVel * dt * 0.6;
        ruletaState.wheelVel *= Math.max(0.995, 1 - 0.5*dt);
        ruletaState.ballAngle += ruletaState.ballVel * dt * 0.8;
        ruletaState.ballVel *= Math.max(0.99, 1 - 0.7*dt);
        // ball around rim
        const r = wheelRadius - 0.7;
        const bx = Math.cos(ruletaState.ballAngle) * r;
        const bz = Math.sin(ruletaState.ballAngle) * r;
        ball.position.set(bx, 2.1 + Math.sin(clock.elapsedTime*6)*0.02, bz);
        // stop condition
        if(Math.abs(ruletaState.wheelVel) < 0.02 && Math.abs(ruletaState.ballVel) < 0.06){
          setTimeout(finalizeRuleta, 700);
        }
      } else {
        // idle sway
        wheel.rotation.z += Math.sin(clock.elapsedTime*0.5)*0.0005;
        ball.position.y = 2.1 + Math.sin(clock.elapsedTime*0.7)*0.015;
      }

      // update minimap
      drawMinimap();

      renderer.render(scene, camera);
    }
    animate();

    // ----- Resize handling -----
    window.addEventListener('resize', ()=>{
      renderer.setSize(wrap.clientWidth, wrap.clientHeight);
      camera.aspect = wrap.clientWidth / wrap.clientHeight; camera.updateProjectionMatrix();
    });

    // ----- Utilities & initial state -----
    updateHUD(); appendLog('Listo: mueve con WASD, gira cÃ¡mara con flechas, interactÃºa con E.');
    // show a small center notice briefly
    const centerNotice = document.getElementById('centerNotice');
    centerNotice.style.display='block';
    centerNotice.textContent='WASD moverse Â· Flechas girar cÃ¡mara Â· E interactuar';
    setTimeout(()=>centerNotice.style.display='none', 3000);

    // keep player within room floor height
    player.position.y = 0.1;

  })();
  </script>
</body>
</html>
