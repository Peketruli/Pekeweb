<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Casino 3D - Ruleta corregida + f√≠sicas b√°sicas</title>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<style>
  body { margin:0; overflow:hidden; background:#000; font-family:Arial, Helvetica, sans-serif; }
  #hint {
    position: absolute; left: 12px; top: 12px; z-index: 5;
    background: rgba(0,0,0,0.6); color: #fff; padding:8px 10px; border-radius:8px;
    font-size:13px;
  }
  #credits {
    position: absolute; right: 12px; top: 12px; z-index: 5;
    background: rgba(0,0,0,0.45); color:#ddd; padding:6px 8px; border-radius:6px; font-size:12px;
  }
</style>
</head>
<body>
<div id="hint">üé∞ Mover: W A S D ‚Äî Mirar: rat√≥n</div>
<div id="credits">Casino cl√°sico ‚Äî f√≠sicas b√°sicas + ruleta corregida</div>

<script>
// ---------- ESCENA ----------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x060304);
scene.fog = new THREE.FogExp2(0x060304, 0.012);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 1.7, 12); // un poco m√°s atr√°s

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// ---------- ILUMINACI√ìN ----------
scene.add(new THREE.AmbientLight(0xffecd6, 0.45));
const dir = new THREE.DirectionalLight(0xffe0b5, 0.6);
dir.position.set(5, 20, 10);
dir.castShadow = true;
scene.add(dir);

// ---------- SUELO ----------
const floorTex = new THREE.TextureLoader().load("https://cdn.pixabay.com/photo/2016/11/21/15/55/pattern-1846866_1280.jpg");
floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
floorTex.repeat.set(8, 8);
const floorMat = new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.9 });
const floor = new THREE.Mesh(new THREE.PlaneGeometry(80,80), floorMat);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// ---------- PAREDES ----------
const wallMat = new THREE.MeshStandardMaterial({ color:0x3d1f0f, roughness:1 });
const back = new THREE.Mesh(new THREE.BoxGeometry(40,8,0.8), wallMat);
back.position.set(0,4,-30);
scene.add(back);
const front = back.clone(); front.position.set(0,4,30); scene.add(front);
const left = new THREE.Mesh(new THREE.BoxGeometry(0.8,8,60), wallMat);
left.position.set(-20,4,0); scene.add(left);
const right = left.clone(); right.position.set(20,4,0); scene.add(right);

// ---------- MESA DE BLACKJACK ----------
const feltCanvas = document.createElement('canvas');
feltCanvas.width = feltCanvas.height = 512;
const fctx = feltCanvas.getContext('2d');
fctx.fillStyle = '#0b5b35';
fctx.fillRect(0,0,512,512);
for(let i=0;i<30000;i++){
  fctx.fillStyle = `rgba(0,0,0,${Math.random()*0.2})`;
  fctx.fillRect(Math.random()*512, Math.random()*512,1,1);
}
const feltTex = new THREE.CanvasTexture(feltCanvas);

const tableTop = new THREE.Mesh(
  new THREE.CylinderGeometry(4.2, 4.2, 0.4, 32),
  new THREE.MeshStandardMaterial({ map: feltTex, roughness:0.8 })
);
tableTop.position.set(0, 0.6, 6);
tableTop.castShadow = true;
scene.add(tableTop);

// ---------- RULETA (ahora correctamente horizontal) ----------
const wheelGroup = new THREE.Group();

// base
const wheelBase = new THREE.Mesh(
  new THREE.CylinderGeometry(2.2,2.2,0.5,48),
  new THREE.MeshStandardMaterial({ color:0x3b1f0e })
);
wheelBase.position.y = 0.5;
wheelGroup.add(wheelBase);

// aro exterior
const rim = new THREE.Mesh(
  new THREE.TorusGeometry(2.3,0.18,16,100),
  new THREE.MeshStandardMaterial({ color:0x4a2b12 })
);
rim.rotation.x = Math.PI/2;
rim.position.y = 0.8;
wheelGroup.add(rim);

// tablero
const wheelCanvas = document.createElement('canvas');
wheelCanvas.width = 1024; wheelCanvas.height = 1024;
const ctx = wheelCanvas.getContext('2d');
const cx = 512, cy = 512, r = 420;
for(let i=0;i<36;i++){
  ctx.beginPath();
  const a0 = (i/36)*Math.PI*2;
  const a1 = ((i+1)/36)*Math.PI*2;
  ctx.moveTo(cx,cy);
  ctx.arc(cx,cy,r,a0,a1);
  ctx.closePath();
  ctx.fillStyle = (i%2===0)?'#b30000':'#111';
  ctx.fill();
}
ctx.beginPath(); ctx.arc(cx,cy,120,0,Math.PI*2); ctx.fillStyle='#ccc'; ctx.fill();
const wheelTex = new THREE.CanvasTexture(wheelCanvas);

const plate = new THREE.Mesh(
  new THREE.CylinderGeometry(1.9,1.9,0.08,64),
  new THREE.MeshStandardMaterial({ map: wheelTex })
);
plate.rotation.x = -Math.PI/2; // ‚Üê antes estaba vertical, ahora horizontal
plate.position.y = 0.86;
wheelGroup.add(plate);

wheelGroup.position.set(-10, 0, 8);
wheelGroup.castShadow = true;
scene.add(wheelGroup);

// ---------- TRAGAPERRAS ----------
const machines = [];
for(let i=0;i<6;i++){
  const g = new THREE.Group();
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(1.6, 2.6, 1.2),
    new THREE.MeshStandardMaterial({ color: 0x2b1a14 })
  );
  body.position.y = 1.3;
  g.add(body);
  g.position.set(i*3 - 7.5, 0, -12);
  scene.add(g);
  machines.push(g);
}

// ---------- MOVIMIENTO ----------
let yaw=0, pitch=0;
const sens=0.0026;
window.addEventListener('mousemove',(e)=>{
  yaw -= e.movementX*sens;
  pitch -= e.movementY*sens;
  const maxPitch=Math.PI/2-0.05;
  pitch=Math.max(-maxPitch,Math.min(maxPitch,pitch));
});
const keys={};
window.addEventListener('keydown',e=>keys[e.code]=true);
window.addEventListener('keyup',e=>keys[e.code]=false);

const velocity=new THREE.Vector3();
const accel=30, damping=10;
const forwardVec=new THREE.Vector3(), rightVec=new THREE.Vector3(), upVec=new THREE.Vector3(0,1,0);

const colliders=[];

// registrar colisionadores simples (AABB)
function addCollider(mesh,size=2){
  colliders.push({pos:mesh.position.clone(), size});
}
addCollider(tableTop,4.2);
machines.forEach(m=>addCollider(m,1.2));
addCollider(wheelGroup,2.5);
addCollider(back,2);
addCollider(front,2);
addCollider(left,2);
addCollider(right,2);

function updateMovement(dt){
  camera.rotation.set(pitch,yaw,0,"ZYX");
  camera.updateMatrixWorld();
  camera.getWorldDirection(forwardVec);
  forwardVec.y=0; forwardVec.normalize();
  rightVec.copy(forwardVec).cross(upVec).negate();

  let moveX=0, moveZ=0;
  if(keys['KeyW']) moveZ+=1;
  if(keys['KeyS']) moveZ-=1;
  if(keys['KeyD']) moveX-=1;
  if(keys['KeyA']) moveX+=1;

  const desired=new THREE.Vector3();
  desired.addScaledVector(forwardVec,moveZ);
  desired.addScaledVector(rightVec,moveX);
  if(desired.lengthSq()>0) desired.normalize();

  velocity.addScaledVector(desired, accel*dt);
  velocity.multiplyScalar(1/(1+damping*dt));

  const nextPos=camera.position.clone().addScaledVector(velocity,dt);

  // --- colisiones ---
  for(const c of colliders){
    const dist=nextPos.clone().sub(c.pos);
    const minDist=1.2+c.size;
    if(Math.abs(dist.x)<minDist && Math.abs(dist.z)<minDist){
      if(dist.length()<minDist){
        velocity.multiplyScalar(0.2); // frena
        return; // bloquea movimiento
      }
    }
  }

  camera.position.addScaledVector(velocity,dt);
}

// ---------- LOOP ----------
const clock=new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const dt=Math.min(clock.getDelta(),0.05);
  updateMovement(dt);
  wheelGroup.rotation.y += 0.02;
  renderer.render(scene,camera);
}
animate();

// ---------- RESIZE ----------
window.addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
