<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Casino 3D - Movimiento funcional</title>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/PointerLockControls.js"></script>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
    font-family: Arial, sans-serif;
    cursor: pointer;
  }
  #overlay {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.85);
    color: white;
    font-size: 1.5em;
    z-index: 5;
  }
</style>
</head>
<body>

<div id="overlay">üé∞ Haz clic en cualquier parte para entrar al casino üéÆ</div>

<script>
// === ESCENA ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050505);

// === C√ÅMARA ===
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 1.7, 8);

// === RENDER ===
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// === LUCES ===
scene.add(new THREE.AmbientLight(0xffffff,0.4));
const pointLight = new THREE.PointLight(0xff00ff, 3, 30);
pointLight.position.set(0,5,0);
scene.add(pointLight);

// === SUELO Y PAREDES ===
const floorMat = new THREE.MeshStandardMaterial({color:0x222222});
const floor = new THREE.Mesh(new THREE.PlaneGeometry(50,50), floorMat);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

const wallMat = new THREE.MeshStandardMaterial({color:0x330033});
const backWall = new THREE.Mesh(new THREE.BoxGeometry(50,10,1), wallMat);
backWall.position.set(0,5,-25);
scene.add(backWall);

const leftWall = new THREE.Mesh(new THREE.BoxGeometry(1,10,50), wallMat);
leftWall.position.set(-25,5,0);
scene.add(leftWall);

const rightWall = new THREE.Mesh(new THREE.BoxGeometry(1,10,50), wallMat);
rightWall.position.set(25,5,0);
scene.add(rightWall);

// === OBJETOS ===
const slotMat = new THREE.MeshStandardMaterial({color:0xff00ff,emissive:0x330033});
for(let i=0;i<6;i++){
    const slot = new THREE.Mesh(new THREE.BoxGeometry(1.5,2.5,1.5), slotMat);
    slot.position.set(i*3-7.5,1.25,-10);
    scene.add(slot);
}

const table = new THREE.Mesh(new THREE.CylinderGeometry(5,5,0.5,32), new THREE.MeshStandardMaterial({color:0x004400}));
table.position.set(0,0.25,0);
scene.add(table);

const ruleta = new THREE.Mesh(new THREE.CylinderGeometry(2,2,0.3,32), new THREE.MeshStandardMaterial({color:0x990000}));
ruleta.position.set(-10,0.15,5);
scene.add(ruleta);

// === CONTROLES ===
const controls = new THREE.PointerLockControls(camera, document.body);
scene.add(controls.getObject());

const overlay = document.getElementById("overlay");
overlay.addEventListener("click", ()=>{
    controls.lock(); // clic directo activa el PointerLock
});

controls.addEventListener("lock", ()=>{ overlay.style.display = "none"; });
controls.addEventListener("unlock", ()=>{ overlay.style.display = "flex"; });

// === MOVIMIENTO ===
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();
const keys = {};
document.addEventListener("keydown",(e)=>keys[e.code]=true);
document.addEventListener("keyup",(e)=>keys[e.code]=false);

const clock = new THREE.Clock();

function animate(){
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    const speed = 8.0;

    if(controls.isLocked){
        direction.z = Number(keys["KeyW"]) - Number(keys["KeyS"]);
        direction.x = Number(keys["KeyD"]) - Number(keys["KeyA"]);
        direction.normalize();
        velocity.x = direction.x * speed * delta;
        velocity.z = direction.z * speed * delta;
        controls.moveRight(velocity.x);
        controls.moveForward(velocity.z);
    }

    ruleta.rotation.y += 0.01;
    renderer.render(scene,camera);
}

animate();

window.addEventListener("resize", ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
