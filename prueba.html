<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Casino 3D</title>
<style>
  :root{--bg:#0b0f1a;--panel:#101625;--accent:#f5b642;--muted:#9aa5b1}
  html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:white;overflow:hidden}
  #container{width:100%;height:100%}
  #ui{position:absolute;top:12px;left:12px;z-index:50}
  .panel{background:rgba(0,0,0,0.45);padding:10px;border-radius:8px;margin-bottom:8px;backdrop-filter:blur(4px)}
  #modal{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    width:460px;max-width:95vw;background:var(--panel);padding:18px;border-radius:12px;
    display:none;z-index:100;max-height:80vh;overflow:auto;box-shadow:0 8px 30px rgba(0,0,0,0.6)
  }
  #npcMsg{position:absolute;bottom:12px;left:50%;transform:translateX(-50%);
    background:rgba(0,0,0,0.6);padding:8px 12px;border-radius:8px;display:none}
  button,input,select{background:#182034;color:white;border:1px solid #334;padding:8px;border-radius:8px;margin:6px 0;cursor:pointer}
  .gameUI h2{margin:4px 0 10px 0;text-align:center}
  .gameUI{display:flex;flex-direction:column;align-items:center}
  .gameUI .row{width:100%;display:flex;gap:8px;justify-content:center}
  .gameResult{margin-top:10px;color:var(--accent);min-height:30px;text-align:center}
  label{font-size:0.95rem}
  input[type=number]{width:100px;padding:6px;border-radius:6px}
  .small{font-size:0.85rem;color:#c3cbd2}
</style>
</head>
<body>
<div id="container"></div>

<div id="ui" class="panel">
  <div>Pekepuntos: <strong id="balance">0</strong></div>
  <div class="small">Pulsa <b>E</b> para interactuar ‚Äî mueve con WASD y rota con flechas</div>
</div>

<div id="modal" role="dialog" aria-modal="true"></div>
<div id="npcMsg">Pulsa E para recoger fichas diarias</div>

<!-- three.js -->
<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>

<script>
/* ====== CASINO 3D: versi√≥n corregida (persistencia siempre en Supabase) ======
   - Aseg√∫rate de pegar esto reemplazando scripts previos.
   - Usa la consola del navegador (F12) para ver errores si algo falla.
   - Nota: utiliza la UMD de supabase (dist/umd) para exponer window.supabase correctamente.
*/

(async function(){
  const SUPABASE_URL = 'https://jdvwlfogkzrzovepzjqa.supabase.co';
  const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpkdndsZm9na3pyem92ZXB6anFhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwMzY1MjEsImV4cCI6MjA3MzYxMjUyMX0.IwVFrvuluY0tfgE82XnqYSsRjFPsDYnlfyirHjKu1TI';

  // ---------- init supabase UMD reliably ----------
  let supabase = null;
  async function ensureSupabase(){
    try {
      if(window.supabase && typeof window.supabase.createClient === 'function'){
        supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        console.log('Supabase: using existing window.supabase');
        return;
      }
      // load UMD bundle that exposes window.supabase
      await new Promise((res, rej) => {
        const s = document.createElement('script');
        s.src = 'https://unpkg.com/@supabase/supabase-js/dist/umd/supabase.min.js';
        s.onload = res;
        s.onerror = () => rej(new Error('No se pudo cargar supabase UMD'));
        document.head.appendChild(s);
      });
      if(window.supabase && typeof window.supabase.createClient === 'function'){
        supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        console.log('Supabase inicializado correctamente (UMD).');
      } else {
        console.warn('Supabase cargado pero window.supabase.createClient no es una funci√≥n.');
        supabase = null;
      }
    } catch (e){
      console.warn('No se pudo inicializar Supabase:', e);
      supabase = null;
    }
  }
  await ensureSupabase();

  // ---------- DOM refs (safe) ----------
  const container = document.getElementById('container') || document.body;
  const modalEl = document.getElementById('modal') || null;
  // soporta tanto tu #balance (strong) como #pekepuntos antiguo
  let balanceEl = document.getElementById('balance') || document.getElementById('pekepuntos');
  if(!balanceEl){
    balanceEl = document.createElement('div');
    balanceEl.id = 'balance';
    balanceEl.style.position = 'absolute';
    balanceEl.style.left = '12px';
    balanceEl.style.top = '12px';
    balanceEl.style.zIndex = 999;
    balanceEl.style.color = 'white';
    document.body.appendChild(balanceEl);
  }

  // ---------- estado de usuario ----------
  let currentUser = null;
  let balance = 0;

  // ---------- util helpers ----------
  const rand = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
  const clamp = (v,a,b) => Math.max(a, Math.min(b,v));
  function safeLog() { try{ console.log.apply(console, arguments); }catch(e){} }

  // ---------- funciones supabase/usuario ----------
  async function promptUsername(){
    // breve prompt fallback; puedes reemplazar por tu login m√°s tarde
    let name = prompt('Nombre de usuario para el Casino (sin espacios):', 'Guest'+Math.floor(Math.random()*9000+1000));
    if(name === null) return null;
    name = String(name).trim().replace(/\s+/g,'_').slice(0,50) || ('Guest' + Math.floor(Math.random()*10000));
    return name;
  }

  async function findUser(username){
    if(!supabase) return null;
    try {
      const { data, error } = await supabase.from('usuarios').select('*').eq('username', username).limit(1).single();
      if(error){
        // si no existe data, data ser√° null; pero single() lanza error cuando no hay filas.
        if(error.code === 'PGRST116' || /No rows/.test(error.message)) return null;
        console.warn('findUser supabase error', error);
        return null;
      }
      return data || null;
    } catch (e){
      console.warn('findUser exception', e);
      return null;
    }
  }

  async function createUser(username){
    if(!supabase) return null;
    try {
      const now = new Date().toISOString();
      const payload = { username, pekepuntos: 500, last_claim: null, created_at: now };
      // insert y devolver la fila
      const { data, error } = await supabase.from('usuarios').insert([payload]).select().single();
      if(error){ console.warn('createUser error', error); return null; }
      return data;
    } catch(e){
      console.warn('createUser exception', e);
      return null;
    }
  }

  async function getOrCreateUserFlow(){
    let name = await promptUsername();
    if(!name){
      // si cancel√≥, creamos guest r√°pido
      name = 'Guest' + Math.floor(Math.random()*10000);
      safeLog('Usuario cancel√≥ prompt. Generado:', name);
    }
    // buscar
    let user = await findUser(name);
    if(user) return user;
    // no existe: crear (si da error por RLS o permisos, createUser devolver√° null)
    user = await createUser(name);
    if(user) return user;
    // como fallback, devolver objeto local no persistido
    return { id: null, username: name, pekepuntos: 500, last_claim: null };
  }

  async function updateBalanceOnServer(){
    // intenta actualizar la fila del usuario en supabase; si user.id es null, intenta por username (upsert)
    if(!supabase || !currentUser) { refreshBalanceUI(); return; }
    try {
      if(currentUser.id){
        const { data, error } = await supabase.from('usuarios')
          .update({ pekepuntos: balance, last_claim: currentUser.last_claim || null })
          .eq('id', currentUser.id)
          .select()
          .single();
        if(error){
          console.warn('updateBalance (by id) error', error);
          // intentar upsert por username
          const { data: up, error: errUp } = await supabase.from('usuarios')
            .upsert({ username: currentUser.username, pekepuntos: balance, last_claim: currentUser.last_claim || null }, { onConflict: 'username' })
            .select()
            .single();
          if(errUp) { console.warn('upsert fallback error', errUp); }
          else { currentUser = up; }
        } else {
          currentUser = data;
        }
      } else {
        // upsert por username si no hay id
        const { data, error } = await supabase.from('usuarios')
          .upsert({ username: currentUser.username, pekepuntos: balance, last_claim: currentUser.last_claim || null }, { onConflict: 'username' })
          .select()
          .single();
        if(error){ console.warn('updateBalance upsert error', error); }
        else currentUser = data;
      }
    } catch (e){
      console.warn('updateBalance exception', e);
    } finally {
      refreshBalanceUI();
      try { await updateTop10(); } catch(e){ /* no bloqueante */ }
    }
  }

  async function logActivity(accion, detalle = ''){
    if(!supabase || !currentUser) return;
    try {
      await supabase.from('actividad').insert([{ usuario: currentUser.username, accion, detalle, fecha: new Date().toISOString() }]);
    } catch(e){ console.warn('logActivity error', e); }
  }

  function refreshBalanceUI(){
    if(!balanceEl) return;
    // si es el #pekepuntos antiguo, mantenemos formato
    if(balanceEl.id === 'pekepuntos') balanceEl.textContent = `Pekepuntos: ${Number(balance || 0).toLocaleString()}`;
    else balanceEl.textContent = Number(balance || 0).toLocaleString();
    const userNameEl = document.getElementById('userName');
    if(userNameEl && currentUser) userNameEl.textContent = currentUser.username || 'Usuario';
  }

  // cargar/crear usuario
  try {
    currentUser = await getOrCreateUserFlow();
    balance = Number(currentUser.pekepuntos || 0);
    refreshBalanceUI();
    await logActivity('Entr√≥ al casino');
    safeLog('Usuario cargado:', currentUser);
  } catch (err){
    console.error('Error init user flow', err);
    alert('Error inicializando usuario, mira la consola.');
  }

  // -------------------- THREE.JS (esqueleto) --------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0f1a);

  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0,1.6,5);
  camera.rotation.order = 'YXZ';

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  try { renderer.outputColorSpace = THREE.SRGBColorSpace; } catch(e){}
  container.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff, 0.22));
  const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.8); hemi.position.set(0,50,0); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xfff6d6, 0.6); dir.position.set(5,10,5); dir.castShadow = true; scene.add(dir);

  function canvasTexture(size, drawFn){
    const c = document.createElement('canvas'); c.width = c.height = size;
    const ctx = c.getContext('2d'); drawFn(ctx, size);
    const tex = new THREE.CanvasTexture(c); tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.needsUpdate = true;
    return tex;
  }

  // floor b√°sico
  const floorTex = canvasTexture(512, (ctx,s) => { ctx.fillStyle='#0b0b12'; ctx.fillRect(0,0,s,s); });
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(30,30), new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.95 }));
  floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

  // TOP10 wall
  async function updateTop10(){
    if(!supabase) return;
    try {
      const { data, error } = await supabase.from('usuarios').select('username, pekepuntos').order('pekepuntos', { ascending: false }).limit(10);
      if(error){ console.warn('updateTop10 error', error); return; }
      const s = 1024;
      const tex = canvasTexture(s, (ctx) => {
        ctx.fillStyle = '#071018'; ctx.fillRect(0,0,s,s);
        ctx.fillStyle = '#f5b642'; ctx.font = '48px Arial'; ctx.textAlign='center'; ctx.fillText('TOP 10', s/2, 70);
        ctx.font = '26px Arial'; ctx.textAlign='left'; ctx.fillStyle = '#fff';
        data.forEach((r,i) => { const y = 140 + i*64; ctx.fillText(`${i+1}. ${r.username}`, 60, y); ctx.fillText((r.pekepuntos||0).toLocaleString(), s-140, y); });
      });
      const name = 'top10Wall';
      const existing = scene.getObjectByName(name);
      if(!existing){
        const wall = new THREE.Mesh(new THREE.PlaneGeometry(8,5), new THREE.MeshStandardMaterial({ map: tex, side:THREE.DoubleSide }));
        wall.position.set(0,2,-14.9); wall.name = name; scene.add(wall);
      } else {
        existing.material.map = tex; existing.material.needsUpdate = true;
      }
    } catch(e){ console.warn('updateTop10 exception', e); }
  }
  await updateTop10();
  setInterval(updateTop10, 60_000);

  // objetos interactables (sencillos)
  const interactables = [];
  const bjTable = new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.6,0.3,64), new THREE.MeshStandardMaterial({ color: 0x084b2f }));
  bjTable.position.set(-4,0.3,0); bjTable.userData.type='blackjack'; bjTable.castShadow=true; scene.add(bjTable); interactables.push(bjTable);

  const ruletaBase = new THREE.Mesh(new THREE.CylinderGeometry(1.2,1.2,0.4,64), new THREE.MeshStandardMaterial({ color:0x222222 }));
  ruletaBase.position.set(0,0.2,0); ruletaBase.userData.type='roulette'; ruletaBase.castShadow=true; scene.add(ruletaBase); interactables.push(ruletaBase);

  const ruletaDisk = new THREE.Mesh(new THREE.CylinderGeometry(1.15,1.15,0.08,256), new THREE.MeshStandardMaterial({ map: null }));
  ruletaDisk.rotation.x = Math.PI; ruletaDisk.position.set(0,0.45,0); ruletaDisk.castShadow=true; scene.add(ruletaDisk);

  // crear textura ruleta (copia simple)
  (function createRouletteTexture(){
    const s = 1024;
    const c = document.createElement('canvas'); c.width = c.height = s;
    const ctx = c.getContext('2d'); ctx.translate(s/2, s/2);
    const cell = 37; const anglePer = (Math.PI*2)/cell;
    ctx.fillStyle='#2f1b10'; ctx.beginPath(); ctx.arc(0,0,s/2,0,Math.PI*2); ctx.fill();
    for(let i=0;i<cell;i++){
      const start = i*anglePer - Math.PI/2; ctx.save(); ctx.rotate(start + anglePer/2);
      ctx.fillStyle = i===0 ? '#0b8a12' : (i%2? '#d22':'#111');
      ctx.fillRect(-s*0.18, -s*0.48, s*0.36, s*0.24);
      ctx.fillStyle = '#fff'; ctx.font = '20px Arial'; ctx.textAlign='center'; ctx.fillText(i.toString(), 0, -s*0.36);
      ctx.restore();
    }
    const tex = new THREE.CanvasTexture(c); tex.needsUpdate = true; ruletaDisk.material.map = tex; ruletaDisk.material.needsUpdate = true;
  })();

  // slot proxy
  const slotProxy = new THREE.Mesh(new THREE.BoxGeometry(1.05,2.05,1.05), new THREE.MeshBasicMaterial({ visible:false }));
  slotProxy.position.set(4,1,0); slotProxy.userData.type='slots'; scene.add(slotProxy); interactables.push(slotProxy);

  // npc
  const npc = new THREE.Mesh(new THREE.CylinderGeometry(0.42,0.42,1.6,16), new THREE.MeshStandardMaterial({ color:0xdddddd }));
  npc.position.set(0,1,5); npc.userData.type='npc'; scene.add(npc); interactables.push(npc);

  // movimiento y c√°mara (tu implementaci√≥n)
  const keys = {};
  document.addEventListener('keydown', e => keys[e.code] = true);
  document.addEventListener('keyup', e => keys[e.code] = false);

  let yaw = 0, pitch = 0;
  function updateCamera(dt){
    const yawSpeed = 1.8, pitchSpeed = 1.2;
    if(keys['ArrowLeft']) yaw += yawSpeed * dt;
    if(keys['ArrowRight']) yaw -= yawSpeed * dt;
    if(keys['ArrowUp']) pitch += pitchSpeed * dt;
    if(keys['ArrowDown']) pitch -= pitchSpeed * dt;
    const limit = Math.PI/2 - 0.05;
    pitch = Math.max(-limit, Math.min(limit, pitch));
    camera.rotation.set(pitch, yaw, 0);

    const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
    const right = new THREE.Vector3(); right.crossVectors(forward, camera.up).normalize();
    const move = new THREE.Vector3();
    if(keys['KeyW']) move.add(forward);
    if(keys['KeyS']) move.sub(forward);
    if(keys['KeyD']) move.add(right);
    if(keys['KeyA']) move.sub(right);
    move.multiplyScalar(3 * dt);
    camera.position.add(move);
  }

  // raycast interactions
  const ray = new THREE.Raycaster();
  let lookingAt = null;
  const npcMsgEl = document.getElementById('npcMsg') || (function(){
    const d = document.createElement('div'); d.id='npcMsg';
    d.style.position='absolute'; d.style.bottom='12px'; d.style.left='50%'; d.style.transform='translateX(-50%)';
    d.style.background='rgba(0,0,0,0.6)'; d.style.padding='8px 12px'; d.style.borderRadius='8px'; d.style.display='none'; d.style.color='white';
    document.body.appendChild(d); return d;
  })();

  function checkInteraction(){
    ray.set(camera.position, camera.getWorldDirection(new THREE.Vector3()));
    const hits = ray.intersectObjects(interactables, false);
    if(!hits.length || hits[0].distance > 4){ lookingAt = null; npcMsgEl.style.display = 'none'; return; }
    lookingAt = hits[0].object;
    npcMsgEl.style.display = 'block';
    if(lookingAt.userData.type === 'npc') npcMsgEl.textContent = 'Pulsa E para recoger fichas diarias';
    else npcMsgEl.textContent = 'Pulsa E para interactuar';
  }

  // UI helpers (m√≠nimos)
  function showUI(html){
    if(modalEl){ modalEl.innerHTML = html; modalEl.style.display = 'block'; return; }
    const tmp = document.createElement('div');
    tmp.style.position='absolute'; tmp.style.left='50%'; tmp.style.top='50%'; tmp.style.transform='translate(-50%,-50%)';
    tmp.style.background='rgba(16,22,37,0.95)'; tmp.style.padding='18px'; tmp.style.borderRadius='10px'; tmp.style.color='white';
    tmp.innerHTML = html; document.body.appendChild(tmp);
    setTimeout(()=> tmp.remove(), 3000);
  }
  function hideUI(){ if(modalEl) modalEl.style.display = 'none'; }

  // ---------- Daily claim ----------
  async function claimDaily(){
    const today = new Date().toISOString().slice(0,10);
    const last = currentUser && currentUser.last_claim ? currentUser.last_claim.slice(0,10) : null;
    if(last === today){
      showUI(`<div class="gameUI"><h2>Recompensa diaria</h2><div class="gameResult">Ya reclamaste hoy.</div></div>`);
      return;
    }
    balance += 100;
    if(currentUser) currentUser.last_claim = new Date().toISOString();
    await updateBalanceOnServer();
    await logActivity('Reclam√≥ diaria', '+100');
    showUI(`<div class="gameUI"><h2>Recompensa diaria</h2><div class="gameResult">Recibiste +100 Pekepuntos.</div></div>`);
  }

  // ---------- Juegos simples que persisten en servidor ----------
  // Blackjack minimal (apuesta fija)
  async function openBlackjack(){
    const bet = Math.min(50, balance);
    if(!bet){ showUI('<div class="gameResult">Saldo insuficiente</div>'); return; }
    // simulaci√≥n r√°pida: 50% win
    const win = Math.random() < 0.5;
    if(win){ balance += bet; await updateBalanceOnServer(); await logActivity('Blackjack win', `+${bet}`); showUI(`<div class="gameResult">Ganas ${bet}</div>`); }
    else { balance -= bet; await updateBalanceOnServer(); await logActivity('Blackjack lose', `-${bet}`); showUI(`<div class="gameResult">Pierdes ${bet}</div>`); }
  }

  // Ruleta simple
  async function openRoulette(){
    showUI(`<div class="gameUI"><h2>Ruleta</h2><div class="gameResult" id="rResult"></div></div>`);
    const bet = Math.min(50, balance);
    if(!bet){ showUI('<div class="gameResult">Saldo insuficiente</div>'); return; }
    // retiramos apuesta y persistimos inmediatamente
    balance -= bet; await updateBalanceOnServer();
    const landing = rand(0,36);
    const win = (landing % 2 === 0);
    if(win){ const payout = bet*2; balance += payout; await updateBalanceOnServer(); await logActivity('Ruleta win', `+${payout}`); showUI(`<div class="gameResult">Sale ${landing} ‚Äî Ganaste ${payout}</div>`); }
    else { await logActivity('Ruleta lose', `-${bet}`); showUI(`<div class="gameResult">Sale ${landing} ‚Äî Perdiste ${bet}</div>`); }
  }

  // Slots simple
  async function openSlots(){
    const bet = Math.min(50, balance);
    if(!bet){ showUI('<div class="gameResult">Saldo insuficiente</div>'); return; }
    balance -= bet; await updateBalanceOnServer();
    // animaci√≥n simb√≥lica
    const symbols = ['üçí','üçã','üçä','üçá','üíé','7Ô∏è‚É£'];
    const final = [symbols[rand(0,symbols.length-1)], symbols[rand(0,symbols.length-1)], symbols[rand(0,symbols.length-1)]];
    if(final[0]===final[1] && final[1]===final[2]){ const payout = bet*5; balance += payout; await updateBalanceOnServer(); await logActivity('Slots win', `+${payout}`); showUI(`<div class="gameResult">¬°Jackpot! Ganaste ${payout}</div>`); }
    else if(final[0]===final[1]||final[1]===final[2]||final[0]===final[2]){ const payout = bet*2; balance += payout; await updateBalanceOnServer(); await logActivity('Slots pair', `+${payout}`); showUI(`<div class="gameResult">Dos iguales ‚Äî Ganaste ${payout}</div>`); }
    else { await logActivity('Slots lose', `-${bet}`); showUI(`<div class="gameResult">Perdiste ${bet}</div>`); }
  }

  // manejar tecla E
  document.addEventListener('keydown', async (e) => {
    if(e.code !== 'KeyE') return;
    if(!lookingAt) return;
    const t = lookingAt.userData.type;
    if(t === 'npc'){ await claimDaily(); return; }
    if(t === 'blackjack'){ await openBlackjack(); return; }
    if(t === 'roulette'){ await openRoulette(); return; }
    if(t === 'slots'){ await openSlots(); return; }
  });

  // anim loop
  const clock = new THREE.Clock();
  function animate(){
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    updateCamera(dt);
    checkInteraction();
    renderer.render(scene, camera);
  }
  animate();

  // resize
  window.addEventListener('resize', ()=> {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // API externa
  window._casino = {
    getCurrentUser: () => currentUser,
    getBalance: () => balance,
    addBalance: async (amt, reason='') => { balance += amt; await updateBalanceOnServer(); if(reason) await logActivity('Add', reason); },
    subBalance: async (amt, reason='') => { balance -= amt; await updateBalanceOnServer(); if(reason) await logActivity('Sub', reason); }
  };

  safeLog('Casino 3D iniciado. Supabase:', supabase ? 'OK' : 'NO DISPONIBLE');
})();
</script>
</body>
</html>
