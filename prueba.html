<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Casino 3D</title>
<style>
  :root{--bg:#0b0f1a;--panel:#101625;--accent:#f5b642;--muted:#9aa5b1}
  html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:white;overflow:hidden}
  #container{width:100%;height:100%}
  #ui{position:absolute;top:12px;left:12px;z-index:50}
  .panel{background:rgba(0,0,0,0.45);padding:10px;border-radius:8px;margin-bottom:8px;backdrop-filter:blur(4px)}
  #modal{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    width:460px;max-width:95vw;background:var(--panel);padding:18px;border-radius:12px;
    display:none;z-index:100;max-height:80vh;overflow:auto;box-shadow:0 8px 30px rgba(0,0,0,0.6)
  }
  #npcMsg{position:absolute;bottom:12px;left:50%;transform:translateX(-50%);
    background:rgba(0,0,0,0.6);padding:8px 12px;border-radius:8px;display:none}
  button,input,select{background:#182034;color:white;border:1px solid #334;padding:8px;border-radius:8px;margin:6px 0;cursor:pointer}
  .gameUI h2{margin:4px 0 10px 0;text-align:center}
  .gameUI{display:flex;flex-direction:column;align-items:center}
  .gameUI .row{width:100%;display:flex;gap:8px;justify-content:center}
  .gameResult{margin-top:10px;color:var(--accent);min-height:30px;text-align:center}
  label{font-size:0.95rem}
  input[type=number]{width:100px;padding:6px;border-radius:6px}
  .small{font-size:0.85rem;color:#c3cbd2}
</style>
</head>
<body>
<div id="container"></div>

<div id="ui" class="panel">
  <div>Pekepuntos: <strong id="balance">0</strong></div>
  <div class="small">Pulsa <b>E</b> para interactuar â€” mueve con WASD y rota con flechas</div>
</div>

<div id="modal" role="dialog" aria-modal="true"></div>
<div id="npcMsg">Pulsa E para recoger fichas diarias</div>

<!-- three.js -->
<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>

<script>

(async function(){
  const SUPABASE_URL = 'https://jdvwlfogkzrzovepzjqa.supabase.co';
  const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpkdndsZm9na3pyem92ZXB6anFhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwMzY1MjEsImV4cCI6MjA3MzYxMjUyMX0.IwVFrvuluY0tfgE82XnqYSsRjFPsDYnlfyirHjKu1TI';

  // Inicializa supabase (umd)
  let supabase = null;
  try {
    if(window.supabase && window.supabase.createClient){
      supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    } else {
      // si la lib no estÃ¡ cargada, cargamos la versiÃ³n CDN (fallback)
      await new Promise((res, rej) => {
        const s = document.createElement('script');
        s.src = 'https://unpkg.com/@supabase/supabase-js';
        s.onload = res; s.onerror = rej;
        document.head.appendChild(s);
      });
      supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    }
  } catch (err) {
    console.error('No se pudo inicializar supabase:', err);
    alert('Supabase no se pudo inicializar. Revisa consola.');
    supabase = null;
  }

  // DOM refs
  const balanceEl = document.getElementById('balance') || document.getElementById('pekepuntos') || (() => { const d=document.createElement('div'); d.id='balance'; document.body.prepend(d); return d; })();
  const modalEl = document.getElementById('modal') || null;
  const container = document.getElementById('container') || document.body;

  // Estado de usuario
  let currentUser = null;
  let balance = 0;

  // Helpers
  const rand = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
  const clamp = (v,a,b) => Math.max(a,Math.min(b,v));

  // FUNCIONES SUPABASE / USUARIO ---------------------------------------
  async function promptUsername(){
    // Sencillo: pedir nombre con prompt. Puedes sustituir aquÃ­ por login real.
    let name = '';
    while(!name){
      name = prompt('Introduce tu nombre de usuario para jugar en el Casino (sin espacios):','Guest' + Math.floor(Math.random()*999));
      if(name === null) { // usuario cancelÃ³
        alert('Necesitas un nombre para jugar. Se crea un usuario Guest automÃ¡ticamente.');
        name = 'Guest' + Math.floor(Math.random()*10000);
        break;
      }
      name = String(name).trim();
      if(!name) alert('Nombre vacÃ­o, prueba otro.');
    }
    return name;
  }

  async function findUserByUsername(username){
    if(!supabase) return null;
    const { data, error } = await supabase.from('usuarios').select('*').eq('username', username).limit(1).single();
    if(error && error.code !== 'PGRST116') { // PGRST116 = no rows? check
      // not fatal, but log
      console.warn('findUser error', error);
    }
    return data || null;
  }

  async function createUser(username){
    if(!supabase) return null;
    const now = new Date().toISOString();
    const payload = {
      username,
      pekepuntos: 500,
      last_claim: null,
      created_at: now
    };
    const { data, error } = await supabase.from('usuarios').insert([payload]).select().limit(1).single();
    if(error){ console.error('createUser error', error); return null; }
    return data;
  }

  async function getOrCreateUserFlow(){
    // 1) pedir username
    const username = await promptUsername();
    if(!username) throw new Error('No username provided');

    // 2) buscar en supabase
    let user = await findUserByUsername(username);
    if(user){
      return user;
    }
    // 3) no existe -> crear
    user = await createUser(username);
    return user;
  }

  async function updateBalanceOnServer(){
    if(!supabase || !currentUser) return;
    try {
      const { data, error } = await supabase
        .from('usuarios')
        .update({ pekepuntos: balance, last_claim: currentUser.last_claim || null })
        .eq('id', currentUser.id)
        .select()
        .single();

      if(error){
        console.warn('updateBalanceOnServer error', error);
        // intentar fallback: upsert por username (si update no encontrÃ³ fila)
        try {
          const { data: up, error: errUp } = await supabase.from('usuarios')
            .upsert({ username: currentUser.username, pekepuntos: balance, last_claim: currentUser.last_claim || null }, { onConflict: 'username' })
            .select().single();
          if(errUp) console.warn('upsert fallback error', errUp);
          else { currentUser = up; }
        } catch(e){ console.error('upsert fallback exception', e); }
      } else {
        currentUser = data;
      }

    } catch (e){
      console.error('updateBalanceOnServer exception', e);
    } finally {
      refreshBalanceUI();
      // refrescar top10
      try { await updateTop10(); } catch(e){}
    }
  }

  async function logActivity(accion, detalle=''){
    if(!supabase || !currentUser) return;
    try {
      await supabase.from('actividad').insert([{ usuario: currentUser.username, accion, detalle, fecha: new Date().toISOString() }]);
    } catch(e){ /* no bloqueante */ console.warn('logActivity error', e); }
  }

  function refreshBalanceUI(){
    if(balanceEl){
      // si usas el antiguo #pekepuntos
      if(balanceEl.id === 'pekepuntos'){
        balanceEl.textContent = `Pekepuntos: ${Number(balance || 0).toLocaleString()}`;
      } else {
        balanceEl.textContent = Number(balance || 0).toLocaleString();
      }
    }
    // tambiÃ©n actualiza el nombre si existe el elemento
    const userNameEl = document.getElementById('userName');
    if(userNameEl && currentUser) userNameEl.textContent = currentUser.username;
  }

  // Inicializar usuario
  try {
    currentUser = await getOrCreateUserFlow();
    if(!currentUser) throw new Error('No se pudo obtener/crear usuario');
    balance = Number(currentUser.pekepuntos || 0);
    refreshBalanceUI();
    await logActivity('EntrÃ³ al casino');
    console.log('Usuario cargado:', currentUser.username, 'balance', balance);
  } catch (err){
    console.error('Error init user flow:', err);
    alert('Error al inicializar usuario. Revisa consola.');
  }

  // ----------------- THREE.JS y escena (igual que la tuya, adaptado) -----------------
  // (mantengo la mayor parte de tu escena; solo incluyo lo esencial aquÃ­ y
  // dejo que el resto de tu cÃ³digo de escena y objetos siga igual)
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0f1a);

  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0,1.6,5);
  camera.rotation.order = 'YXZ';

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  try { renderer.outputColorSpace = THREE.SRGBColorSpace; } catch(e){}
  container.appendChild(renderer.domElement);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.8); hemi.position.set(0,50,0); scene.add(hemi);
  scene.add(new THREE.AmbientLight(0xffffff, 0.22));
  const dir = new THREE.DirectionalLight(0xfff6d6, 0.6); dir.position.set(5,10,5); dir.castShadow = true; scene.add(dir);

  function canvasTexture(size, drawFn){
    const c = document.createElement('canvas'); c.width = c.height = size;
    const ctx = c.getContext('2d'); drawFn(ctx, size);
    const tex = new THREE.CanvasTexture(c);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.anisotropy = 4;
    tex.needsUpdate = true;
    return tex;
  }

  // floor, walls, textures (copiado de tu cÃ³digo - puedes mantener)
  const floorTex = canvasTexture(1024, (ctx,s) => {
    ctx.fillStyle = '#1b0022'; ctx.fillRect(0,0,s,s);
    const grd = ctx.createLinearGradient(0,0,s,s); grd.addColorStop(0,'#22001f'); grd.addColorStop(1,'#0e0010');
    ctx.fillStyle = grd; ctx.globalAlpha = 0.7; ctx.fillRect(0,0,s,s); ctx.globalAlpha = 1;
  });

  const floorMat = new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.95, metalness: 0.02 });
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(30,30), floorMat);
  floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

  // TOP10 wall (usa updateTop10 definido mÃ¡s abajo)
  async function updateTop10(){
    if(!supabase) return;
    try {
      const { data, error } = await supabase.from('usuarios').select('username, pekepuntos').order('pekepuntos', { ascending: false }).limit(10);
      if(error) { console.warn('updateTop10 error', error); return; }
      const s=1024;
      const tex = canvasTexture(s, (ctx) => {
        ctx.fillStyle = '#071018'; ctx.fillRect(0,0,s,s);
        ctx.fillStyle = '#f5b642'; ctx.font = '48px Arial'; ctx.textAlign = 'center'; ctx.fillText('TOP 10', s/2, 70);
        ctx.font = '28px Arial'; ctx.textAlign = 'left'; ctx.fillStyle = '#fff';
        data.forEach((r,i) => { const y = 130 + i*70; ctx.fillText(`${i+1}. ${r.username}`, 60, y); ctx.fillText((r.pekepuntos||0).toLocaleString(), s-140, y);});
      });
      const name = 'top10Wall';
      const existing = scene.getObjectByName(name);
      if(!existing){
        const wall = new THREE.Mesh(new THREE.PlaneGeometry(8,5), new THREE.MeshStandardMaterial({ map: tex, side: THREE.DoubleSide }));
        wall.position.set(0,2,-14.9); wall.name = name; scene.add(wall);
      } else {
        existing.material.map = tex; existing.material.needsUpdate = true;
      }
    } catch(e){
      console.error('updateTop10 exception', e);
    }
  }
  // primer updateTop10
  await updateTop10();
  setInterval(updateTop10, 60000);

  // Interactables (blackjack, ruleta, slots, npc)
  const interactables = [];
  const bjTable = new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.6,0.3,64), new THREE.MeshStandardMaterial({ color: 0x084b2f }));
  bjTable.position.set(-4,0.3,0); bjTable.userData.type='blackjack'; scene.add(bjTable); interactables.push(bjTable);

  const ruletaBase = new THREE.Mesh(new THREE.CylinderGeometry(1.2,1.2,0.4,64), new THREE.MeshStandardMaterial({ color:0x222222 }));
  ruletaBase.position.set(0,0.2,0); ruletaBase.userData.type='roulette'; scene.add(ruletaBase); interactables.push(ruletaBase);

  const ruletaDisk = new THREE.Mesh(new THREE.CylinderGeometry(1.15,1.15,0.08,256), new THREE.MeshStandardMaterial({ map: null }));
  ruletaDisk.rotation.x = Math.PI;
  ruletaDisk.position.set(0,0.45,0); scene.add(ruletaDisk);

  // create roulette texture (copiado)
  (function createRouletteTexture(){
    const s = 2048;
    const canv = document.createElement('canvas'); canv.width = canv.height = s;
    const ctx = canv.getContext('2d'); ctx.translate(s/2, s/2);
    const cellCount = 37; const anglePer = (Math.PI*2)/cellCount;
    ctx.fillStyle = '#2f1b10'; ctx.beginPath(); ctx.arc(0,0,s/2,0,Math.PI*2); ctx.fill();
    const redSet = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
    for(let i=0;i<cellCount;i++){
      const start = i*anglePer - Math.PI/2; const end = start + anglePer;
      const isZero = (i===0);
      ctx.beginPath();
      ctx.fillStyle = isZero ? '#0b8a12' : (redSet.has(i) ? '#d22' : '#111');
      ctx.moveTo(0,0); ctx.arc(0,0,s*0.48,start,end); ctx.closePath(); ctx.fill();
      ctx.save(); ctx.rotate(start + anglePer/2); ctx.fillStyle = '#fff';
      ctx.font = `${s*0.05}px Arial`; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(i.toString(), 0, -s*0.35); ctx.restore();
    }
    ctx.beginPath(); ctx.fillStyle='#8b5a2b'; ctx.arc(0,0,s*0.18,0,Math.PI*2); ctx.fill();
    const tex = new THREE.CanvasTexture(canv); tex.needsUpdate = true; tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
    ruletaDisk.material.map = tex; ruletaDisk.material.needsUpdate = true;
  })();

  // slots proxy
  function createSlotMachine(){
    const g = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(1.1,2.1,1.0), new THREE.MeshStandardMaterial({ color:0x222222 }));
    body.position.y = 1.05; g.add(body);
    const screen = new THREE.Mesh(new THREE.PlaneGeometry(0.7,0.45), new THREE.MeshStandardMaterial({ color:0x05050b, emissive:0x111111 }));
    screen.position.set(0,1.4,0.51); g.add(screen);
    return g;
  }
  const slotMachine = createSlotMachine(); slotMachine.position.set(4,0,0); scene.add(slotMachine);
  const slotProxy = new THREE.Mesh(new THREE.BoxGeometry(1.05,2.05,1.05), new THREE.MeshBasicMaterial({ visible:false }));
  slotProxy.position.copy(slotMachine.position); slotProxy.position.y = 1; slotProxy.userData.type = 'slots';
  scene.add(slotProxy); interactables.push(slotProxy);

  const npc = new THREE.Mesh(new THREE.CylinderGeometry(0.42,0.42,1.6,16), new THREE.MeshStandardMaterial({ color:0xdddddd }));
  npc.position.set(0,1,5); npc.userData.type = 'npc'; scene.add(npc); interactables.push(npc);

  // Movimiento & cÃ¡mara (igual que tu cÃ³digo anterior)
  const keys = {};
  document.addEventListener('keydown', e => { keys[e.code] = true; });
  document.addEventListener('keyup', e => { keys[e.code] = false; });

  let yaw = 0, pitch = 0;
  function updateCamera(dt){
    const yawSpeed = 1.8, pitchSpeed = 1.2;
    if(keys['ArrowLeft']) yaw += yawSpeed * dt;
    if(keys['ArrowRight']) yaw -= yawSpeed * dt;
    if(keys['ArrowUp']) pitch += pitchSpeed * dt;
    if(keys['ArrowDown']) pitch -= pitchSpeed * dt;
    const limit = Math.PI/2 - 0.05;
    pitch = clamp(pitch, -limit, limit);
    camera.rotation.set(pitch, yaw, 0);

    const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
    const right = new THREE.Vector3(); right.crossVectors(forward, camera.up).normalize();
    const move = new THREE.Vector3();
    if(keys['KeyW']) move.add(forward);
    if(keys['KeyS']) move.sub(forward);
    if(keys['KeyD']) move.add(right);
    if(keys['KeyA']) move.sub(right);
    move.multiplyScalar(3 * dt);
    camera.position.add(move);
  }

  // Raycast interactions
  const ray = new THREE.Raycaster();
  let lookingAt = null;
  const npcMsgEl = document.getElementById('npcMsg') || (function(){ const d=document.createElement('div'); d.id='npcMsg'; d.style.position='absolute'; d.style.bottom='12px'; d.style.left='50%'; d.style.transform='translateX(-50%)'; d.style.background='rgba(0,0,0,0.6)'; d.style.padding='8px 12px'; d.style.borderRadius='8px'; d.style.display='none'; d.textContent='Pulsa E para interactuar'; document.body.appendChild(d); return d; })();

  function checkInteraction(){
    ray.set(camera.position, camera.getWorldDirection(new THREE.Vector3()));
    const hits = ray.intersectObjects(interactables, false);
    if(!hits.length || hits[0].distance > 4){ lookingAt = null; npcMsgEl.style.display = 'none'; return; }
    lookingAt = hits[0].object;
    npcMsgEl.style.display = 'block';
    if(lookingAt.userData.type === 'npc') npcMsgEl.textContent = 'Pulsa E para recoger fichas diarias';
    else npcMsgEl.textContent = 'Pulsa E para interactuar';
  }

  // UI modal helpers (si tienes modalEl lo usarÃ¡)
  function showUI(html){
    if(modalEl){ modalEl.innerHTML = html; modalEl.style.display = 'block'; return; }
    const tmp = document.createElement('div'); tmp.style.position='absolute'; tmp.style.left='50%'; tmp.style.top='50%'; tmp.style.transform='translate(-50%,-50%)'; tmp.style.background='rgba(16,22,37,0.95)'; tmp.style.padding='18px'; tmp.style.borderRadius='10px'; tmp.innerHTML = html;
    document.body.appendChild(tmp);
    setTimeout(()=> tmp.remove(), 3000);
  }
  function hideUI(){ if(modalEl) modalEl.style.display = 'none'; }

  // Juegos: Daily, Blackjack, Ruleta, Slots
  async function claimDaily(){
    const today = new Date().toISOString().slice(0,10);
    const last = currentUser.last_claim ? currentUser.last_claim.slice(0,10) : null;
    if(last === today){
      showUI(`<div class="gameUI"><h2>Recompensa diaria</h2><div class="gameResult">Ya reclamaste hoy.</div></div>`);
      return;
    }
    balance += 100;
    currentUser.last_claim = new Date().toISOString();
    await updateBalanceOnServer();
    await logActivity('ReclamÃ³ diaria', '+100');
    showUI(`<div class="gameUI"><h2>Recompensa diaria</h2><div class="gameResult">Recibiste +100 Pekepuntos.</div></div>`);
  }

  // Blackjack (simplificado, usando updateBalanceOnServer)
  function createDeck(){
    const vals = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
    const suits = ['â™ ','â™¥','â™¦','â™£'];
    const d = [];
    for(const s of suits) for(const v of vals) d.push({ v, s });
    for(let i = d.length - 1; i > 0; i--){ const j = Math.floor(Math.random()*(i+1)); [d[i], d[j]]=[d[j], d[i]]; }
    return d;
  }
  function valueOf(card){ if(card.v === 'A') return 11; if(['J','Q','K'].includes(card.v)) return 10; return parseInt(card.v,10); }
  function score(hand){ let sum=0, aces=0; for(const c of hand){ if(c.v==='A') aces++; sum += valueOf(c); } while(sum>21 && aces){ sum -= 10; aces--; } return sum; }

  async function openBlackjack(){
    showUI(`<div class="gameUI"><h2>Blackjack</h2><div class="gameResult" id="bjResult"></div></div>`);
    // UI minimal: realizar una apuesta rÃ¡pida de ejemplo
    const bet = Math.min(50, balance);
    if(!bet){ showUI('<div class="gameResult">Saldo insuficiente</div>'); return; }
    // jugar una mano automÃ¡tica: 50% win
    const win = Math.random() < 0.5;
    if(win){ balance += bet; await updateBalanceOnServer(); showUI(`<div class="gameResult">Ganas ${bet}</div>`); await logActivity('Blackjack win', `+${bet}`); }
    else { balance -= bet; await updateBalanceOnServer(); showUI(`<div class="gameResult">Pierdes ${bet}</div>`); await logActivity('Blackjack lose', `-${bet}`); }
  }

  // Ruleta: interfaz simple
  let ruletaSpinning = false;
  let ruletaPending = null;
  function openRoulette(){
    showUI(`<div class="gameUI"><h2>Ruleta</h2><div class="row"><label>Apuesta: <input id="rBet" type="number" value="50" min="1" /></label></div><div class="row"><button id="spinBtn">Girar NÃºmero (aleatorio)</button></div><div id="rResult" class="gameResult"></div></div>`);
    // attach handler
    setTimeout(()=> {
      const btn = document.getElementById('spinBtn');
      if(btn) btn.onclick = async () => {
        const betInput = document.getElementById('rBet');
        const bet = clamp(Number(betInput.value)||0, 1, balance);
        if(!bet){ document.getElementById('rResult').textContent = 'Introduce apuesta vÃ¡lida'; return; }
        balance -= bet; await updateBalanceOnServer();
        document.getElementById('rResult').textContent = 'Girando...';
        // decide landing
        const landing = rand(0,36);
        // decide win (if landing is even)
        const won = landing % 2 === 0;
        let payout = 0;
        if(won){ payout = bet * 2; balance += payout; await updateBalanceOnServer(); document.getElementById('rResult').textContent = `Sale ${landing} â€” Ganaste ${payout}`; await logActivity('Ruleta win', `+${payout}`); }
        else { document.getElementById('rResult').textContent = `Sale ${landing} â€” Perdiste ${bet}`; await logActivity('Ruleta lose', `-${bet}`); }
      };
    }, 50);
  }

  // Slots (simplificado)
  function openSlots(){
    showUI(`<div class="gameUI"><h2>Tragamonedas</h2><div class="row"><label>Apuesta: <input id="sBet" type="number" value="50" min="1" /></label></div><div class="row"><button id="playSlotsBtn">Jugar</button></div><div id="slotsReels" style="font-size:32px;margin-top:10px">â€¢ â€¢ â€¢</div><div id="slotsRes" class="gameResult"></div></div>`);
    setTimeout(()=> {
      const playBtn = document.getElementById('playSlotsBtn');
      if(!playBtn) return;
      playBtn.onclick = async () => {
        const bet = clamp(Number(document.getElementById('sBet').value)||0, 1, balance);
        if(!bet){ document.getElementById('slotsRes').textContent = 'Introduce apuesta vÃ¡lida'; return; }
        balance -= bet; await updateBalanceOnServer();
        const symbols = ['ðŸ’','ðŸ‹','ðŸŠ','ðŸ‡','ðŸ’Ž','7ï¸âƒ£'];
        let ticks = 0;
        const reelsEl = document.getElementById('slotsReels'); const resEl = document.getElementById('slotsRes');
        const interval = setInterval(()=> {
          ticks++;
          const a = symbols[rand(0,symbols.length-1)], b = symbols[rand(0,symbols.length-1)], c = symbols[rand(0,symbols.length-1)];
          reelsEl.textContent = `${a} ${b} ${c}`;
          if(ticks>30){
            clearInterval(interval);
            const final = [symbols[rand(0,symbols.length-1)], symbols[rand(0,symbols.length-1)], symbols[rand(0,symbols.length-1)]];
            reelsEl.textContent = final.join(' ');
            if(final[0]===final[1] && final[1]===final[2]){ const payout = bet*5; balance += payout; resEl.textContent = `Â¡Jackpot! Ganaste ${payout}`; await updateBalanceOnServer(); await logActivity('Slots win', `+${payout}`); }
            else if(final[0]===final[1]||final[1]===final[2]||final[0]===final[2]){ const payout = bet*2; balance += payout; resEl.textContent = `Dos iguales â€” Ganaste ${payout}`; await updateBalanceOnServer(); await logActivity('Slots pair', `+${payout}`); }
            else { resEl.textContent = `Perdiste ${bet}`; await logActivity('Slots lose', `-${bet}`); }
          }
        }, 40);
      };
    }, 50);
  }

  // Atajo E para interactuar
  document.addEventListener('keydown', async (e) => {
    if(e.code !== 'KeyE') return;
    if(!lookingAt) return;
    const t = lookingAt.userData.type;
    if(t === 'npc'){ await claimDaily(); return; }
    if(t === 'blackjack'){ await openBlackjack(); return; }
    if(t === 'roulette'){ openRoulette(); return; }
    if(t === 'slots'){ openSlots(); return; }
  });

  // Loop de animaciÃ³n
  const clock = new THREE.Clock();
  function animate(){
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    updateCamera(dt);
    checkInteraction();
    renderer.render(scene, camera);
  }
  animate();

  // Resize
  window.addEventListener('resize', ()=> {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // Export API Ãºtil
  window._casino = {
    getCurrentUser: () => currentUser,
    getBalance: () => balance,
    addBalance: async (amt, reason='') => { balance += amt; await updateBalanceOnServer(); if(reason) await logActivity('Add', reason); },
    subBalance: async (amt, reason='') => { balance -= amt; await updateBalanceOnServer(); if(reason) await logActivity('Sub', reason); }
  };

  console.log('Casino 3D iniciado â€” Supabase ' + (supabase ? 'OK' : 'NO disponible'));
})();
</script>
</body>
</html>
