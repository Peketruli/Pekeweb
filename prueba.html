<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Casino 3D - Ruleta y Mesas</title>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<style>
body { margin:0; overflow:hidden; background:#000; font-family:Arial, Helvetica, sans-serif; }
#hint { position:absolute; left:12px; top:12px; z-index:5; background:rgba(0,0,0,0.6); color:#fff; padding:8px 10px; border-radius:8px; font-size:13px; }
#credits { position:absolute; right:12px; top:12px; z-index:5; background:rgba(0,0,0,0.45); color:#ddd; padding:6px 8px; border-radius:6px; font-size:12px; }
</style>
</head>
<body>
<div id="hint">ðŸŽ° Mover: W A S D â€” Mirar: ratÃ³n</div>
<div id="credits">Casino clÃ¡sico â€” texturas libres (online)</div>

<script>
// ---------- Escena ----------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x151515);
scene.fog = new THREE.FogExp2(0x151515, 0.02);

const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(0, 1.7, 10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const loader = new THREE.TextureLoader();

// ---------- Suelo tipo alfombra roja ----------
const carpetCanvas = document.createElement('canvas');
carpetCanvas.width = carpetCanvas.height = 512;
const ctx = carpetCanvas.getContext('2d');
ctx.fillStyle = '#7d0a0a';
ctx.fillRect(0, 0, 512, 512);
ctx.strokeStyle = 'rgba(255,255,255,0.05)';
ctx.lineWidth = 2;
for (let i = 0; i < 512; i += 32) {
  ctx.beginPath();
  ctx.moveTo(i, 0);
  ctx.lineTo(i, 512);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0, i);
  ctx.lineTo(512, i);
  ctx.stroke();
}
const carpetTex = new THREE.CanvasTexture(carpetCanvas);
carpetTex.wrapS = carpetTex.wrapT = THREE.RepeatWrapping;
carpetTex.repeat.set(8, 8);
carpetTex.anisotropy = renderer.capabilities.getMaxAnisotropy();

const floorMat = new THREE.MeshStandardMaterial({
  map: carpetTex,
  roughness: 0.9,
  metalness: 0.05
});
const floor = new THREE.Mesh(new THREE.PlaneGeometry(80, 80), floorMat);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

// ---------- IluminaciÃ³n ----------
const ambient = new THREE.AmbientLight(0xffffff, 0.35);
scene.add(ambient);

const mainLight = new THREE.PointLight(0xffe0b3, 1.3, 60, 2);
mainLight.position.set(0, 7, 0);
mainLight.castShadow = true;
scene.add(mainLight);

const fillLight = new THREE.PointLight(0xff6666, 0.7, 50, 2);
fillLight.position.set(10, 5, 10);
scene.add(fillLight);

const fillLight2 = new THREE.PointLight(0xffcc99, 0.5, 50, 2);
fillLight2.position.set(-10, 5, -10);
scene.add(fillLight2);

// ---------- Techo con textura ----------
const metalTex = loader.load('https://cdn.pixabay.com/photo/2016/03/09/09/17/metal-1245782_1280.jpg');
metalTex.wrapS = metalTex.wrapT = THREE.RepeatWrapping;
metalTex.repeat.set(6, 6);

const ceilingMat = new THREE.MeshStandardMaterial({
  map: metalTex,
  color: 0xdddddd,
  metalness: 0.9,
  roughness: 0.4
});
const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(80, 80), ceilingMat);
ceiling.rotation.x = Math.PI / 2;
ceiling.position.y = 10;
ceiling.receiveShadow = true;
scene.add(ceiling);

// Luces del techo (tipo focos)
for (let i = -20; i <= 20; i += 20) {
  const spot = new THREE.SpotLight(0xffddaa, 1.2, 50, Math.PI / 6, 0.4, 2);
  spot.position.set(i, 9.8, 0);
  spot.target.position.set(i, 0, 0);
  spot.castShadow = true;
  scene.add(spot);
  scene.add(spot.target);
}

// ---------- Paredes ----------
const wallTex = loader.load('https://cdn.pixabay.com/photo/2017/06/21/07/30/marble-2426312_1280.jpg');
wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;
wallTex.repeat.set(4, 2);
const wallMat = new THREE.MeshStandardMaterial({ map: wallTex, roughness: 0.7, metalness: 0.2 });

function wall(x, y, z, sx, sy, sz) {
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz), wallMat);
  mesh.position.set(x, y, z);
  mesh.receiveShadow = true;
  scene.add(mesh);
}
wall(0, 5, -40, 80, 10, 0.8);
wall(0, 5, 40, 80, 10, 0.8);
wall(-40, 5, 0, 0.8, 10, 80);
wall(40, 5, 0, 0.8, 10, 80);

// ---------- Ruleta ----------
const wheelGroup = new THREE.Group();
const wheelBase = new THREE.Mesh(
  new THREE.CylinderGeometry(2.2, 2.2, 0.4, 48),
  new THREE.MeshStandardMaterial({ color: 0x2f1608 })
);
wheelBase.position.y = 0.2;
wheelGroup.add(wheelBase);

const wheelCanvas = document.createElement('canvas');
wheelCanvas.width = wheelCanvas.height = 1024;
const ctx2 = wheelCanvas.getContext('2d');
const cx = 512, cy = 512, r = 420;
for (let i = 0; i < 18; i++) {
  ctx2.beginPath();
  const start = (i / 18) * Math.PI * 2;
  const end = ((i + 1) / 18) * Math.PI * 2;
  ctx2.moveTo(cx, cy);
  ctx2.arc(cx, cy, r, start, end);
  ctx2.closePath();
  ctx2.fillStyle = i % 2 === 0 ? '#9b0000' : '#000';
  ctx2.fill();
}
ctx2.beginPath();
ctx2.fillStyle = '#d1c6b3';
ctx2.arc(cx, cy, r * 0.1, 0, Math.PI * 2);
ctx2.fill();

const wheelTex = new THREE.CanvasTexture(wheelCanvas);
const wheelPlate = new THREE.Mesh(
  new THREE.CylinderGeometry(1.9, 1.9, 0.05, 64),
  new THREE.MeshStandardMaterial({ map: wheelTex })
);
wheelPlate.position.y = 0.45;
wheelGroup.add(wheelPlate);

const rimMesh = new THREE.Mesh(
  new THREE.TorusGeometry(2.4, 0.18, 16, 100),
  new THREE.MeshStandardMaterial({ color: 0x8b4513 })
);
rimMesh.rotation.x = Math.PI / 2;
rimMesh.position.y = 0.45;
wheelGroup.add(rimMesh);

wheelGroup.position.set(-10, 0, 8);
scene.add(wheelGroup);

// ---------- Mesa de Blackjack ----------
const tableGroup = new THREE.Group();

// Base de la mesa
const tableTopTex = loader.load('https://cdn.pixabay.com/photo/2016/11/29/13/10/poker-1865801_1280.jpg');
tableTopTex.wrapS = tableTopTex.wrapT = THREE.RepeatWrapping;
tableTopTex.repeat.set(2, 2);

const tableTopMat = new THREE.MeshStandardMaterial({
  map: tableTopTex,
  color: 0x116611,
  roughness: 0.8,
  metalness: 0.2
});

const tableTop = new THREE.Mesh(
  new THREE.CylinderGeometry(3.5, 3.5, 0.2, 64),
  tableTopMat
);
tableTop.position.y = 1;
tableTop.receiveShadow = true;
tableTop.castShadow = true;
tableGroup.add(tableTop);

// Patas
const legMat = new THREE.MeshStandardMaterial({ color: 0x3b2b19, roughness: 0.6 });
for (let i = -2; i <= 2; i += 4) {
  for (let j = -1; j <= 1; j += 2) {
    const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1, 16), legMat);
    leg.position.set(i, 0.5, j * 2);
    tableGroup.add(leg);
  }
}

tableGroup.position.set(10, 0, -5);
scene.add(tableGroup);

// ---------- AnimaciÃ³n Ruleta ----------
function spin() {
  wheelGroup.rotation.y += 0.02;
  requestAnimationFrame(spin);
}
spin();

// ---------- Movimiento cÃ¡mara ----------
let yaw = 0, pitch = 0;
const sens = 0.0026;
window.addEventListener('mousemove', e => {
  yaw -= e.movementX * sens;
  pitch -= e.movementY * sens;
  pitch = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, pitch));
});

const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

const vel = new THREE.Vector3();
const clock = new THREE.Clock();
function move(dt) {
  camera.rotation.set(pitch, yaw, 0, "YXZ");
  const dir = new THREE.Vector3();
  const fwd = new THREE.Vector3();
  camera.getWorldDirection(fwd);
  fwd.y = 0;
  fwd.normalize();
  const right = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0, 1, 0)).negate();
  if (keys["KeyW"]) dir.add(fwd);
  if (keys["KeyS"]) dir.sub(fwd);
  if (keys["KeyA"]) dir.add(right);
  if (keys["KeyD"]) dir.sub(right);
  if (dir.lengthSq() > 0) dir.normalize();
  vel.addScaledVector(dir, dt * 20);
  vel.multiplyScalar(0.9);
  camera.position.addScaledVector(vel, dt);
}

function animate() {
  requestAnimationFrame(animate);
  move(clock.getDelta());
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
