<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Casino 3D ‚Äî B√°sico</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
html, body {height:100%; margin:0; background:#030612; color:#fff; font-family:Arial, Helvetica, sans-serif; overflow:hidden;}
#wrap {position:relative; width:100%; height:100vh;}
canvas {display:block;}
.hud {position:absolute; top:12px; right:12px; max-width:300px; z-index:10;}
.panel {background:rgba(0,0,0,0.7); padding:10px; border-radius:8px; margin-bottom:10px;}
.info-row {display:flex; justify-content:space-between; margin:4px 0;}
#prompt {position:absolute; bottom:80px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.7); padding:6px 10px; border-radius:6px; display:none; z-index:20;}
#interaction-panel {position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:350px; background:rgba(8,10,12,0.95); padding:16px; border-radius:10px; display:none; z-index:30;}
.btn {background:#d95d00; color:white; padding:6px 10px; border:none; border-radius:6px; cursor:pointer; margin-top:6px;}
</style>
</head>
<body>
<div id="wrap">
  <div class="hud">
    <div class="panel">
      <div class="info-row"><span>Saldo</span><strong id="balance">1000</strong></div>
      <div class="info-row"><span>Apuesta</span><strong id="bet">0</strong></div>
    </div>
  </div>
  <div id="prompt">[E] Interactuar</div>
  <div id="interaction-panel">
    <h3 id="panel-title">Juego</h3>
    <div id="panel-content"></div>
    <button class="btn" onclick="closePanel()">Cerrar</button>
  </div>
</div>

<script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script>
// ==================== CASINO 3D - JS COMPLETO (opci√≥n A: todo generado con Three.js) ====================
// Requisitos: Three.js ya cargado en la p√°gina.
// Dise√±ado para colocarlo dentro de tu HTML donde estaba el <script> anterior.

// ---------- CONFIG / HUD ----------
const wrap = document.getElementById('wrap');
const balanceEl = document.getElementById('balance');
const betEl = document.getElementById('bet');
const prompt = document.getElementById('prompt');
const panel = document.getElementById('interaction-panel');
const panelTitle = document.getElementById('panel-title');
const panelContent = document.getElementById('panel-content');

let balance = 1000;
let currentBet = 0;
function updateHUD(){ if(balanceEl) balanceEl.textContent = balance; if(betEl) betEl.textContent = currentBet; }
function addLog(msg){
  // si existe un log en DOM lo usa, si no manda a consola
  const logs = document.getElementById('log');
  if(logs){
    const d = document.createElement('div'); d.className='log-entry'; d.textContent = msg; logs.prepend(d);
  } else console.log(msg);
}
updateHUD();

// ---------- THREE SCENE ----------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x041018);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(wrap.clientWidth, wrap.clientHeight);
wrap.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(72, wrap.clientWidth / wrap.clientHeight, 0.1, 2000);
camera.position.set(0, 1.7, 12);

// Lights
const amb = new THREE.AmbientLight(0xffffff, 0.55); scene.add(amb);
const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(8, 20, 6); scene.add(dir);

// Floor
const floor = new THREE.Mesh(new THREE.PlaneGeometry(80,80), new THREE.MeshStandardMaterial({ color: 0x091217, roughness: 0.95 }));
floor.rotation.x = -Math.PI/2; scene.add(floor);

// ---------- PLAYER / CONTROLS ----------
let playerPos = new THREE.Vector3(0,0,12);
let yaw = 0, pitch = 0;
const keys = { w:false,a:false,s:false,d:false, ArrowLeft:false,ArrowRight:false,ArrowUp:false,ArrowDown:false };
window.addEventListener('keydown', e => { if(e.key in keys) keys[e.key] = true; });
window.addEventListener('keyup', e => { if(e.key in keys) keys[e.key] = false; });

const speed = 5;
function computeDelta(dt){
  const rotSpeed = 1.5 * dt;
  if(keys.ArrowLeft) yaw += rotSpeed; if(keys.ArrowRight) yaw -= rotSpeed;
  if(keys.ArrowUp) pitch += rotSpeed*0.5; if(keys.ArrowDown) pitch -= rotSpeed*0.5;
  pitch = Math.max(-1.2, Math.min(1.2, pitch));
  const e = new THREE.Euler(pitch, yaw, 0, 'YXZ');
  const q = new THREE.Quaternion().setFromEuler(e);
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(q); forward.y = 0; forward.normalize();
  const right = new THREE.Vector3(1,0,0).applyQuaternion(q); right.y = 0; right.normalize();

  let mf=0, mr=0;
  if(keys.w) mf+=1; if(keys.s) mf-=1; if(keys.a) mr-=1; if(keys.d) mr+=1;
  const len = Math.hypot(mf,mr); if(len>0){ mf/=len; mr/=len; }
  const delta = new THREE.Vector3();
  delta.addScaledVector(forward, mf*speed*dt);
  delta.addScaledVector(right, mr*speed*dt);
  return delta;
}

// ---------- ZONAS (Ruleta, Blackjack, Slots) ----------
const zones = [
  { x:0, z:0, label: 'Ruleta', action: openRouletteUI },
  { x:-10, z:-5, label: 'Blackjack', action: openBlackjackUI },
  { x:10, z:-5, label: 'Tragaperras', action: openSlotsUI }
];
let currentZone = null;

function detectZones(){
  currentZone = null;
  for(const z of zones){
    const dx = playerPos.x - z.x, dz = playerPos.z - z.z;
    if(Math.hypot(dx, dz) < 3){
      currentZone = z;
      prompt.style.display = 'block';
      prompt.textContent = '[E] ' + z.label;
      return;
    }
  }
  prompt.style.display = 'none';
}
document.addEventListener('keydown', e => {
  if(e.key.toLowerCase() === 'e' && currentZone) currentZone.action();
  if(e.key === 'Escape') panel.style.display = 'none';
});

// ---------- UTIL: canvas texture for labels, cards ----------
function createNumberCanvasLabel(text, size=256, bg='#111', fg='#fff'){
  const c = document.createElement('canvas'); c.width = c.height = size;
  const ctx = c.getContext('2d');
  ctx.fillStyle = bg; ctx.fillRect(0,0,size,size);
  ctx.fillStyle = fg; ctx.font = `${Math.floor(size*0.18)}px sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(text, size/2, size/2);
  return c;
}
function createCardCanvas(rank, suit, sizeW=256, sizeH=360){
  const c = document.createElement('canvas'); c.width = sizeW; c.height = sizeH;
  const ctx = c.getContext('2d');
  // background
  ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,sizeW,sizeH);
  ctx.fillStyle = '#0b5c0a'; ctx.fillRect(6,6,sizeW-12,sizeH-12);
  // inner box
  ctx.fillStyle = '#e9e9e9'; ctx.fillRect(12,12,sizeW-24,sizeH-24);
  // rank top-left
  ctx.fillStyle = '#000'; ctx.font = '28px sans-serif'; ctx.textAlign='left'; ctx.fillText(rank + suit, 18, 36);
  // big center symbol
  ctx.font = '72px sans-serif'; ctx.textAlign='center'; ctx.fillText(suit, sizeW/2, sizeH/2 + 10);
  // rank bottom-right
  ctx.font = '20px sans-serif'; ctx.textAlign='right'; ctx.fillText(rank, sizeW - 18, sizeH - 18);
  return c;
}

// ---------- RULETE: wheel, ball, UI & logic ----------
const wheelRadius = 3.8;
const pockets = [0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23,10,5,24,16,33,1,20,14,31,9,22,18,29,7,28,12,35,3,26];
const anglePerPocket = (Math.PI*2) / pockets.length;

function createWheelCanvas(size=1024){
  const c = document.createElement('canvas'); c.width = c.height = size;
  const ctx = c.getContext('2d');
  const cx=size/2, cy=size/2, r=size*0.45;
  ctx.fillStyle='#072b22'; ctx.fillRect(0,0,size,size);
  for(let i=0;i<pockets.length;i++){
    const a0 = i*anglePerPocket - Math.PI/2;
    const a1 = (i+1)*anglePerPocket - Math.PI/2;
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,r,a0,a1); ctx.closePath();
    // alternate color: use index parity
    const col = pockets[i]===0 ? '#1b8b41' : (i % 2 ? '#b71c1c' : '#000000');
    ctx.fillStyle = col; ctx.fill();
    // number label
    const mid = a0 + (a1-a0)/2;
    ctx.save();
    ctx.translate(cx + Math.cos(mid)*r*0.66, cy + Math.sin(mid)*r*0.66);
    ctx.rotate(mid + Math.PI/2);
    ctx.fillStyle = '#fff';
    ctx.font = `${Math.floor(size*0.04)}px sans-serif`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(pockets[i], 0, 0);
    ctx.restore();
  }
  // center
  ctx.beginPath(); ctx.fillStyle='#111'; ctx.arc(cx,cy,r*0.45,0,Math.PI*2); ctx.fill();
  return c;
}
const wheelTexture = new THREE.CanvasTexture(createWheelCanvas(1024));
wheelTexture.needsUpdate = true;
const wheelMesh = new THREE.Mesh(
  new THREE.CylinderGeometry(wheelRadius, wheelRadius, 1.2, 128),
  new THREE.MeshStandardMaterial({ map: wheelTexture })
);
wheelMesh.rotation.x = Math.PI; // cylinder faces correct side
wheelMesh.position.set(0, 0.35, 0);
scene.add(wheelMesh);

// wheel rim and markers (visual)
const rimGeom = new THREE.RingGeometry(wheelRadius+0.05, wheelRadius+0.15, 128);
const rimMat = new THREE.MeshStandardMaterial({ color:0x222222 });
const rimMesh = new THREE.Mesh(rimGeom, rimMat);
rimMesh.rotation.x = -Math.PI/2; rimMesh.position.y = 0.36; scene.add(rimMesh);

// ball
const ballMesh = new THREE.Mesh(new THREE.SphereGeometry(0.18, 16, 16), new THREE.MeshStandardMaterial({ color: 0xffffff }));
ballMesh.position.y = 1.2;
scene.add(ballMesh);

// helper: determine red/black by index parity (0 is green)
function isPocketRed(n){ if(n===0) return false; const idx = pockets.indexOf(n); return (idx % 2 === 0); }

// Build roulette UI
function openRouletteUI(){
  panelTitle.textContent = 'Ruleta';
  panel.style.display = 'block';
  panelContent.innerHTML = `
    <div style="font-size:13px;margin-bottom:8px">Tipo de apuesta:</div>
    <select id="rType" style="width:100%;margin-bottom:8px">
      <option value="number">N√∫mero</option>
      <option value="color">Color</option>
      <option value="par">Par/Impar</option>
      <option value="dozen">Docena</option>
      <option value="column">Columna</option>
      <option value="highlow">Alto/Bajo</option>
    </select>
    <div id="rParams" style="margin-bottom:8px">
      <input id="rNumber" type="number" min="0" max="36" placeholder="N√∫mero (ej: 7)" style="width:100%;display:block"/>
    </div>
    <label>$ A apostar:</label><br>
    <input id="rouletteBet" type="number" value="10" style="width:100%;margin-top:6px"/><br>
    <button class="btn" id="rSpin" style="width:100%;margin-top:10px">Girar Ruleta</button>
    <div style="font-size:12px;margin-top:8px">N√∫mero=35x ¬∑ Docena/Columna=3x ¬∑ Par/Color/HighLow=2x</div>
  `;
  const rType = document.getElementById('rType');
  const rParams = document.getElementById('rParams');
  rType.addEventListener('change', ()=>{
    const t = rType.value;
    if(t==='number') rParams.innerHTML = `<input id="rNumber" type="number" min="0" max="36" placeholder="N√∫mero (ej: 7)" style="width:100%;display:block"/>`;
    else if(t==='color') rParams.innerHTML = `<select id="rColor" style="width:100%"><option value="red">Rojo</option><option value="black">Negro</option></select>`;
    else if(t==='par') rParams.innerHTML = `<select id="rPar" style="width:100%"><option value="even">Par</option><option value="odd">Impar</option></select>`;
    else if(t==='dozen') rParams.innerHTML = `<select id="rDozen" style="width:100%"><option value="1">1 (1-12)</option><option value="2">2 (13-24)</option><option value="3">3 (25-36)</option></select>`;
    else if(t==='column') rParams.innerHTML = `<select id="rColumn" style="width:100%"><option value="1">Columna 1</option><option value="2">Columna 2</option><option value="3">Columna 3</option></select>`;
    else if(t==='highlow') rParams.innerHTML = `<select id="rHighLow" style="width:100%"><option value="low">1-18</option><option value="high">19-36</option></select>`;
  });
  document.getElementById('rSpin').addEventListener('click', ()=>{
    const type = document.getElementById('rType').value;
    const betAmt = parseInt(document.getElementById('rouletteBet').value) || 0;
    if(betAmt <= 0){ addLog('Ruleta: apuesta inv√°lida'); return; }
    let betObj = { type: type, amount: betAmt };
    if(type==='number'){ betObj.value = parseInt(document.getElementById('rNumber').value); if(isNaN(betObj.value) || betObj.value<0 || betObj.value>36){ addLog('N√∫mero inv√°lido'); return; } }
    else if(type==='color'){ betObj.value = document.getElementById('rColor').value; }
    else if(type==='par'){ betObj.value = document.getElementById('rPar').value; }
    else if(type==='dozen'){ betObj.value = parseInt(document.getElementById('rDozen').value); }
    else if(type==='column'){ betObj.value = parseInt(document.getElementById('rColumn').value); }
    else if(type==='highlow'){ betObj.value = document.getElementById('rHighLow').value; }
    panel.style.display = 'none';
    spinRouletteWithBet(betObj);
  });
}

// payout engine for a single bet object
function payoutForBet(betObj, pocketIndex){
  const pocketNum = pockets[pocketIndex];
  const amt = betObj.amount;
  if(betObj.type === 'number') return (pocketNum === betObj.value) ? amt * 35 : 0;
  if(betObj.type === 'color'){
    if(pocketNum === 0) return 0;
    const red = isPocketRed(pocketNum);
    if(betObj.value === 'red') return red ? amt*2 : 0;
    return (!red) ? amt*2 : 0;
  }
  if(betObj.type === 'par'){
    if(pocketNum === 0) return 0;
    const even = (pocketNum % 2 === 0);
    return (betObj.value === 'even' ? (even ? amt*2 : 0) : (!even ? amt*2 : 0));
  }
  if(betObj.type === 'dozen'){
    if(pocketNum === 0) return 0;
    const d = Math.ceil(pocketNum/12);
    return (d === betObj.value) ? amt*3 : 0;
  }
  if(betObj.type === 'column'){
    if(pocketNum === 0) return 0;
    const col = ((pocketNum - 1) % 3) + 1;
    return (col === betObj.value) ? amt*3 : 0;
  }
  if(betObj.type === 'highlow'){
    if(pocketNum === 0) return 0;
    if(betObj.value === 'low') return (pocketNum >=1 && pocketNum <=18) ? amt*2 : 0;
    if(betObj.value === 'high') return (pocketNum >=19 && pocketNum <=36) ? amt*2 : 0;
  }
  return 0;
}

// Core spin that animates and ensures final pocket aligns logically with detection formula
let rouletteSpinning = false;
function spinRouletteWithBet(betObj){
  if(rouletteSpinning) return;
  if(balance < betObj.amount){ addLog('Ruleta: saldo insuficiente'); return; }
  balance -= betObj.amount; updateHUD();
  rouletteSpinning = true;

  // choose final pocket randomly
  const chosenIndex = Math.floor(Math.random() * pockets.length);
  const chosenNumber = pockets[chosenIndex];

  // initial angles
  let ballAngle = Math.random() * Math.PI * 2;
  let wheelAngle = 0;

  // target center angle for chosen pocket (in wheel texture coordinates)
  const pocketCenterAngle = (chosenIndex + 0.5) * anglePerPocket - Math.PI/2;

  // ensure wheel will make multiple revs + end at angle that makes detection return chosenIndex
  const totalRevs = 8 + Math.floor(Math.random()*4);
  const baseRotation = Math.PI*2*totalRevs;
  const tinyOffset = (Math.random() - 0.5) * anglePerPocket * 0.4;

  // solving detection eq: ((-ballAngle - wheelFinal) mod 2œÄ) === pocketCenterAngle
  // => wheelFinal = -ballAngle - pocketCenterAngle  (+ k*2œÄ)
  let wheelFinal = baseRotation + (-ballAngle - pocketCenterAngle) + tinyOffset;
  // normalize positive
  if(wheelFinal < 0) wheelFinal += Math.ceil(Math.abs(wheelFinal) / (Math.PI*2)) * (Math.PI*2);

  const wheelTarget = wheelFinal;
  const ballRadius = wheelRadius - 0.25;
  const ballHeight = 1.2;

  const start = performance.now();
  // animation loop
  function step(now){
    const t = (now - start) / 1000;
    const dt = 1/60;

    // easing: wheel slows as remaining decreases
    const remaining = Math.max(0, wheelTarget - wheelAngle);
    const brakeFactor = remaining / (Math.PI*2*totalRevs + 0.0001);
    let wheelDelta = Math.max(0.02, 8 * Math.sqrt(Math.max(0, brakeFactor))) * dt;
    if(wheelAngle + wheelDelta > wheelTarget) wheelDelta = wheelTarget - wheelAngle;
    wheelAngle += wheelDelta;
    wheelMesh.rotation.y = wheelAngle;

    // ball spins in opposite direction visually & slows slower
    const ballSpeedDecay = 0.996 - Math.min(0.02, 0.0005 * (1 - brakeFactor));
    ballAngle += 30 * dt * brakeFactor * 1.2 +  ( (1-brakeFactor) * 1.2 ); // lively feel
    // simpler position to avoid runaway values:
    ballAngle += 0.12 * dt * 60; // constant small increment for visual spin

    // place ball
    ballMesh.position.x = Math.cos(ballAngle) * ballRadius;
    ballMesh.position.z = Math.sin(ballAngle) * ballRadius;
    ballMesh.position.y = ballHeight;

    // finish
    if(Math.abs(wheelAngle - wheelTarget) < 0.0001){
      // compute final index using same detection formula
      const relativeAngle = ((-ballAngle - wheelAngle) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
      const finalIndex = Math.floor(relativeAngle / anglePerPocket) % pockets.length;
      const finalNumber = pockets[(finalIndex + pockets.length) % pockets.length];

      // snap visuals: place ball at correct pocket center world angle
      const pocketCenterVisual = (finalIndex + 0.5) * anglePerPocket - Math.PI/2;
      const pocketWorldAngleFinal = - ( /*ballAngle*/ 0 ) - pocketCenterVisual; // simpler: rotate wheel so pocket center sits where it should
      // but easier: compute ball position directly relative to wheel final:
      const worldBallAngle = - (wheelAngle) - pocketCenterVisual;
      ballMesh.position.x = Math.cos(worldBallAngle) * ballRadius;
      ballMesh.position.z = Math.sin(worldBallAngle) * ballRadius;
      ballMesh.position.y = ballHeight;

      rouletteSpinning = false;

      const payout = payoutForBet(betObj, finalIndex);
      if(payout > 0){
        balance += payout;
        addLog(`Ruleta sali√≥ ${finalNumber} ‚Äî Ganaste $${payout}!`);
      } else {
        addLog(`Ruleta sali√≥ ${finalNumber} ‚Äî Perdiste.`);
      }
      updateHUD();
      return;
    } else {
      requestAnimationFrame(step);
    }
  }
  requestAnimationFrame(step);
}

// ---------- TRAGAPERRAS 3D (cuerpo 3D + UI preview) ----------
const slotBody = new THREE.Mesh(new THREE.BoxGeometry(3.2,4.4,2.0), new THREE.MeshStandardMaterial({ color: 0x1a1a1a }));
slotBody.position.set(10, 2.2, -5); scene.add(slotBody);
const slotScreen = new THREE.Mesh(new THREE.PlaneGeometry(2.6, 1.3), new THREE.MeshStandardMaterial({ color: 0x050505 }));
slotScreen.position.set(10, 3.05, -4.0); scene.add(slotScreen);
// button
const spinBtn = new THREE.Mesh(new THREE.CylinderGeometry(0.28,0.28,0.22,32), new THREE.MeshStandardMaterial({ color: 0xd95d00 }));
spinBtn.rotation.x = Math.PI/2; spinBtn.position.set(10, 1.25, -3.5); scene.add(spinBtn);

const slotSymbols = ['üçí','‚≠ê','7','üçã','üîî','üçâ'];
function openSlotsUI(){
  panelTitle.textContent = 'Tragaperras';
  panel.style.display = 'block';
  panelContent.innerHTML = `
    <label>$ A apostar:</label><br>
    <input id="slotBet" type="number" value="10" style="width:100%;margin-bottom:8px"/><br>
    <canvas id="slotPreview" width="360" height="140" style="width:100%;border-radius:6px;background:#000;display:block;margin-bottom:8px"></canvas>
    <button class="btn" id="slotSpin" style="width:100%">Girar</button>
    <div style="font-size:12px;margin-top:8px">Tres iguales = x5 ¬∑ Dos iguales = x2</div>
  `;
  drawSlotPreview();
  document.getElementById('slotSpin').onclick = ()=>spinSlots();
}
function drawSlotPreview(syms){
  const cv = document.getElementById('slotPreview'); if(!cv) return;
  const ctx = cv.getContext('2d'); ctx.fillStyle='#071217'; ctx.fillRect(0,0,cv.width,cv.height);
  const w = cv.width/3;
  for(let i=0;i<3;i++){
    ctx.fillStyle='#111'; ctx.fillRect(i*w+10,10,w-20,cv.height-20);
    ctx.fillStyle='#fff'; ctx.font='48px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    const s = syms ? syms[i] : slotSymbols[Math.floor(Math.random()*slotSymbols.length)];
    ctx.fillText(s, i*w + w/2, cv.height/2);
  }
}

let slotSpinning = false;
function spinSlots(){
  if(slotSpinning) return;
  const amt = parseInt(document.getElementById('slotBet').value) || 0;
  if(amt <= 0){ addLog('Slot: apuesta inv√°lida'); return; }
  if(balance < amt){ addLog('Slot: saldo insuficiente'); return; }
  balance -= amt; updateHUD(); panel.style.display = 'none';
  slotSpinning = true;

  const results = [ slotSymbols[Math.floor(Math.random()*slotSymbols.length)],
                    slotSymbols[Math.floor(Math.random()*slotSymbols.length)],
                    slotSymbols[Math.floor(Math.random()*slotSymbols.length)] ];

  const cv = document.getElementById('slotPreview');
  const ctx = cv.getContext('2d');
  const start = performance.now();
  const durations = [800, 1300, 1800];
  function frame(now){
    const elapsed = now - start;
    for(let i=0;i<3;i++){
      const w = cv.width/3;
      ctx.fillStyle='#071217'; ctx.fillRect(i*w,0,w,cv.height);
      ctx.fillStyle='#111'; ctx.fillRect(i*w+10,10,w-20,cv.height-20);
      ctx.fillStyle='#fff'; ctx.font='48px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      if(elapsed < durations[i]) ctx.fillText(slotSymbols[Math.floor(Math.random()*slotSymbols.length)], i*w + w/2, cv.height/2);
      else ctx.fillText(results[i], i*w + w/2, cv.height/2);
    }
    if(elapsed < durations[2] + 150) requestAnimationFrame(frame);
    else {
      slotSpinning = false;
      const counts = {}; results.forEach(s => counts[s] = (counts[s]||0) + 1);
      let win = 0;
      if(Object.values(counts).includes(3)) win = amt * 5;
      else if(Object.values(counts).includes(2)) win = amt * 2;
      if(win > 0){ balance += win; addLog(`Tragaperras: ganaste $${win}!`); } else addLog('Tragaperras: perdiste');
      updateHUD();
    }
  }
  requestAnimationFrame(frame);
}

// ---------- BLACKJACK 3D (mesa + cards in 3D + UI) ----------
let bjState = {
  shoe: [],
  playerHand: [],
  dealerHand: [],
  bet: 0,
  inRound: false
};

function createShoe(){
  const suits = ['‚ô†','‚ô•','‚ô¶','‚ô£'], ranks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  const shoe = [];
  for(let deck=0; deck<4; deck++){
    for(const r of ranks) for(const s of suits) shoe.push(r + s);
  }
  for(let i=shoe.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1)); [shoe[i], shoe[j]] = [shoe[j], shoe[i]];
  }
  return shoe;
}
function drawFromShoe(){
  if(bjState.shoe.length === 0) bjState.shoe = createShoe();
  return bjState.shoe.pop();
}
function valueOfHand(cards){
  let sum = 0, aces = 0;
  for(const c of cards){
    const r = c.slice(0, -1);
    if(r==='A'){ sum += 11; aces++; }
    else if(['J','Q','K'].includes(r)) sum += 10;
    else sum += parseInt(r);
  }
  while(sum > 21 && aces > 0){ sum -= 10; aces--; }
  return sum;
}
function isBlackjack(cards){ return cards.length === 2 && valueOfHand(cards) === 21; }

// 3D table and card placeholders
const blackjackGroup = new THREE.Group();
blackjackGroup.position.set(-10, 0, -5);
scene.add(blackjackGroup);

const bjTable = new THREE.Mesh(new THREE.CylinderGeometry(3.6, 3.6, 0.5, 64), new THREE.MeshStandardMaterial({ color: 0x0a5c0a }));
bjTable.position.y = 0.25; blackjackGroup.add(bjTable);

// card holders (player / dealer)
const playerCardGroup = new THREE.Group(); playerCardGroup.position.set(-10, 0.6, -6.2); blackjackGroup.add(playerCardGroup);
const dealerCardGroup = new THREE.Group(); dealerCardGroup.position.set(-10, 0.6, -3.6); blackjackGroup.add(dealerCardGroup);

// helper: create 3D plane mesh for card and keep reference for update
function createCardMesh(rankSuit){
  const canvas = createCardCanvas(rankSuit.slice(0,-1), rankSuit.slice(-1));
  const tex = new THREE.CanvasTexture(canvas);
  tex.needsUpdate = true;
  const mat = new THREE.MeshStandardMaterial({ map: tex, side: THREE.DoubleSide });
  const geo = new THREE.PlaneGeometry(0.7, 1.0);
  const mesh = new THREE.Mesh(geo, mat);
  return { mesh, tex, canvas, rankSuit };
}
function placeCardMesh(group, cardMesh, idx){
  cardMesh.mesh.position.set(idx*0.8 - 0.8, 0.02, 0); // spread
  cardMesh.mesh.rotation.x = -0.25;
  group.add(cardMesh.mesh);
}

// Blackjack UI (panel) and 3D card synchronization
function openBlackjackUI(){
  if(balance < 10){ addLog('Blackjack: necesitas al menos $10'); return; }
  panelTitle.textContent = 'Blackjack';
  panel.style.display = 'block';
  // reset 3D card groups
  while(playerCardGroup.children.length) playerCardGroup.remove(playerCardGroup.children[0]);
  while(dealerCardGroup.children.length) dealerCardGroup.remove(dealerCardGroup.children[0]);

  bjState.shoe = createShoe();
  bjState.playerHand = [];
  bjState.dealerHand = [];
  bjState.bet = 10;
  bjState.inRound = true;
  balance -= bjState.bet; updateHUD();

  // deal
  bjState.playerHand.push(drawFromShoe(), drawFromShoe());
  bjState.dealerHand.push(drawFromShoe(), drawFromShoe());

  // create card meshes and place them
  bjState._playerMeshes = bjState.playerHand.map((c,i) => {
    const cm = createCardMesh(c);
    placeCardMesh(playerCardGroup, cm, i);
    return cm;
  });
  bjState._dealerMeshes = bjState.dealerHand.map((c,i) => {
    const cm = createCardMesh(c);
    // flip second dealer card face-down initially
    if(i === 1){
      // face-down texture (simple)
      const cv = document.createElement('canvas'); cv.width=256; cv.height=360;
      const ctx = cv.getContext('2d'); ctx.fillStyle = '#0b5c0a'; ctx.fillRect(0,0,cv.width,cv.height);
      ctx.fillStyle = '#111'; ctx.fillRect(10,10,cv.width-20,cv.height-20);
      ctx.fillStyle = '#fff'; ctx.font='20px sans-serif'; ctx.textAlign='center'; ctx.fillText('BACK', cv.width/2, cv.height/2);
      cm.tex.image = cv; cm.tex.needsUpdate = true;
    }
    placeCardMesh(dealerCardGroup, cm, i);
    return cm;
  });

  renderBlackjackPanel();
}
function renderBlackjackPanel(){
  const p = bjState.playerHand;
  const d = bjState.dealerHand;
  let html = `Tus cartas: ${p.map(c=>'<span class="card">'+c+'</span>').join(' ')} (Total: ${valueOfHand(p)})<br>`;
  html += `Dealer: <span class="card">${d[0]}</span> ??<br>`;
  html += `<div style="margin-top:8px"><button class="btn" onclick="hitBlackjack()">Pedir</button> <button class="btn" onclick="standBlackjack()">Plantarse</button> <button class="btn" onclick="doubleBlackjack()">Doblar</button></div>`;
  // immediate blackjack checks
  if(isBlackjack(p) && !isBlackjack(d)){
    const win = Math.floor(bjState.bet * 1.5);
    balance += bjState.bet + win;
    addLog(`Blackjack! Ganaste $${win}`);
    bjState.inRound = false;
    updateHUD();
    html += `<div style="margin-top:8px">Blackjack! Pagado 3:2</div>`;
    // reveal dealer back card if any
    revealDealerCards();
  } else if(isBlackjack(p) && isBlackjack(d)){
    balance += bjState.bet;
    addLog('Push (Ambos Blackjack)');
    bjState.inRound = false;
    updateHUD();
    html += `<div style="margin-top:8px">Push: ambos Blackjack</div>`;
    revealDealerCards();
  }
  panelContent.innerHTML = html;
}
function revealDealerCards(){
  // update dealer mesh textures to actual faces
  bjState.dealerHand.forEach((c, i) => {
    const cm = bjState._dealerMeshes[i];
    if(cm){
      const canvas = createCardCanvas(c.slice(0,-1), c.slice(-1));
      cm.tex.image = canvas; cm.tex.needsUpdate = true;
    }
  });
}

// Blackjack actions (UI buttons call these)
function hitBlackjack(){
  if(!bjState.inRound) return;
  const card = drawFromShoe(); bjState.playerHand.push(card);
  const cm = createCardMesh(card);
  placeCardMesh(playerCardGroup, cm, bjState.playerHand.length - 1);
  bjState._playerMeshes.push(cm);
  const total = valueOfHand(bjState.playerHand);
  if(total > 21){
    addLog(`Blackjack: Busted con ${total}`);
    bjState.inRound = false;
    updateHUD();
    panel.style.display = 'none';
    revealDealerCards();
  } else renderBlackjackPanel();
}
function standBlackjack(){
  if(!bjState.inRound) return;
  revealDealerCards();
  // dealer plays (stand on soft 17)
  while(true){
    const dv = valueOfHand(bjState.dealerHand);
    if(dv < 17) {
      const c = drawFromShoe(); bjState.dealerHand.push(c);
      const cm = createCardMesh(c); placeCardMesh(dealerCardGroup, cm, bjState.dealerHand.length - 1); bjState._dealerMeshes.push(cm);
    } else break;
  }
  const pv = valueOfHand(bjState.playerHand);
  const dv = valueOfHand(bjState.dealerHand);
  addLog(`Dealer: ${bjState.dealerHand.join(' ')} (${dv})`);
  if(pv > 21) addLog('Perdiste (busted)');
  else if(dv > 21 || pv > dv){
    const win = bjState.bet * 2; balance += win; addLog(`Ganaste $${win - bjState.bet}`);
  } else if(pv === dv){ balance += bjState.bet; addLog('Push'); }
  else addLog('Perdiste');
  bjState.inRound = false;
  updateHUD();
  panel.style.display = 'none';
}
function doubleBlackjack(){
  if(!bjState.inRound) return;
  if(balance < bjState.bet){ addLog('No tienes suficiente para doblar'); return; }
  balance -= bjState.bet; bjState.bet *= 2; updateHUD();
  hitBlackjack();
  if(valueOfHand(bjState.playerHand) <= 21) standBlackjack();
}

// ---------- ANIMATION / RENDER ----------
let lastTime = 0;
function animate(ts){
  requestAnimationFrame(animate);
  const dt = (ts - lastTime) * 0.001 || 0.016; lastTime = ts;
  detectZones();
  const delta = computeDelta(dt);
  playerPos.add(delta);
  camera.position.copy(playerPos); camera.position.y = 1.7; camera.rotation.set(pitch, yaw, 0, 'YXZ');
  renderer.render(scene, camera);
}
requestAnimationFrame(animate);

// ---------- WINDOW RESIZE ----------
window.addEventListener('resize', ()=> {
  camera.aspect = wrap.clientWidth / wrap.clientHeight; camera.updateProjectionMatrix();
  renderer.setSize(wrap.clientWidth, wrap.clientHeight);
});

// ---------- PANEL UTIL ----------
function closePanel(){ panel.style.display = 'none'; }

// INITIAL small visual indicators
// small markers for table positions
(function placeMarkers(){
  const geo = new THREE.CircleGeometry(0.12, 12);
  const matR = new THREE.MeshStandardMaterial({ color: 0xffcc00 });
  const m1 = new THREE.Mesh(geo, matR); m1.rotation.x = -Math.PI/2; m1.position.set(0,0.36,0); scene.add(m1); // ruleta
  const m2 = new THREE.Mesh(geo, matR); m2.rotation.x = -Math.PI/2; m2.position.set(-10,0.36,-5); scene.add(m2); // bj
  const m3 = new THREE.Mesh(geo, matR); m3.rotation.x = -Math.PI/2; m3.position.set(10,0.36,-5); scene.add(m3); // slots
})();

</script>
</body>
</html>
