<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Casino 3D - Ruleta y Mesas</title>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<style>
body { margin:0; overflow:hidden; background:#000; font-family:Arial, Helvetica, sans-serif; }
#hint { position:absolute; left:12px; top:12px; z-index:5; background:rgba(0,0,0,0.6); color:#fff; padding:8px 10px; border-radius:8px; font-size:13px; }
#credits { position:absolute; right:12px; top:12px; z-index:5; background:rgba(0,0,0,0.45); color:#ddd; padding:6px 8px; border-radius:6px; font-size:12px; }
</style>
</head>
<body>
<div id="hint">ðŸŽ° Mover: W A S D â€” Mirar: ratÃ³n</div>
<div id="credits">Casino clÃ¡sico â€” texturas libres (online)</div>

<script>
// ---------- Escena ----------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);
scene.fog = new THREE.FogExp2(0x202020, 0.02);

const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(0, 1.7, 10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// ---------- Cargador de texturas ----------
const loader = new THREE.TextureLoader();

// ---------- Suelo tipo alfombra roja ----------
const carpetCanvas = document.createElement('canvas');
carpetCanvas.width = carpetCanvas.height = 512;
const ctx = carpetCanvas.getContext('2d');

// Fondo rojo oscuro
ctx.fillStyle = '#8B0000'; // rojo oscuro tipo alfombra
ctx.fillRect(0, 0, 512, 512);

// LÃ­neas sutiles para simular textura de alfombra
ctx.strokeStyle = 'rgba(255, 0, 0, 0.1)';
ctx.lineWidth = 4;
for(let i = 0; i < 512; i += 32){
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i, 512);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, i);
    ctx.lineTo(512, i);
    ctx.stroke();
}

const carpetTex = new THREE.CanvasTexture(carpetCanvas);
carpetTex.wrapS = carpetTex.wrapT = THREE.RepeatWrapping;
carpetTex.repeat.set(8, 8);
carpetTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
carpetTex.colorSpace = THREE.SRGBColorSpace;

const floorMat = new THREE.MeshStandardMaterial({
    map: carpetTex,
    roughness: 0.9,
    metalness: 0.1
});

const floor = new THREE.Mesh(new THREE.PlaneGeometry(80, 80), floorMat);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);


// ---------- IluminaciÃ³n ----------
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(10, 20, 10);
directionalLight.castShadow = true;
scene.add(directionalLight);

// ---------- Paredes con mÃ¡rmol ----------
const wallTex = loader.load('https://cdn.pixabay.com/photo/2017/06/21/07/30/marble-2426312_1280.jpg');
wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;
wallTex.repeat.set(4, 2);
wallTex.anisotropy = 8;

const wallMat = new THREE.MeshStandardMaterial({
  map: wallTex,
  roughness: 0.8,
  metalness: 0.2
});

// Pared trasera
const backWall = new THREE.Mesh(new THREE.BoxGeometry(80, 10, 0.8), wallMat);
backWall.position.set(0, 5, -40);
scene.add(backWall);

// Pared frontal
const frontWall = backWall.clone();
frontWall.position.set(0, 5, 40);
scene.add(frontWall);

// Pared izquierda
const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.8, 10, 80), wallMat);
leftWall.position.set(-40, 5, 0);
scene.add(leftWall);

// Pared derecha
const rightWall = leftWall.clone();
rightWall.position.set(40, 5, 0);
scene.add(rightWall);

// -------------------- Mesa de blackjack --------------------
const tableGroup = new THREE.Group();

function createFeltTexture() {
  const c = document.createElement('canvas'); c.width = c.height = 512;
  const ctx = c.getContext('2d');
  const grad = ctx.createLinearGradient(0, 0, 512, 512);
  grad.addColorStop(0, '#0b5b35');
  grad.addColorStop(1, '#0e7041');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, 512, 512);

  // Borde dorado
  ctx.strokeStyle = '#ffd27f';
  ctx.lineWidth = 12;
  ctx.strokeRect(0, 0, 512, 512);

  // LÃ­neas de apuestas
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  for (let i = 1; i <= 3; i++) {
    ctx.beginPath();
    ctx.moveTo(0, i * 128);
    ctx.lineTo(512, i * 128);
    ctx.stroke();
  }

  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(1, 1);
  return tex;
}

const feltTex2 = createFeltTexture();

// Tablero principal
const tableTop = new THREE.Mesh(
  new THREE.CylinderGeometry(4.2, 4.2, 0.3, 32),
  new THREE.MeshStandardMaterial({ map: feltTex2, roughness: 0.7, metalness: 0.05 })
);
tableTop.position.y = 0.6;
tableTop.castShadow = true;
tableTop.receiveShadow = true;
tableGroup.add(tableTop);

// Borde de madera
const rim = new THREE.Mesh(
  new THREE.TorusGeometry(4.35, 0.25, 16, 100),
  new THREE.MeshStandardMaterial({ color: 0x4a2b12, metalness: 0.2, roughness: 0.5 })
);
rim.rotation.x = Math.PI / 2;
rim.position.y = 0.75;
rim.castShadow = true;
tableGroup.add(rim);

// Sillas
const numSillas = 6;
for (let i = 0; i < numSillas; i++) {
  const angle = (i / numSillas) * Math.PI * 1.2 - Math.PI / 2.4;
  const radius = 4.9;
  const sx = Math.sin(angle) * radius;
  const sz = Math.cos(angle) * radius;

  const seat = new THREE.Mesh(
    new THREE.CylinderGeometry(0.35, 0.35, 0.3, 16),
    new THREE.MeshStandardMaterial({ color: 0x2b1508, roughness: 0.6, metalness: 0.1 })
  );
  seat.position.set(sx, 0.3, sz);
  seat.castShadow = true;
  tableGroup.add(seat);

  const back = new THREE.Mesh(
    new THREE.BoxGeometry(0.4, 0.7, 0.05),
    new THREE.MeshStandardMaterial({ color: 0x2b1508, roughness: 0.6, metalness: 0.1 })
  );
  back.position.set(sx, 0.65, sz - 0.25);
  back.rotation.y = angle;
  tableGroup.add(back);
}

tableGroup.position.set(0, 0, 0);
scene.add(tableGroup);

// ---------- Ruleta ----------
const wheelGroup = new THREE.Group();

const wheelBase = new THREE.Mesh(
  new THREE.CylinderGeometry(2.2, 2.2, 0.4, 48),
  new THREE.MeshStandardMaterial({ color: 0x2f1608, metalness: 0.6, roughness: 0.4 })
);
wheelBase.position.y = 0.3;
wheelGroup.add(wheelBase);

const wheelCanvas = document.createElement('canvas');
wheelCanvas.width = wheelCanvas.height = 1024;
const ctx2 = wheelCanvas.getContext('2d');
const size = 1024, cx = size / 2, cy = size / 2, r = size * 0.42;

ctx2.fillStyle = '#3b2b20';
ctx2.fillRect(0, 0, size, size);

for (let i = 0; i < 18; i++) {
  ctx2.beginPath();
  const start = (i / 18) * Math.PI * 2;
  const end = ((i + 1) / 18) * Math.PI * 2;
  ctx2.moveTo(cx, cy);
  ctx2.arc(cx, cy, r, start, end);
  ctx2.closePath();
  ctx2.fillStyle = (i % 2 === 0) ? '#9b0000' : '#000000';
  ctx2.fill();
}

ctx2.beginPath(); ctx2.fillStyle = '#222'; ctx2.arc(cx, cy, r * 0.55, 0, Math.PI * 2); ctx2.fill();
ctx2.beginPath(); ctx2.fillStyle = '#d1c6b3'; ctx2.arc(cx, cy, r * 0.12, 0, Math.PI * 2); ctx2.fill();

const wheelTex = new THREE.CanvasTexture(wheelCanvas);

const wheelPlate = new THREE.Mesh(
  new THREE.CylinderGeometry(1.9, 1.9, 0.05, 64, 1, false),
  new THREE.MeshStandardMaterial({ map: wheelTex })
);
wheelPlate.position.y = 0.55;
wheelGroup.add(wheelPlate);

const rimMesh = new THREE.Mesh(
  new THREE.TorusGeometry(2.4, 0.18, 16, 100),
  new THREE.MeshStandardMaterial({ color: 0x8b4513, metalness: 0.3, roughness: 0.6 })
);
rimMesh.rotation.x = Math.PI / 2;
rimMesh.position.y = 0.55;
wheelGroup.add(rimMesh);

wheelGroup.position.set(-10, 0.6, 8);
wheelGroup.castShadow = true;
scene.add(wheelGroup);

// Giro automÃ¡tico
function animateWheel() {
  wheelGroup.rotation.y += 0.02;
  requestAnimationFrame(animateWheel);
}
animateWheel();

// ---------- Movimiento cÃ¡mara ----------
let yaw = 0, pitch = 0;
const sens = 0.0026;
window.addEventListener('mousemove', e => {
  yaw -= (e.movementX || 0) * sens;
  pitch -= (e.movementY || 0) * sens;
  const maxP = Math.PI / 2 - 0.05;
  pitch = Math.max(-maxP, Math.min(maxP, pitch));
});

const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

const velocity = new THREE.Vector3();
const accel = 20, damping = 8;
const forward = new THREE.Vector3();
const right = new THREE.Vector3();
const up = new THREE.Vector3(0, 1, 0);
const clock = new THREE.Clock();

function updateMovement(dt) {
  camera.rotation.set(pitch, yaw, 0, "ZYX");
  camera.updateMatrixWorld();
  camera.getWorldDirection(forward);
  forward.y = 0;
  forward.normalize();
  right.copy(forward).cross(up).negate();
  let mx = 0, mz = 0;
  if (keys['KeyW']) mz += 1;
  if (keys['KeyS']) mz -= 1;
  if (keys['KeyD']) mx -= 1;
  if (keys['KeyA']) mx += 1;
  const dir = new THREE.Vector3();
  dir.addScaledVector(forward, mz);
  dir.addScaledVector(right, mx);
  if (dir.lengthSq() > 0) dir.normalize();
  velocity.addScaledVector(dir, accel * dt);
  velocity.multiplyScalar(1 / (1 + damping * dt));
  camera.position.addScaledVector(velocity, dt);
}

// ---------- AnimaciÃ³n ----------
function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.05);
  updateMovement(dt);
  wheelGroup.rotation.y += 0.02;
  renderer.render(scene, camera);
}
animate();

// ---------- Resize ----------
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
