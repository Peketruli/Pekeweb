<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Chats</title>
  <script src="https://unpkg.com/@supabase/supabase-js"></script>
  <style>
    body{margin:0;padding:0;font-family:Arial, sans-serif;display:flex;height:100vh;background:#111;color:#fff}
    .sidebar{width:25%;background:rgba(0,0,0,0.85);padding:18px;overflow-y:auto}
    .chat-section{width:75%;display:flex;flex-direction:column;background:rgba(20,20,20,0.95)}
    .chat-messages{flex:1;padding:18px;overflow:auto;border-bottom:1px solid #333}
    .chat-input{display:flex;padding:12px}
    .chat-input input{flex:1;padding:10px;border-radius:6px;border:none;margin-right:8px;background:#222;color:#fff}
    .chat-input button{padding:10px 14px;border-radius:6px;border:none;background:#0aa;color:#fff;cursor:pointer}
    ul{list-style:none;padding:0;margin:0}
    li{padding:10px;border-bottom:1px solid #222;cursor:pointer}
    li:hover{background:#222}
    .creator{color:#FFD700;font-weight:700}
    .back-button{display:block;margin-bottom:12px;padding:8px 12px;background:#ff5733;border:none;border-radius:6px;color:#fff;cursor:pointer}
    #error-log{margin-top:15px;padding:10px;background:#400;border:1px solid #a00;border-radius:6px;display:none;white-space:pre-wrap}
    .hidden-snowman{
        position:absolute;
        font-size:2rem;
        cursor:pointer;
        transition:0.25s;
        z-index: 100; /* Alto z-index para que estÃ© sobre todo */
    }

    .hidden-snowman.catched{
        opacity:0;
        transform:scale(0);
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <button class="back-button" onclick="window.location.href='h.html'">Volver a Inicio</button>

     Â  <div class="hidden-snowman" data-id="21">â›„</div>
Â  <div class="hidden-snowman" data-id="22">â›„</div>
Â  <div class="hidden-snowman" data-id="23">â›„</div>
Â  <div class="hidden-snowman" data-id="24">â›„</div>
Â  <div class="hidden-snowman" data-id="25">â›„</div>

    <h2>Chats</h2>
    <button onclick="crearChat()">Crear Chat</button>
    <ul id="chat-list"></ul>

    <div style="margin-top:18px">
      <h3>Miembros</h3>
      <ul id="members-list"></ul>
    </div>

    <div id="error-log"></div>
  </div>

  <div class="chat-section">
    <div class="chat-messages" id="chat-messages">
      <p>Selecciona un chat para ver los mensajes...</p>
    </div>

    <div class="chat-input">
      <input id="message-input" placeholder="Escribe un mensaje..." />
      <button onclick="enviarMensaje()">Enviar</button>
    </div>
  </div>

<script>
const SUPABASE_URL = "https://jdvwlfogkzrzovepzjqa.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpkdndsZm9na3pyem92ZXB6anFhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwMzY1MjEsImV4cCI6MjA3MzYxMjUyMX0.IwVFrvuluY0tfgE82XnqYSsRjFPsDYnlfyirHjKu1TI";
const { createClient } = supabase;
const db = createClient(SUPABASE_URL, SUPABASE_KEY);

let usuario = JSON.parse(localStorage.getItem("currentUser")) || { username: "User" + Math.floor(Math.random()*1000) };
let chatActual = null;
let refreshMensajes, refreshMiembros;

/* --- Mostrar errores en pantalla --- */
function mostrarError(msg){
  const log = document.getElementById("error-log");
  log.style.display = "block";
  log.textContent = msg;
}

/* ---------- Inicializar ---------- */
document.addEventListener("DOMContentLoaded", () => {
  cargarChats();

  // ðŸ”„ Refrescar lista de chats cada 5s
  setInterval(cargarChats, 5000);
});

/* ---------- Cargar lista de chats ---------- */
async function cargarChats() {
  const { data: chats, error } = await db
    .from("chats")
    .select("*")
    .order("created_at", { ascending: true });

  if (error) { mostrarError("Error cargando chats: " + error.message); return; }

  const ul = document.getElementById("chat-list");
  ul.innerHTML = "";

  if (!chats || chats.length === 0) {
    const li = document.createElement("li");
    li.textContent = "No hay chats. Crea uno.";
    li.style.cursor = "default";
    ul.appendChild(li);
    return;
  }

  chats.forEach(chat => {
    const li = document.createElement("li");
    li.textContent = chat.nombre;
    li.onclick = () => abrirChat(chat.id);
    ul.appendChild(li);
  });
}

/* ---------- Crear chat ---------- */
async function crearChat() {
  const nombre = prompt("Nombre del chat:");
  if (!nombre) return;

  if (!usuario || !usuario.username) {
    mostrarError("No hay usuario vÃ¡lido.");
    return;
  }

  const { data, error } = await db
    .from("chats")
    .insert([{ nombre, creador: usuario.username, miembros: [usuario.username] }])
    .select()
    .single();

  if (error) { mostrarError("Error al crear chat: " + error.message); return; }

  await cargarChats();
  abrirChat(data.id);
}

/* ---------- Abrir chat ---------- */
async function abrirChat(chatId) {
  const { data: chatData, error } = await db
    .from("chats")
    .select("*")
    .eq("id", chatId)
    .single();

  if (error) { mostrarError("Error abriendo chat: " + error.message); return; }

  // AÃ±adir usuario si no estÃ¡
  let miembros = Array.isArray(chatData.miembros) ? chatData.miembros : [];
  if (!miembros.includes(usuario.username)) {
    miembros.push(usuario.username);
    const { error: updateError } = await db
      .from("chats")
      .update({ miembros })
      .eq("id", chatId);

    if (updateError) { mostrarError("Error actualizando miembros: " + updateError.message); }
  }

  chatActual = chatData;

  // Refrescar miembros y mensajes de entrada
  refrescarMiembros(chatId);
  cargarMensajes(chatId);

  // ðŸ”„ Reiniciar intervalos
  if (refreshMensajes) clearInterval(refreshMensajes);
  if (refreshMiembros) clearInterval(refreshMiembros);

  refreshMensajes = setInterval(() => cargarMensajes(chatId), 5000);
  refreshMiembros = setInterval(() => refrescarMiembros(chatId), 5000);
}

/* ---------- Refrescar miembros ---------- */
async function refrescarMiembros(chatId) {
  const { data: updatedChat, error } = await db
    .from("chats")
    .select("miembros, creador")
    .eq("id", chatId)
    .single();

  if (error) { mostrarError("Error refrescando miembros: " + error.message); return; }

  const membersUl = document.getElementById("members-list");
  membersUl.innerHTML = "";
  const currentMembers = Array.isArray(updatedChat.miembros) ? updatedChat.miembros : [];
  currentMembers.forEach(m => {
    const li = document.createElement("li");
    li.textContent = m;
    if (m === updatedChat.creador) li.classList.add("creator");
    membersUl.appendChild(li);
  });
}

/* ---------- Cargar mensajes ---------- */
async function cargarMensajes(chatId) {
  const { data: mensajes, error } = await db
    .from("chat_messages")
    .select("*")
    .eq("chat_id", chatId)
    .order("created_at", { ascending: true });

  if (error) { mostrarError("Error cargando mensajes: " + error.message); return; }

  const container = document.getElementById("chat-messages");
  container.innerHTML = "";

  if (!mensajes || mensajes.length === 0) {
    container.innerHTML = "<p>No hay mensajes.</p>";
    return;
  }

  mensajes.forEach(m => {
    const p = document.createElement("p");
    const time = new Date(m.created_at).toLocaleTimeString();
    p.textContent = `${m.author} [${time}]: ${m.message}`;
    container.appendChild(p);
  });

  container.scrollTop = container.scrollHeight;
}

/* ---------- Enviar mensaje ---------- */
async function enviarMensaje() {
  const input = document.getElementById("message-input");
  const texto = input.value.trim();
  if (!texto) return;
  if (!chatActual || !chatActual.id) {
    mostrarError("Selecciona un chat antes de enviar un mensaje.");
    return;
  }

  const { error } = await db
    .from("chat_messages")
    .insert([{ chat_id: chatActual.id, author: usuario.username, message: texto }]);

  if (error) { mostrarError("Error al enviar mensaje: " + error.message); return; }

  input.value = "";
  await cargarMensajes(chatActual.id);
}
 // ==================== LÃ“GICA MUÃ‘ECOS ESCONDIDOS AÃ‘ADIDA ====================
let snowmen = JSON.parse(localStorage.getItem("snowmen")) || [];
let collectedIDs = JSON.parse(localStorage.getItem("collectedSnowmenIDs")) || [];
const firstCollectibleIndex = 13; // Primer coleccionable para muÃ±ecos (ID 13)
const maxCollectibleIndex = 22; // Ãšltimo coleccionable para muÃ±ecos (ID 22)


document.addEventListener("DOMContentLoaded", () => {
    // ... (El resto de loadUserInfo y loadBlogs ya estÃ¡n arriba)
    setupSnowmanListeners(); 
});

function unlockCollectible(id){
Â  // Esta es una funciÃ³n auxiliar que debe estar definida en evento.html para que funcione la lÃ³gica de desbloqueo,
    // pero la definimos aquÃ­ para evitar errores y simular el guardado.
Â  // En el blog, solo recogemos y guardamos en localStorage. El desbloqueo visual se harÃ¡ en evento.html.
Â  Â  let coleccion = JSON.parse(localStorage.getItem("coleccionables"));
Â  Â  if(!coleccion) return false;

Â  Â  if(coleccion[id-1] && !coleccion[id-1].unlocked){
Â  Â  Â  coleccion[id-1].unlocked=true;
Â  Â  Â  localStorage.setItem("coleccionables", JSON.stringify(coleccion));
Â  Â  Â  return true;
Â  Â  }
Â  Â  return false;
}

function setupSnowmanListeners() {
    document.querySelectorAll(".hidden-snowman").forEach(sm=>{
        const id = sm.dataset.id;
        
        // PosiciÃ³n aleatoria en la ventana
        const padding = 80; 
        // Usamos document.body.scrollHeight/scrollWidth para posicionar en todo el cuerpo, no solo la vista
        const maxX = window.innerWidth - padding;
        const maxY = document.body.scrollHeight - padding; 
        
        // Intentamos que se posicionen fuera de la zona central del blog-container para que sean "escondidos"
        const isLeft = Math.random() < 0.5;
        
        if (isLeft) {
             // Posicionar en el lado izquierdo (0 a 30% de la ventana)
            sm.style.left = (Math.random() * (window.innerWidth * 0.3 - padding) + padding) + "px";
        } else {
            // Posicionar en el lado derecho (70% al 100% de la ventana)
            sm.style.left = (window.innerWidth * 0.7 + Math.random() * (window.innerWidth * 0.3 - padding) + padding) + "px";
        }

        // PosiciÃ³n vertical aleatoria
        sm.style.top = (Math.random() * (maxY - 200) + 200) + "px"; // 200px para evitar el header

        // Ocultar si ya recogido
        if(collectedIDs.includes(id)) sm.style.display="none";

        sm.addEventListener("click", ()=>{
            if(collectedIDs.includes(id)) return;

            sm.classList.add("catched");
            setTimeout(()=> sm.style.display="none", 200);

            // Guardar en el array de muÃ±ecos
            snowmen.push("MuÃ±eco #" + (snowmen.length + 1));
            localStorage.setItem("snowmen", JSON.stringify(snowmen));

            // Guardar el ID recogido
            collectedIDs.push(id);
            localStorage.setItem("collectedSnowmenIDs", JSON.stringify(collectedIDs));

            const totalCollected = snowmen.length;
            
            let unlockedNow = false;
            let nextNeeded = 5 - (totalCollected % 5);

            // LÃ³gica de desbloqueo (Solo se comprueba y se guarda el estado)
            if(totalCollected % 5 === 0){
                const collectibleToUnlock = firstCollectibleIndex + (totalCollected / 5) - 1;
                
                if(collectibleToUnlock <= maxCollectibleIndex) {
                    if(unlockCollectible(collectibleToUnlock)){
                        unlockedNow = true;
                        alert("â„ï¸ Â¡MuÃ±ecos recogidos! Un coleccionable se ha desbloqueado. Visita el Evento de Navidad para verlo.");
                    }
                } else {
                    alert("âœ… Â¡MuÃ±eco recogido! Ya has desbloqueado todos los coleccionables disponibles.");
                }
            }
            
            if (!unlockedNow && totalCollected < maxCollectibleIndex * 5) {
                alert(`â›„ Â¡MuÃ±eco de nieve recogido! Faltan ${nextNeeded} para el prÃ³ximo coleccionable.`);
            } else if (!unlockedNow) {
                 alert("â›„ Â¡MuÃ±eco de nieve recogido! (Ya has desbloqueado todos los premios)");
            }
        });
    });
}
</script>
</body>
</html>
