<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Hundir la Flota — Avanzado (IA + Multiplayer)</title>
<style>
  :root{
    --bg:#071022;
    --panel:#0d1a2a;
    --accent:#39a0ff;
    --cell:30px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    min-height:100vh;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    background:linear-gradient(180deg,#041026,#071022);
    color:#e6eef6;
    font-family:Inter, Arial, sans-serif;
    padding:18px;
  }
  .container{width:100%;max-width:1150px;display:flex;gap:18px;align-items:flex-start}
  .left, .right{background:var(--panel);border-radius:10px;padding:12px}
  .left{flex:1;min-width:640px}
  .right{width:320px}
  h1{margin:0 0 8px 0;color:var(--accent)}
  .boards{display:flex;gap:20px;align-items:flex-start}
  .board{display:grid;grid-template-columns:repeat(10,var(--cell));gap:4px;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px}
  .cell{width:var(--cell);height:var(--cell);background:#0b2030;border-radius:4px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-weight:700}
  .cell.ship{background:#2a90ff;opacity:0.9}
  .cell.hit{background:#d63b3b;color:#fff}
  .cell.miss{background:#3e4b55;color:#ddd}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  .controls button{padding:8px 10px;border-radius:8px;border:none;background:var(--accent);color:#041022;cursor:pointer}
  .status{margin-top:10px;padding:8px;background:rgba(255,255,255,0.02);border-radius:6px}
  label{display:block;margin-top:8px;font-size:13px}
  .small{font-size:13px;color:#bcd}
  input, select{padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
  .log{margin-top:10px;min-height:30px}
  .room-controls{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  .muted{color:#8aa}
  .rooms-list{margin-top:10px;max-height:180px;overflow:auto;padding:6px;background:rgba(255,255,255,0.02);border-radius:6px}
  .room-item{display:flex;justify-content:space-between;align-items:center;padding:6px;border-bottom:1px solid rgba(255,255,255,0.02)}
  .room-item button{padding:4px 8px;border-radius:6px;border:none;background:#2ecc71;color:#041022;cursor:pointer}
  .room-item button.join{background:#39a0ff;color:#041022}
</style>
</head>
<body>
  <div class="container">
    <div class="left">
      <h1>Hundir la Flota — Avanzado</h1>

      <div style="display:flex;gap:12px;align-items:center;">
        <div>
          <div class="small">Modo</div>
          <select id="mode">
            <option value="local" selected>Local: vs IA</option>
            <option value="multiplayer">Multijugador (Supabase)</option>
          </select>
        </div>

        <div>
          <div class="small">IA dificultad</div>
          <select id="ai-diff">
            <option value="easy">Fácil (aleatorio)</option>
            <option value="normal" selected>Normal (hunt/target)</option>
          </select>
        </div>

        <div style="margin-left:auto">
          <div class="small">Turno</div>
          <div id="turnIndicator" class="muted">—</div>
        </div>
      </div>

      <div class="boards" style="margin-top:12px">
        <div>
          <div class="small">Tu tablero</div>
          <div id="playerBoard" class="board" aria-label="Tu tablero"></div>
        </div>

        <div>
          <div class="small">Tablero rival</div>
          <div id="enemyBoard" class="board" aria-label="Tablero enemigo"></div>
        </div>
      </div>

      <div class="controls">
        <button id="autoPlace">Colocación automática</button>
        <button id="clearPlace">Borrar barcos</button>
        <button id="startBtn">Empezar partida</button>
        <button id="randomShot" title="Para test">Disparo aleatorio (solo local)</button>
        <label style="margin-left:8px" class="small">Coloca barcos clicando celdas (clic cambia sentido)</label>
      </div>

      <div class="status">
        <div class="small">Tu barcos sanos: <span id="playerShipsLeft">-</span></div>
        <div class="small">Rival barcos sanos: <span id="enemyShipsLeft">-</span></div>
        <div class="log" id="log">Listo.</div>
      </div>
    </div>

    <div class="right">
      <h3>Multijugador (Supabase)</h3>
      <div class="small">Sala y unión integradas — usa "Crear sala" o únete a una sala libre listada abajo.</div>

      <div style="margin-top:8px">
        <label>Room ID</label>
        <input id="roomId" placeholder="room-id (ej: room-123)" style="width:100%;padding:6px;border-radius:6px">
      </div>

      <div class="room-controls">
        <button id="createRoom">Crear sala</button>
        <button id="refreshRooms">Refrescar salas libres</button>
      </div>

      <div class="rooms-list" id="roomsList" aria-live="polite"></div>

      <div style="margin-top:10px">
        <div class="small">Estado sala: <span id="roomState">—</span></div>
        <div class="small">Jugador local: <span id="localPlayerId">—</span></div>
      </div>

      <div style="margin-top:12px">
        <div class="small">Notas:</div>
        <ul class="small">
          <li>El primer jugador crea sala y espera un rival.</li>
          <li>Ambos deben pulsar "Empezar partida" cuando colocaron barcos.</li>
        </ul>
      </div>
    </div>
  </div>

<!-- Supabase client (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
<script>
/* ==========================
   Battleship — Avanzado
   - Local IA (hunt/target)
   - Multiplayer via Supabase Realtime
   - Uses a preconfigured Supabase project (no inputs for keys)
   ========================== */

/* ---------- CONFIG: tu proyecto Supabase (preconfigurado) ---------- */
const SUPABASE_URL = "https://jdvwlfogkzrzovepzjqa.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpkdndsZm9na3pyem92ZXB6anFhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwMzY1MjEsImV4cCI6MjA3MzYxMjUyMX0.IwVFrvuluY0tfgE82XnqYSsRjFPsDYnlfyirHjKu1TI";

/* ---------- Constantes del juego ---------- */
const SHIPS_DEF = [
  { name:'carrier', size:5 },
  { name:'battleship', size:4 },
  { name:'cruiser', size:3 },
  { name:'submarine', size:3 },
  { name:'destroyer', size:2 }
];
const N = 10; // 10x10

/* ---------- Estado local ---------- */
let playerBoard = createEmptyBoard();
let enemyBoard = createEmptyBoard(); // for local: AI ships here; for multiplayer: masked view of opponent
let playerShips = [];
let enemyShips = [];
let placingDir = 'H';
let placingIndex = 0;
let gameStarted = false;
let playerTurn = true;
let mode = 'local';
let aiDifficulty = 'normal';

let supabase = null;
let currentRoomId = null;
let localPlayerId = null; // 'p1' or 'p2'
let unsub = null;

/* ---------- DOM ---------- */
const logEl = document.getElementById('log');
const playerBoardEl = document.getElementById('playerBoard');
const enemyBoardEl = document.getElementById('enemyBoard');
const playerShipsLeftEl = document.getElementById('playerShipsLeft');
const enemyShipsLeftEl = document.getElementById('enemyShipsLeft');
const turnIndicator = document.getElementById('turnIndicator');

const autoPlaceBtn = document.getElementById('autoPlace');
const clearPlaceBtn = document.getElementById('clearPlace');
const startBtn = document.getElementById('startBtn');
const randomShotBtn = document.getElementById('randomShot');

const modeSelect = document.getElementById('mode');
const aiDiffSelect = document.getElementById('ai-diff');

/* Multijugador DOM */
const createRoomBtn = document.getElementById('createRoom');
const refreshRoomsBtn = document.getElementById('refreshRooms');
const roomIdInput = document.getElementById('roomId');
const roomsListEl = document.getElementById('roomsList');
const roomStateEl = document.getElementById('roomState');
const localPlayerIdEl = document.getElementById('localPlayerId');

/* ---------------------
   Utilidades y tablero
   --------------------- */
function createEmptyBoard(){ return Array.from({length:N}, ()=>Array(N).fill(null)); }
function coordToIndex(r,c){ return r* N + c; }
function log(s){ logEl.textContent = s; }

function resetBoards(){
  playerBoard = createEmptyBoard();
  enemyBoard = createEmptyBoard();
  playerShips = [];
  enemyShips = [];
  placingDir = 'H';
  placingIndex = 0;
  gameStarted = false;
  playerTurn = true;
  updateUI();
  log('Tableros reiniciados. Coloca tus barcos.');
}

/* DOM boards */
function createBoardDOM(boardEl, clickable, handler){
  boardEl.innerHTML = '';
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const cell = document.createElement('div');
      cell.className='cell';
      cell.dataset.r=r; cell.dataset.c=c;
      if(clickable) cell.addEventListener('click', ()=> handler(r,c,cell));
      boardEl.appendChild(cell);
    }
  }
}

createBoardDOM(playerBoardEl, true, playerBoardClick);
createBoardDOM(enemyBoardEl, true, enemyBoardClick);

/* Update visuals */
function updateUI(){
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    const el = playerBoardEl.children[coordToIndex(r,c)];
    el.className='cell';
    const v = playerBoard[r][c];
    if(v && v.type==='ship' && !v.hit) el.classList.add('ship');
    if(v && v.type==='ship' && v.hit) el.classList.add('hit');
    if(v && v.type==='miss') el.classList.add('miss');
  }
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    const el = enemyBoardEl.children[coordToIndex(r,c)];
    el.className='cell';
    const v = enemyBoard[r][c];
    if(v && v.type==='miss') el.classList.add('miss');
    if(v && v.type==='hit') el.classList.add('hit');
  }
  playerShipsLeftEl.textContent = countShipsRemaining(playerBoard);
  enemyShipsLeftEl.textContent = countShipsRemaining(enemyBoard);
  turnIndicator.textContent = gameStarted ? (playerTurn ? 'Tu turno' : 'Turno rival') : 'No empezada';
}

/* Count ships remaining (cells with ship not hit) */
function countShipsRemaining(board){
  let cnt=0;
  for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(board[r][c] && board[r][c].type==='ship' && !board[r][c].hit) cnt++;
  return cnt;
}

/* ---------------------
   Ship placement
   --------------------- */
function canPlace(board, r,c, size, dir){
  if(dir==='H'){
    if(c+size>10) return false;
    for(let i=0;i<size;i++) if(board[r][c+i]) return false;
  } else {
    if(r+size>10) return false;
    for(let i=0;i<size;i++) if(board[r+i][c]) return false;
  }
  return true;
}
function placeShip(board, r,c, size, name, dir){
  if(!canPlace(board,r,c,size,dir)) return false;
  const positions=[];
  for(let i=0;i<size;i++){
    const rr = dir==='H'? r : r+i;
    const cc = dir==='H'? c+i : c;
    board[rr][cc] = { type:'ship', ship:name, hit:false };
    positions.push([rr,cc]);
  }
  return positions;
}
function autoPlaceAll(board){
  for(let r=0;r<N;r++) for(let c=0;c<N;c++) board[r][c]=null;
  const ships=[];
  for(const s of SHIPS_DEF){
    let placed=false;
    let tries=0;
    while(!placed && tries<1000){
      tries++;
      const dir = Math.random()<0.5?'H':'V';
      const r = Math.floor(Math.random()*10);
      const c = Math.floor(Math.random()*10);
      if(canPlace(board,r,c,s.size,dir)){
        const pos = placeShip(board,r,c,s.size,s.name,dir);
        ships.push({name:s.name,size:s.size,positions:pos, sunk:false});
        placed=true;
      }
    }
    if(!placed) { console.warn('No pudo colocar', s); }
  }
  return ships;
}

/* manual placement click */
function playerBoardClick(r,c,el){
  if(gameStarted) return;
  const s = SHIPS_DEF[placingIndex];
  if(canPlace(playerBoard,r,c,s.size,placingDir)){
    const pos = placeShip(playerBoard,r,c,s.size,s.name,placingDir);
    playerShips.push({name:s.name,size:s.size,positions:pos,sunk:false});
    placingIndex++;
    if(placingIndex >= SHIPS_DEF.length) {
      log('Has colocado todos los barcos. Pulsa Empezar partida.');
    } else {
      log(`Colocado ${s.name}. Siguiente: ${SHIPS_DEF[placingIndex].name}`);
    }
    updateUI();
  } else {
    placingDir = placingDir==='H'?'V':'H';
    log(`No cabe ahí — cambié orientación a ${placingDir}. Inténtalo otra vez.`);
  }
}

/* clear placement */
document.getElementById('clearPlace').addEventListener('click', ()=>{ resetBoards(); });

document.getElementById('autoPlace').addEventListener('click', ()=> {
  playerShips = autoPlaceAll(playerBoard);
  updateUI();
  log('Colocados aleatoriamente tus barcos.');
});

/* ---------------------
   Game start & shooting
   --------------------- */
startBtn.addEventListener('click', ()=>{
  if(mode === 'multiplayer'){
    if(!currentRoomId) return alert('Une o crea sala primero.');
    sendLocalReady(); // will mark ships placed in DB and possibly start the game when both ready
  } else {
    if(!playerShips.length) playerShips = autoPlaceAll(playerBoard);
    enemyShips = autoPlaceAll(enemyBoard);
    gameStarted = true;
    playerTurn = true;
    updateUI();
    log('Partida local iniciada. Tu turno.');
  }
});

/* player's click on enemy board to shoot */
function enemyBoardClick(r,c,el){
  if(!gameStarted || !playerTurn || (mode === 'multiplayer' && !isMyTurn())) return;
  if(enemyBoard[r][c] && (enemyBoard[r][c].type === 'hit' || enemyBoard[r][c].type === 'miss')) return;
  if(mode === 'local'){
    if(enemyBoard[r][c] && enemyBoard[r][c].type === 'ship') {
      enemyBoard[r][c].hit = true;
      enemyBoard[r][c].type = 'hit';
      log('¡Impacto!');
    } else {
      enemyBoard[r][c] = { type:'miss' };
      log('Agua.');
    }
    updateUI();
    checkEndLocal();
    playerTurn = false;
    setTimeout(()=> aiTurn(), 600);
  } else {
    sendShotToServer(r,c);
  }
}

/* check end local */
function checkEndLocal(){
  const enemyLeft = countShipsRemaining(enemyBoard);
  if(enemyLeft === 0) { log('¡Has ganado!'); gameStarted=false; return; }
  const playerLeft = countShipsRemaining(playerBoard);
  if(playerLeft === 0) { log('Has perdido.'); gameStarted=false; return; }
}

/* ---------------------
   AI (hunt/target)
   --------------------- */
let aiMemory = { hits:[], candidates:[], tried:new Set() };

document.getElementById('randomShot').addEventListener('click', ()=> {
  if(mode!=='local') return;
  const [r,c] = [Math.floor(Math.random()*N), Math.floor(Math.random()*N)];
  enemyBoardClick(r,c);
});

function aiTurn(){
  if(!gameStarted) return;
  log('IA pensándolo...');
  let r,c;
  if(aiDifficulty === 'easy'){
    [r,c] = aiChooseRandom(playerBoard);
  } else {
    [r,c] = aiChooseHuntTarget();
  }
  if(playerBoard[r][c] && playerBoard[r][c].type === 'ship'){
    playerBoard[r][c].hit = true;
    playerBoard[r][c].type = 'hit';
    log('IA: ¡Impacto!');
    aiMemory.hits.push([r,c].toString());
    addCandidatesAround(r,c);
  } else {
    playerBoard[r][c] = { type:'miss' };
    log('IA: Agua.');
  }
  updateUI();
  checkEndLocal();
  playerTurn = true;
}

/* AI helpers */
function aiChooseRandom(board){
  let tries=0;
  while(true){
    const r = Math.floor(Math.random()*N);
    const c = Math.floor(Math.random()*N);
    const key = `${r},${c}`;
    if(!aiMemory.tried.has(key) && (!board[r][c] || (board[r][c] && board[r][c].type!=='hit' && board[r][c].type!=='miss'))){
      aiMemory.tried.add(key);
      return [r,c];
    }
    if(++tries>1000) return [Math.floor(Math.random()*N),Math.floor(Math.random()*N)];
  }
}
function addCandidatesAround(r,c){
  const deltas = [[1,0],[-1,0],[0,1],[0,-1]];
  for(const [dr,dc] of deltas){
    const rr=r+dr, cc=c+dc;
    if(rr>=0 && rr<N && cc>=0 && cc<N){
      const key = `${rr},${cc}`;
      if(!aiMemory.tried.has(key)) aiMemory.candidates.push([rr,cc]);
    }
  }
}
function aiChooseHuntTarget(){
  while(aiMemory.candidates.length){
    const [r,c] = aiMemory.candidates.shift();
    const key = `${r},${c}`;
    if(aiMemory.tried.has(key)) continue;
    aiMemory.tried.add(key);
    return [r,c];
  }
  return aiChooseRandom(playerBoard);
}

/* ---------------------
   Supabase multiplayer
   --------------------- */
function initSupabase(){
  if(supabase) return supabase;
  supabase = supabaseJs.createClient(SUPABASE_URL, SUPABASE_KEY);
  return supabase;
}

/* Create room — writes initial state */
createRoomBtn.addEventListener('click', async ()=>{
  initSupabase();
  const room = roomIdInput.value.trim() || 'room-' + Math.random().toString(36).slice(2,8);
  currentRoomId = room;
  localPlayerId = 'p1';
  localPlayerIdEl.textContent = localPlayerId;

  const initial = {
    players: {
      p1: { boardMasked: createEmptyBoardMasked(), shipsPlaced:false },
      p2: { boardMasked: createEmptyBoardMasked(), shipsPlaced:false }
    },
    fullBoards: { p1: createEmptyBoardFull(), p2: createEmptyBoardFull() },
    turn: 'p1',
    started: false,
    winner: null
  };
  // attach current local player's full board (might be empty if haven't placed)
  initial.fullBoards.p1 = boardToSerializable(playerBoard);
  const { data, error } = await supabase.from('games').upsert({ id: room, state: initial });
  if(error){ console.error(error); alert('Error creando sala: ' + error.message); return; }
  log('Sala creada: ' + room + ' (esperando rival)');
  roomStateEl.textContent = 'creada - esperando rival';
  subscribeRoom(room);
  // refresh rooms list
  fetchOpenRooms();
});

/* Fetch open (free) rooms and render list */
refreshRoomsBtn.addEventListener('click', fetchOpenRooms);
async function fetchOpenRooms(){
  initSupabase();
  roomsListEl.innerHTML = 'Buscando...';
  // read all games and filter client-side for "free" rooms (started === false and fullBoards.p2 is empty)
  const { data, error } = await supabase.from('games').select('id,state').order('created_at',{ascending:false}).limit(200);
  if(error){ console.error(error); roomsListEl.innerHTML = '<div class="small">Error al listar salas</div>'; return; }
  const free = [];
  for(const row of data){
    const st = row.state;
    if(!st) continue;
    // consider free if not started and fullBoards.p2 has no ship cells (all null)
    if(!st.started){
      const fb2 = st.fullBoards && st.fullBoards.p2;
      let occupied=false;
      if(fb2){
        for(let r=0;r<N && !occupied;r++) for(let c=0;c<N;c++) if(fb2[r][c]) { occupied=true; break; }
      }
      if(!occupied) free.push(row.id);
    }
  }
  renderRoomsList(free);
}

/* render rooms list */
function renderRoomsList(list){
  roomsListEl.innerHTML = '';
  if(!list.length){ roomsListEl.innerHTML = '<div class="small">No hay salas libres.</div>'; return; }
  for(const id of list){
    const div = document.createElement('div');
    div.className = 'room-item';
    const lbl = document.createElement('div');
    lbl.textContent = id;
    const btn = document.createElement('button');
    btn.textContent = 'Unirse';
    btn.className = 'join';
    btn.addEventListener('click', ()=> joinRoomById(id));
    div.appendChild(lbl); div.appendChild(btn);
    roomsListEl.appendChild(div);
  }
}

/* Join a room by clicking list (or input) */
async function joinRoomById(room){
  initSupabase();
  const roomId = room || roomIdInput.value.trim();
  if(!roomId) return alert('Introduce room id o selecciona una sala libre.');
  currentRoomId = roomId;
  localPlayerId = 'p2';
  localPlayerIdEl.textContent = localPlayerId;
  // fetch state
  const { data, error } = await supabase.from('games').select('state').eq('id', roomId).single();
  if(error || !data) return alert('No existe sala o error: ' + (error? error.message: 'no data'));
  const state = data.state;
  // set our fullBoards.p2 to our placed board (players should have placed or auto-place)
  state.fullBoards.p2 = boardToSerializable(playerBoard);
  // update DB
  await supabase.from('games').update({ state }).eq('id', roomId);
  log('Unido a sala: ' + roomId);
  roomStateEl.textContent = 'unido - listo';
  subscribeRoom(roomId);
}

/* subscribe to room changes */
async function subscribeRoom(room){
  initSupabase();
  if(unsub) {
    try{ await unsub.unsubscribe(); }catch(e){}
    unsub=null;
  }
  const chan = supabase.channel('room-'+room);
  chan.on('postgres_changes', { event: '*', schema:'public', table:'games', filter:`id=eq.${room}` }, (payload)=>{
    if(payload.eventType === 'INSERT' || payload.eventType === 'UPDATE'){
      const newState = payload.new.state;
      handleRemoteState(newState);
    }
  });
  await chan.subscribe();
  unsub = chan;
  // fetch current state once and apply
  const res = await supabase.from('games').select('state').eq('id', room).single();
  if(res.data) handleRemoteState(res.data.state);
}

/* handle incoming state */
function handleRemoteState(state){
  if(!state) return;
  roomStateEl.textContent = state.started ? 'jugando' : 'en preparación';
  // determine other player key
  const myKey = localPlayerId;
  const otherKey = myKey === 'p1' ? 'p2' : 'p1';
  // apply masked board for other player into enemyBoard
  if(state.players && state.players[otherKey] && state.players[otherKey].boardMasked){
    const masked = state.players[otherKey].boardMasked;
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      enemyBoard[r][c] = masked[r][c] ? { type: masked[r][c] } : null;
    }
  }
  gameStarted = state.started;
  playerTurn = (state.turn === localPlayerId);
  updateUI();
  if(state.winner) { log('Partida finalizada. Ganador: ' + state.winner); }
}

/* helpers serializable */
function createEmptyBoardMasked(){ return Array.from({length:N}, ()=>Array(N).fill(null)); }
function createEmptyBoardFull(){ return Array.from({length:N}, ()=>Array(N).fill(null)); }

function boardToSerializable(board){
  const out = Array.from({length:N}, ()=>Array(N).fill(null));
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    const v = board[r][c];
    if(!v) out[r][c] = null;
    else if(v.type === 'ship') out[r][c] = {type:'ship', ship:v.ship, hit:!!v.hit};
    else if(v.type === 'hit') out[r][c] = { type:'hit' };
    else if(v.type === 'miss') out[r][c] = { type:'miss' };
  }
  return out;
}

/* send ready in multiplayer */
async function sendLocalReady(){
  initSupabase();
  if(!supabase || !currentRoomId || !localPlayerId) return;
  const { data, error } = await supabase.from('games').select('state').eq('id', currentRoomId).single();
  if(error || !data) return alert('Error read room: ' + (error? error.message: 'no data'));
  const state = data.state;
  state.fullBoards[localPlayerId] = boardToSerializable(playerBoard);
  state.players[localPlayerId].shipsPlaced = true;
  if(state.players.p1.shipsPlaced && state.players.p2.shipsPlaced){
    state.started = true;
    state.turn = 'p1';
  }
  state.players[localPlayerId].boardMasked = createEmptyBoardMasked();
  await supabase.from('games').update({ state }).eq('id', currentRoomId);
  log('Lista: enviado ready al servidor.');
}

/* send shot (applies logic in DB record via client-side update) */
async function sendShotToServer(r,c){
  initSupabase();
  if(!supabase || !currentRoomId || !localPlayerId) return;
  const { data, error } = await supabase.from('games').select('state').eq('id', currentRoomId).single();
  if(error || !data) return alert('Error read room: ' + (error? error.message: 'no data'));
  const state = data.state;
  if(state.turn !== localPlayerId) return alert('No es tu turno');
  const opponent = localPlayerId === 'p1' ? 'p2' : 'p1';
  const targetFull = state.fullBoards[opponent];
  const mask = state.players[opponent].boardMasked || createEmptyBoardMasked();
  if(targetFull[r][c] && targetFull[r][c].type === 'ship'){
    mask[r][c] = 'hit';
    targetFull[r][c].hit = true;
  } else {
    mask[r][c] = 'miss';
  }
  state.players[opponent].boardMasked = mask;
  state.turn = opponent;
  let opponentLeft = 0;
  for(let rr=0; rr<N; rr++) for(let cc=0; cc<N; cc++){
    const t = targetFull[rr][cc];
    if(t && t.type==='ship' && !t.hit) opponentLeft++;
  }
  if(opponentLeft === 0){
    state.started = false;
    state.winner = localPlayerId;
  }
  state.fullBoards[opponent] = targetFull;
  await supabase.from('games').update({ state }).eq('id', currentRoomId);
}

/* check whose turn */
function isMyTurn(){ return playerTurn && mode === 'multiplayer' ? (playerTurn && localPlayerId && (localPlayerId === (playerTurn? localPlayerId : null))) : playerTurn; }

/* ---------------------
   initialization & helpers
   --------------------- */
modeSelect.addEventListener('change', ()=> {
  mode = modeSelect.value;
  resetBoards();
  if(mode === 'multiplayer') log('Seleccionado modo multijugador. Crea o únete a una sala libre.');
});
aiDiffSelect.addEventListener('change', ()=> aiDifficulty = aiDiffSelect.value);

function initLocal(){
  resetBoards();
  enemyShips = autoPlaceAll(enemyBoard);
  updateUI();
}
resetBoards();
initLocal();
fetchOpenRooms();

/* expose debug */
window._battleship = { playerBoard, enemyBoard, resetBoards, autoPlaceAll, initLocal, fetchOpenRooms };

/* end */
</script>
</body>
</html>
