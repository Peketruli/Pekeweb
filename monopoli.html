<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Monopoly ‚Äî Tablero 700x700 con cartas animadas</title>
<style>
  :root{--bg:#cfe7ef;--panel:#fff;}
  body{margin:0; font-family:Arial,Helvetica,sans-serif; background:var(--bg); display:flex; justify-content:center; padding:18px;}
  #container{display:flex; gap:18px; align-items:flex-start;}
  canvas{background:#fafafa; border:4px solid #333; box-shadow:0 6px 20px rgba(0,0,0,0.12);}
  #hud{width:320px; background:var(--panel); padding:14px; border-radius:8px; box-shadow:0 6px 20px rgba(0,0,0,0.08);}
  h2{margin:6px 0 10px; font-size:18px; text-align:center;}
  .btn{display:block; width:100%; padding:10px; margin:8px 0; border-radius:6px; border:none; font-weight:600; cursor:pointer;}
  #rollBtn{background:#2b8aef;color:#fff;}
  #payJailBtn{background:#e67e22;color:#fff; display:none;}
  #useCardBtn{background:#27ae60;color:#fff; display:none;}
  .info{background:#f3f6f8;padding:8px;border-radius:6px;margin-top:8px; font-size:14px;}
  .small{font-size:13px;color:#444;margin-top:6px;}
  .playersList{margin-top:8px;}
  .playerRow{display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px dashed #eee;}
  .center{display:flex;gap:8px;align-items:center;justify-content:center;}
  /* overlay modal for card reveal */
  #cardModal {
    position: fixed;
    left: 0; top: 0; right: 0; bottom: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.45);
    z-index: 9999;
  }
  #cardBox {
    width: 380px; min-height:120px; background: #fff; border-radius:10px; padding:18px; box-shadow: 0 8px 30px rgba(0,0,0,0.3);
    display:flex; flex-direction:column; gap:10px;
  }
  #cardText { font-size:16px; }
  #closeCardBtn { margin-left:auto; padding:8px 12px; border-radius:6px; border:none; background:#2b8aef; color:#fff; cursor:pointer; }
  /* small card visual used during animation */
  .floatingCard {
    position: fixed;
    width: 160px; height: 100px; background: #fff; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.25);
    display:flex; align-items:center; justify-content:center; font-weight:600;
    z-index: 9998;
  }
</style>
</head>
<body>
<div id="container">
  <canvas id="gameCanvas" width="700" height="700"></canvas>

  <div id="hud">
    <h2>Monopoly ‚Äî Turno: <span id="turnName">Jugador</span></h2>
    <div class="playersList" id="playersList"></div>

    <div class="center">
      <button id="rollBtn" class="btn">üé≤ Tirar dados</button>
    </div>

    <div class="center small">
      <button id="payJailBtn" class="btn" style="width:auto;padding:8px 10px;">üíµ Pagar $50 y salir</button>
      <button id="useCardBtn" class="btn" style="width:auto;padding:8px 10px;">üÉè Usar "Salir de la c√°rcel"</button>
    </div>

    <div class="info" id="infoBox">Bienvenido ‚Äî pulsa "Tirar dados".</div>

    <div class="small" style="margin-top:10px;">
      <strong>Cartas en mesa:</strong>
      <div>Suerte: <span id="suerteCount"></span> ‚Äî Arca: <span id="arcaCount"></span></div>
    </div>
  </div>
</div>

<!-- Modal para mostrar carta -->
<div id="cardModal" role="dialog" aria-hidden="true">
  <div id="cardBox">
    <div id="cardText">Contenido de la carta</div>
    <div style="display:flex; justify-content:flex-end;">
      <button id="closeCardBtn">Cerrar</button>
    </div>
  </div>
</div>

<script>
/* ============== CONFIG / ESTADO ============== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const SIZE = 700;
const CELLS = 10;
const CELL = SIZE / CELLS; // 70

/* TABLERO (esquinas tienen type:"especial" y no color) */
const board = [
  {name:"Salida", type:"especial"},
  {name:"Ronda de Valencia", color:"#8B4513", price:60, type:"propiedad"},
  {name:"Comunidad", type:"arca"},
  {name:"Plaza Lavapi√©s", color:"#8B4513", price:60, type:"propiedad"},
  {name:"Impuesto", type:"impuesto"},
  {name:"Estaci√≥n Mediod√≠a", type:"estacion", price:200},
  {name:"Glorieta Cuatro Caminos", color:"#ADD8E6", price:100, type:"propiedad"},
  {name:"Suerte", type:"suerte"},
  {name:"Avenida Reina Victoria", color:"#ADD8E6", price:100, type:"propiedad"},
  {name:"Calle Bravo Murillo", color:"#ADD8E6", price:120, type:"propiedad"},

  {name:"C√°rcel", type:"especial"},
  {name:"Glorieta Bilbao", color:"#FFC0CB", price:140, type:"propiedad"},
  {name:"Compa√±√≠a electricidad", type:"compa√±ia", price:150},
  {name:"Calle Alberto Aguilera", color:"#FFC0CB", price:140, type:"propiedad"},
  {name:"Calle Fuencarral", color:"#FFC0CB", price:160, type:"propiedad"},
  {name:"Estaci√≥n Norte", type:"estacion", price:200},
  {name:"Avenida Felipe II", color:"#FFA500", price:180, type:"propiedad"},
  {name:"Comunidad", type:"arca"},
  {name:"Calle Serrano", color:"#FFA500", price:180, type:"propiedad"},
  {name:"Calle Vel√°zquez", color:"#FFA500", price:200, type:"propiedad"},

  {name:"Parking", type:"especial"},
  {name:"Avenida de Am√©rica", color:"#FF0000", price:220, type:"propiedad"},
  {name:"Suerte", type:"suerte"},
  {name:"Calle Mar√≠a de Molina", color:"#FF0000", price:220, type:"propiedad"},
  {name:"Calle Cea Berm√∫dez", color:"#FF0000", price:240, type:"propiedad"},
  {name:"Estaci√≥n Delicias", type:"estacion", price:200},
  {name:"Avenida de los Poblados", color:"#FFFF00", price:260, type:"propiedad"},
  {name:"Calle O'Donnell", color:"#FFFF00", price:260, type:"propiedad"},
  {name:"Compa√±√≠a de agua", type:"compa√±ia", price:150},
  {name:"Calle Goya", color:"#FFFF00", price:280, type:"propiedad"},

  {name:"Ve a la c√°rcel", type:"especial"},
  {name:"Calle Alcal√°", color:"#008000", price:300, type:"propiedad"},
  {name:"Calle Gran V√≠a", color:"#008000", price:300, type:"propiedad"},
  {name:"Comunidad", type:"arca"},
  {name:"Paseo de la Castellana", color:"#008000", price:320, type:"propiedad"},
  {name:"Estaci√≥n Sur", type:"estacion", price:200},
  {name:"Suerte", type:"suerte"},
  {name:"Paseo del Prado", color:"#0000FF", price:350, type:"propiedad"},
  {name:"Impuesto de lujo", type:"impuesto"},
  {name:"Calle Serrano Mayor", color:"#0000FF", price:400, type:"propiedad"}
];

const players = [
  {name:"Jugador", color:"#1f77b4", pos:0, money:1500, properties:[], inJail:false, jailTurns:0, hasGetOutCard:false},
  {name:"IA", color:"#d62728", pos:0, money:1500, properties:[], inJail:false, jailTurns:0, hasGetOutCard:false}
];

let current = 0;
let animating = false;
let diceRolling = false;
let diceResult = [1,1];
let lastRollWasDouble = false;

/* Decks */
let suerteDeck = [];
let arcaDeck = [];

/* UI references */
const rollBtn = document.getElementById('rollBtn');
const payJailBtn = document.getElementById('payJailBtn');
const useCardBtn = document.getElementById('useCardBtn');
const infoBox = document.getElementById('infoBox');
const turnName = document.getElementById('turnName');
const playersListDiv = document.getElementById('playersList');
const suerteCount = document.getElementById('suerteCount');
const arcaCount = document.getElementById('arcaCount');
const cardModal = document.getElementById('cardModal');
const cardTextEl = document.getElementById('cardText');
const closeCardBtn = document.getElementById('closeCardBtn');

/* ================ UTIL / DECKS ================ */
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

function createDecks(){
  suerteDeck = [
    {text:"Avanza a Salida. Cobra $200.", action:(p)=>{ p.pos=0; p.money+=200; showMsg(`${p.name} avanza a Salida y cobra $200`); }},
    {text:"Ve a la C√°rcel (no cobras por pasar).", action:(p)=>{ p.pos=10; p.inJail=true; p.jailTurns=0; showMsg(`${p.name} va a la c√°rcel`); }},
    {text:"Cobras $150.", action:(p)=>{ p.money+=150; showMsg(`${p.name} cobra $150`); }},
    {text:"Paga $50.", action:(p)=>{ p.money-=50; showMsg(`${p.name} paga $50`); }},
    {text:"Toma tarjeta 'Salir de la c√°rcel'.", action:(p)=>{ p.hasGetOutCard=true; showMsg(`${p.name} obtiene 'Salir de la c√°rcel'`); }},
    {text:"Avanza a Paseo del Prado.", action:(p)=>{ p.pos=38; showMsg(`${p.name} avanza a Paseo del Prado`); }},
    {text:"Avanza a la pr√≥xima estaci√≥n. Paga si no es tuya.", action:(p)=>{ advanceToNextStation(p); }}
  ];

  arcaDeck = [
    {text:"Cobras $100.", action:(p)=>{ p.money+=100; showMsg(`${p.name} cobra $100`); }},
    {text:"Paga $50.", action:(p)=>{ p.money-=50; showMsg(`${p.name} paga $50`); }},
    {text:"Toma tarjeta 'Salir de la c√°rcel'.", action:(p)=>{ p.hasGetOutCard=true; showMsg(`${p.name} obtiene 'Salir de la c√°rcel'`); }},
    {text:"Recibe $40 de otros (simplificado).", action:(p)=>{ p.money+=40; showMsg(`${p.name} recibe $40 (simplificado)`); }},
    {text:"Avanza a Salida. Cobra $200.", action:(p)=>{ p.pos=0; p.money+=200; showMsg(`${p.name} avanza a Salida y cobra $200`); }}
  ];

  shuffle(suerteDeck);
  shuffle(arcaDeck);
}

/* ================= DRAW HELPERS ================= */
function getCoords(pos){
  if(pos < 10) return {x: SIZE - CELL*(pos+1), y: SIZE - CELL}; // bottom row (right->left)
  if(pos < 20) return {x: 0, y: SIZE - CELL*(pos-9)}; // left column (bottom->top)
  if(pos < 30) return {x: CELL*(pos-20), y: 0}; // top row (left->right)
  return {x: SIZE - CELL, y: CELL*(pos-30)}; // right column (top->bottom)
}
function wrapText(ctx, text, maxWidth){
  const words = text.split(' ');
  const lines = [];
  let line = "";
  for(let w of words){
    const test = line ? line + " " + w : w;
    if(ctx.measureText(test).width > maxWidth){
      lines.push(line);
      line = w;
    } else {
      line = test;
    }
  }
  if(line) lines.push(line);
  return lines;
}

/* Draw the board with names and center decks */
function drawBoard(){
  ctx.clearRect(0,0,SIZE,SIZE);
  ctx.lineWidth = 1;
  ctx.strokeStyle = "#222";

  // outer squares grid
  for(let i=0;i<CELLS;i++){
    // top row
    ctx.strokeRect(i*CELL, 0, CELL, CELL);
    // bottom row
    ctx.strokeRect(i*CELL, SIZE-CELL, CELL, CELL);
    // left col
    ctx.strokeRect(0, i*CELL, CELL, CELL);
    // right col
    ctx.strokeRect(SIZE-CELL, i*CELL, CELL, CELL);
  }

  // draw cells content
  ctx.font = "12px Arial";
  for(let i=0;i<40;i++){
    const c = board[i];
    const p = getCoords(i);

    // only draw color stripe for properties/stations/companies (not for specials)
    if(c.color && c.type && (c.type === "propiedad" || c.type === "estacion")){
      ctx.fillStyle = c.color;
      ctx.fillRect(p.x, p.y, CELL, 10);
    }

    // Name text inside cell (wrap)
    ctx.fillStyle = "#111";
    const textX = p.x + 6;
    const textYStart = p.y + 22;
    const lines = wrapText(ctx, c.name, CELL - 10);
    for(let li=0; li<Math.min(lines.length,4); li++){
      ctx.fillText(lines[li], textX, textYStart + li*14);
    }

    // If property, show price at bottom-left
    if(c.price && c.type !== "especial"){
      ctx.font = "11px Arial";
      ctx.fillStyle = "#333";
      ctx.fillText(`$${c.price}`, p.x + 6, p.y + CELL - 10);
      ctx.font = "12px Arial";
    }

    // If special or tax/suerte mark bottom
    if(c.type === "suerte" || c.type === "arca"){
      ctx.fillStyle = "#222";
      ctx.fillText(c.type.toUpperCase(), p.x + 6, p.y + CELL - 10);
    } else if(c.type === "impuesto"){
      ctx.fillStyle = "#b33";
      ctx.fillText("IMPUESTO", p.x + 6, p.y + CELL - 10);
    } else if(c.type === "especial"){
      // draw bold short label for corners
      ctx.fillStyle = "#000";
      ctx.font = "bold 13px Arial";
      // center label
      const label = c.name;
      const labelLines = wrapText(ctx, label, CELL - 10);
      for(let li=0; li<labelLines.length && li<2; li++){
        ctx.fillText(labelLines[li], p.x + 6, p.y + CELL - (28 - li*14));
      }
      ctx.font = "12px Arial";
    }
  }

  // Draw decks in center
  const centerX = SIZE/2, centerY = SIZE/2;
  const deckW = 60, deckH = 90;
  // Arca
  ctx.fillStyle = "#fff";
  ctx.fillRect(centerX - deckW - 12, centerY - deckH/2, deckW, deckH);
  ctx.strokeStyle = "#333";
  ctx.strokeRect(centerX - deckW - 12, centerY - deckH/2, deckW, deckH);
  ctx.fillStyle = "#333";
  ctx.font = "bold 12px Arial";
  ctx.fillText("ARCA", centerX - deckW - 12 + 10, centerY);
  // Suerte
  ctx.fillStyle = "#fff";
  ctx.fillRect(centerX + 12, centerY - deckH/2, deckW, deckH);
  ctx.strokeRect(centerX + 12, centerY - deckH/2, deckW, deckH);
  ctx.fillStyle = "#333";
  ctx.fillText("SUERTE", centerX + 12 + 6, centerY);

  // counts on decks
  ctx.font = "11px Arial";
  ctx.fillText(`${arcaDeck.length}`, centerX - deckW - 12 + deckW - 14, centerY + deckH/2 - 8);
  ctx.fillText(`${suerteDeck.length}`, centerX + 12 + deckW - 14, centerY + deckH/2 - 8);

  // draw players tokens
  players.forEach((pl, idx) => {
    const co = getCoords(pl.pos);
    const fx = co.x + CELL/2 + (idx===0 ? -14 : 14);
    const fy = co.y + CELL/2 + (idx===0 ? -10 : 10);
    ctx.fillStyle = pl.color;
    ctx.beginPath();
    ctx.arc(fx, fy, 12, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.stroke();
  });
}

/* ============= GAME / TURN / MOVEMENT ============= */
function showMsg(t){ infoBox.textContent = t; }
function updateHUD(){
  turnName.textContent = players[current].name;
  playersListDiv.innerHTML = "";
  players.forEach(p=>{
    const row = document.createElement('div'); row.className = "playerRow";
    const left = document.createElement('div'); left.innerHTML = `<strong style="color:${p.color}">${p.name}</strong><br><span class="small">Pos: ${p.pos}</span>`;
    const right = document.createElement('div'); right.innerHTML = `<div>$${p.money}</div><div class="small">${p.properties.length} propiedades</div>`;
    row.appendChild(left); row.appendChild(right);
    playersListDiv.appendChild(row);
  });
  suerteCount.textContent = suerteDeck.length;
  arcaCount.textContent = arcaDeck.length;

  // jail controls visibility
  const pl = players[current];
  if(pl.inJail){
    payJailBtn.style.display = "inline-block";
    useCardBtn.style.display = pl.hasGetOutCard ? "inline-block" : "none";
    rollBtn.disabled = false;
  } else {
    payJailBtn.style.display = "none";
    useCardBtn.style.display = "none";
  }
}

/* next turn */
function nextTurn(){
  current = (current + 1) % players.length;
  lastRollWasDouble = false;
  updateHUD();
  drawBoard();
  // If IA turn, trigger AI
  if(players[current].name === "IA"){
    setTimeout(()=> aiTakeTurn(players[current]), 700);
  }
}

/* animate movement step-by-step */
function animateMove(pl, steps){
  if(animating) return;
  animating = true;
  let s = 0;
  function step(){
    if(s<steps){
      pl.pos++;
      if(pl.pos>=40){ pl.pos-=40; pl.money += 200; showMsg(`${pl.name} pasa por Salida +$200`); }
      s++;
      drawBoard();
      updateHUD();
      setTimeout(step, 180);
    } else {
      animating = false;
      handleLanding(pl);
    }
  }
  step();
}

/* landing handler -- if card, play animation */
function handleLanding(pl){
  const cell = board[pl.pos];
  if(cell.type === "propiedad" || cell.type === "estacion" || cell.type === "compa√±ia"){
    if(!cell.owner){
      if(pl.name === "Jugador"){
        const ok = confirm(`¬øComprar ${cell.name} por $${cell.price}?`);
        if(ok){ pl.money -= cell.price; cell.owner = pl.name; pl.properties.push(cell); showMsg(`${pl.name} compra ${cell.name}`); }
        else showMsg(`${pl.name} no compra ${cell.name}`);
      } else {
        if(pl.money > cell.price + 200){ pl.money -= cell.price; cell.owner = pl.name; pl.properties.push(cell); showMsg(`IA compra ${cell.name}`); }
        else showMsg(`IA no compra ${cell.name}`);
      }
    } else if(cell.owner !== pl.name){
      const owner = players.find(p=>p.name === cell.owner);
      const rent = Math.floor(cell.price/2);
      pl.money -= rent; owner.money += rent;
      showMsg(`${pl.name} paga $${rent} a ${owner.name}`);
    } else showMsg(`${pl.name} cae en su propia propiedad`);
    drawBoard(); updateHUD();
    setTimeout(()=> nextTurn(), 800);
  } else if(cell.type === "impuesto"){
    pl.money -= 100; showMsg(`${pl.name} paga impuesto $100`);
    drawBoard(); updateHUD();
    setTimeout(()=> nextTurn(), 800);
  } else if(cell.type === "suerte"){
    // animate taking card from center to modal reveal
    animateTakeCard("suerte", pl);
  } else if(cell.type === "arca"){
    animateTakeCard("arca", pl);
  } else if(cell.name === "Ve a la c√°rcel"){
    pl.pos = 10; pl.inJail = true; pl.jailTurns = 0; showMsg(`${pl.name} va directo a la c√°rcel`);
    drawBoard(); updateHUD();
    setTimeout(()=> nextTurn(), 800);
  } else if(cell.name === "C√°rcel"){
    showMsg(`${pl.name} est√° en la casilla de C√°rcel`);
    setTimeout(()=> nextTurn(), 800);
  } else {
    showMsg(`${pl.name} cae en ${cell.name}`);
    setTimeout(()=> nextTurn(), 800);
  }
}

/* advance to next station simplified */
function advanceToNextStation(player){
  const stations = [5,15,25,35];
  for(let s of stations){
    if(s > player.pos){ player.pos = s; break; }
  }
  const cell = board[player.pos];
  if(cell.owner && cell.owner !== player.name){
    const owner = players.find(p=>p.name === cell.owner);
    player.money -= 100; owner.money += 100;
    showMsg(`${player.name} paga $100 a ${owner.name} por estaci√≥n`);
  } else showMsg(`${player.name} avanza a estaci√≥n`);
  drawBoard(); updateHUD();
  setTimeout(()=> nextTurn(), 900);
}

/* ============ CARD ANIMATION & REVEAL ============ */

/* draw a floating card element and animate from deck center to middle of screen, then show modal with content */
function animateTakeCard(deckName, player){
  // position of deck in canvas coordinates -> convert to screen coordinates
  const canvasRect = canvas.getBoundingClientRect();
  const deckCenterCanvas = { x: SIZE/2 + (deckName==="arca"? - (60/2 + 12) : (60/2 + 12)), y: SIZE/2 };
  const deckScreen = { x: canvasRect.left + deckCenterCanvas.x, y: canvasRect.top + deckCenterCanvas.y };

  // create floating card DOM
  const cardEl = document.createElement('div');
  cardEl.className = 'floatingCard';
  cardEl.textContent = deckName.toUpperCase();
  document.body.appendChild(cardEl);

  // start at deckScreen, animate to center of window
  cardEl.style.left = `${deckScreen.x - 80}px`;
  cardEl.style.top = `${deckScreen.y - 50}px`;

  const targetX = window.innerWidth/2 - 190/2; // target left for modal alignment (approx)
  const targetY = window.innerHeight/2 - 80;

  // simple tween
  const frames = 18;
  let f = 0;
  const start = { x: deckScreen.x - 80, y: deckScreen.y - 50 };
  const dx = (targetX - start.x) / frames;
  const dy = (targetY - start.y) / frames;

  const anim = setInterval(()=>{
    f++;
    cardEl.style.left = `${start.x + dx * f}px`;
    cardEl.style.top = `${start.y + dy * f}px`;
    if(f >= frames){
      clearInterval(anim);
      // reveal card content from deck
      setTimeout(()=>{
        // remove floating and show modal with actual card
        cardEl.remove();
        revealCard(deckName, player);
      }, 120);
    }
  }, 22);
}

/* reveal card: pop modal with card text and execute action when closed */
function revealCard(deckName, player){
  let deck = deckName === "suerte" ? suerteDeck : arcaDeck;
  if(deck.length === 0){ createDecks(); deck = deckName==="suerte"?suerteDeck:arcaDeck; }
  const card = deck.shift();
  cardTextEl.textContent = card.text;
  cardModal.style.display = "flex";
  // when closing, execute card action, redraw board and continue turn progression
  function closeHandler(){
    cardModal.style.display = "none";
    closeCardBtn.removeEventListener('click', closeHandler);
    // execute action
    card.action(player);
    updateHUD(); drawBoard();
    // continue (small pause)
    setTimeout(()=> nextTurn(), 700);
  }
  closeCardBtn.addEventListener('click', closeHandler);
}

/* ============== DICE ANIMATION ============== */
function randDice(){ return Math.floor(Math.random()*6) + 1; }

function drawDicePreview(d1,d2){
  const sizeDie = 44;
  const margin = 10;
  const x1 = SIZE - sizeDie*2 - margin - 6;
  const y1 = SIZE - sizeDie - margin - 6;

  // background
  ctx.fillStyle = "rgba(0,0,0,0.06)";
  ctx.fillRect(x1-8,y1-8,sizeDie*2+18,sizeDie+16);

  // die 1
  ctx.fillStyle = "#fff";
  ctx.fillRect(x1,y1,sizeDie,sizeDie);
  ctx.strokeStyle = "#333";
  ctx.strokeRect(x1,y1,sizeDie,sizeDie);
  drawPips(x1,y1,sizeDie,d1);

  // die 2
  const x2 = x1 + sizeDie + 10;
  ctx.fillStyle = "#fff";
  ctx.fillRect(x2,y1,sizeDie,sizeDie);
  ctx.strokeRect(x2,y1,sizeDie,sizeDie);
  drawPips(x2,y1,sizeDie,d2);
}
function drawPips(x,y,w,num){
  ctx.fillStyle = "#000";
  const r = 4;
  const cx = x + w/2, cy = y + w/2;
  const offset = 12;
  const left = cx - offset, right = cx + offset, top = cy - offset, bottom = cy + offset;
  const draw = (px,py)=> { ctx.beginPath(); ctx.arc(px,py,r,0,Math.PI*2); ctx.fill(); };
  if(num===1) draw(cx,cy);
  if(num===2){ draw(left,top); draw(right,bottom); }
  if(num===3){ draw(left,top); draw(cx,cy); draw(right,bottom); }
  if(num===4){ draw(left,top); draw(right,top); draw(left,bottom); draw(right,bottom); }
  if(num===5){ draw(left,top); draw(right,top); draw(cx,cy); draw(left,bottom); draw(right,bottom); }
  if(num===6){ draw(left,top); draw(right,top); draw(left,cy); draw(right,cy); draw(left,bottom); draw(right,bottom); }
}

function rollDiceAnimated(callback){
  if(diceRolling) return;
  diceRolling = true;
  let frames = 12; let f = 0;
  const interval = 70;
  const anim = setInterval(()=>{
    diceResult = [randDice(), randDice()];
    drawBoard(); drawDicePreview(diceResult[0], diceResult[1]);
    f++;
    if(f >= frames){
      clearInterval(anim);
      diceRolling = false;
      drawBoard(); drawDicePreview(diceResult[0], diceResult[1]);
      setTimeout(()=> callback(diceResult[0], diceResult[1]), 180);
    }
  }, interval);
}

/* ============== JAIL / TURN EVENTS ============== */
function rollForJail(pl){
  rollDiceAnimated((d1,d2)=>{
    showMsg(`${pl.name} intenta sacar dobles: ${d1}, ${d2}`);
    if(d1===d2){
      pl.inJail = false; pl.jailTurns = 0;
      showMsg(`${pl.name} sac√≥ dobles y sale de la c√°rcel`);
      animateMove(pl, d1 + d2);
    } else {
      pl.jailTurns++;
      showMsg(`${pl.name} no saca dobles (${pl.jailTurns}/3)`);
      if(pl.jailTurns >= 3){
        pl.money -= 50; pl.inJail = false; pl.jailTurns = 0;
        showMsg(`${pl.name} paga $50 tras 3 intentos y sale`);
        animateMove(pl, d1 + d2);
      } else {
        setTimeout(()=> nextTurn(), 700);
      }
    }
  });
}

/* pay or use card */
payJailBtn.addEventListener('click', ()=>{
  const pl = players[current];
  if(pl.inJail){ pl.money -= 50; pl.inJail = false; pl.jailTurns = 0; showMsg(`${pl.name} paga $50 y sale`); drawBoard(); updateHUD(); }
});
useCardBtn.addEventListener('click', ()=>{
  const pl = players[current];
  if(pl.hasGetOutCard){ pl.hasGetOutCard = false; pl.inJail = false; pl.jailTurns = 0; showMsg(`${pl.name} usa 'Salir de la c√°rcel'`); drawBoard(); updateHUD(); }
});

/* roll button main logic */
rollBtn.addEventListener('click', ()=>{
  const pl = players[current];
  if(animating || diceRolling) return;
  // if in jail -> attempt doubles
  if(pl.inJail){
    rollForJail(pl);
    return;
  }
  rollDiceAnimated((d1,d2)=>{
    const sum = d1 + d2;
    showMsg(`${pl.name} tira ${d1} + ${d2} = ${sum}`);
    // handle double turn
    lastRollWasDouble = (d1 === d2);
    animateMove(pl, sum);
  });
});

/* override handleLanding to manage doubles and extra turns: reuse existing function but check lastRollWasDouble */
const originalHandleLandingFunc = handleLanding; // not defined yet in hoisting; ensure reference below

/* We'll re-implement handleLanding with doubles logic (to avoid hoisting issues) */
/* (function defined above as function handleLanding... but to be safe we define wrapper) */

/* ============== AI Simple ============== */
function aiTakeTurn(ai){
  if(ai.inJail){
    // prefer using card or paying if affordable
    if(ai.hasGetOutCard){ ai.hasGetOutCard = false; ai.inJail = false; ai.jailTurns = 0; showMsg("IA usa 'Salir de la c√°rcel'"); setTimeout(()=> animateMove(ai, randDice()+randDice()), 500); return; }
    if(ai.money > 120){ ai.money -= 50; ai.inJail = false; ai.jailTurns = 0; showMsg("IA paga $50 y sale"); setTimeout(()=> animateMove(ai, randDice()+randDice()), 500); return; }
    // else attempt roll doubles
    rollForJail(ai);
    return;
  }
  rollDiceAnimated((d1,d2)=>{
    const sum = d1+d2;
    showMsg(`IA tira ${d1} + ${d2} = ${sum}`);
    lastRollWasDouble = (d1===d2);
    setTimeout(()=> animateMove(ai, sum), 220);
  });
}

/* ============== STARTUP ============== */
function handleLandingWithDoubles(pl){
  // reuse existing landing logic (we implemented earlier as handleLanding)
  // We call the previously defined handleLanding (the one above) but ensure extra-turn semantics governed by lastRollWasDouble
  // The previously defined handleLanding already calls nextTurn(); so we need to intercept that behavior:
  // We'll copy the same logic inline here to ensure double-handling.
  const cell = board[pl.pos];
  if(cell.type === "propiedad" || cell.type === "estacion" || cell.type === "compa√±ia"){
    if(!cell.owner){
      if(pl.name === "Jugador"){
        const ok = confirm(`¬øComprar ${cell.name} por $${cell.price}?`);
        if(ok){ pl.money -= cell.price; cell.owner = pl.name; pl.properties.push(cell); showMsg(`${pl.name} compra ${cell.name}`); }
        else showMsg(`${pl.name} no compra ${cell.name}`);
      } else {
        if(pl.money > cell.price + 200){ pl.money -= cell.price; cell.owner = pl.name; pl.properties.push(cell); showMsg(`IA compra ${cell.name}`); }
        else showMsg(`IA no compra ${cell.name}`);
      }
    } else if(cell.owner !== pl.name){
      const owner = players.find(p=>p.name === cell.owner);
      const rent = Math.floor(cell.price/2);
      pl.money -= rent; owner.money += rent;
      showMsg(`${pl.name} paga $${rent} a ${owner.name}`);
    } else showMsg(`${pl.name} cae en su propia propiedad`);
    drawBoard(); updateHUD();
    // check doubles
    if(lastRollWasDouble && !pl.inJail){
      lastRollWasDouble = false;
      showMsg(`${pl.name} sac√≥ dobles y obtiene turno extra`);
      // same player goes again (do not call nextTurn)
      setTimeout(()=> { updateHUD(); drawBoard(); }, 700);
      return;
    }
    setTimeout(()=> nextTurn(), 800);
  } else if(cell.type === "impuesto"){
    pl.money -= 100; showMsg(`${pl.name} paga impuesto $100`);
    drawBoard(); updateHUD();
    if(lastRollWasDouble && !pl.inJail){ lastRollWasDouble = false; showMsg(`${pl.name} sac√≥ dobles y obtiene turno extra`); setTimeout(()=> { updateHUD(); drawBoard(); }, 700); return; }
    setTimeout(()=> nextTurn(), 800);
  } else if(cell.type === "suerte"){
    animateTakeCard("suerte", pl);
    // card animation will call nextTurn after reveal
  } else if(cell.type === "arca"){
    animateTakeCard("arca", pl);
  } else if(cell.name === "Ve a la c√°rcel"){
    pl.pos = 10; pl.inJail = true; pl.jailTurns = 0; showMsg(`${pl.name} va directo a la c√°rcel`);
    drawBoard(); updateHUD();
    setTimeout(()=> nextTurn(), 800);
  } else if(cell.name === "C√°rcel"){
    showMsg(`${pl.name} est√° en la casilla de C√°rcel`);
    if(lastRollWasDouble && !pl.inJail){ lastRollWasDouble = false; showMsg(`${pl.name} sac√≥ dobles y obtiene turno extra`); setTimeout(()=> { updateHUD(); drawBoard(); }, 700); return; }
    setTimeout(()=> nextTurn(), 800);
  } else {
    showMsg(`${pl.name} cae en ${cell.name}`);
    if(lastRollWasDouble && !pl.inJail){ lastRollWasDouble = false; showMsg(`${pl.name} sac√≥ dobles y obtiene turno extra`); setTimeout(()=> { updateHUD(); drawBoard(); }, 700); return; }
    setTimeout(()=> nextTurn(), 800);
  }
}

/* replace previous handleLanding used by animateMove to use this doubles-aware function */
function handleLanding(pl){ handleLandingWithDoubles(pl); }

/* create decks and initialize */
createDecks();
drawBoard();
updateHUD();
showMsg("Juego listo en 700x700. Pulsa 'Tirar dados'.");

setInterval(()=>{ if(!diceRolling) drawBoard(); }, 700);

</script>
</body>
</html>
