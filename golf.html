<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Pac-Man ‚Äî Mejorado (IA + F√≠sica)</title>
<style>
  :root{--bg:#000;--wall:#001f6f;--pellet:#ffd54d}
  body{margin:0;background:var(--bg);color:#fff;font-family:Arial,system-ui;overflow:hidden}
  #menu,#playScreen,#gameArea{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column}
  #menu{background:radial-gradient(circle at center,#111,#000)}
  .card{background:#222;padding:18px;border-radius:10px;margin:8px;width:220px;text-align:center;cursor:pointer}
  .card:hover{transform:scale(1.03);background:#333}
  #playScreen{display:none;background:rgba(0,0,0,.85)}
  #gameArea{display:none}
  button{padding:10px 16px;border-radius:8px;border:0;background:#0af;color:#001;font-weight:700;cursor:pointer}
  #scoreBoard{position:fixed;left:12px;top:12px;background:rgba(0,0,0,.45);padding:6px 10px;border-radius:6px}
  canvas{image-rendering:pixelated;border-radius:8px;box-shadow:0 8px 20px rgba(0,0,0,.6)}
</style>
</head>
<body>

<div id="menu">
  <h1>üéÆ Zona de Juegos</h1>
  <div class="card" onclick="loadGame('pacman')">Pac-Man</div>
</div>

<div id="playScreen">
  <h2 id="gameTitle">Pac-Man</h2>
  <div style="display:flex;gap:12px">
    <button id="btnPlay">Play</button>
    <button id="btnBackFromPlay">Volver</button>
  </div>
</div>

<div id="gameArea">
  <div id="scoreBoard">Puntuaci√≥n: 0 | Vidas: 3</div>
  <div id="gameContainer"></div>
  <button id="btnBack" style="position:fixed;right:12px;bottom:12px">Volver al men√∫</button>
</div>

<script>
/* ---------------- Pac-Man: JS corregido y completo ----------------
   - Reemplaza el <script> anterior por este
   - El initPacman(container) devuelve una funci√≥n stop() que detiene el bucle
------------------------------------------------------------------ */

(function(){

// ---------------- Config / Mapa ----------------
const RAW_MAP = [
"############################",
"#............##............#",
"#.####.#####.##.#####.####.#",
"#o####.#####.##.#####.####o#",
"#.####.#####.##.#####.####.#",
"#..........................#",
"#.####.##.########.##.####.#",
"#.####.##.########.##.####.#",
"#......##....##....##......#",
"######.##### ## #####.######",
"######.##### ## #####.######",
"######.##          ##.######",
"######.## ###--### ##.######",
"######.## #      # ##.######",
"       .  #      #  .       ",
"######.## #      # ##.######",
"######.## ######## ##.######",
"######.##          ##.######",
"######.## ######## ##.######",
"######.## ######## ##.######",
"#............##............#",
"#.####.#####.##.#####.####.#",
"#o####.#####.##.#####.####o#",
"#...##................##...#",
"###.##.##.########.##.##.###",
"###.##.##.########.##.##.###",
"#......##....##....##......#",
"#.##########.##.##########.#",
"#.##########.##.##########.#",
"#..........................#",
"############################"
];

const TILE = 16;
const COLS = RAW_MAP[0].length;
const ROWS = RAW_MAP.length;

// ---------------- Utilidades ----------------
function cloneMap(raw){
  return raw.map(r=>r.split(''));
}
function inside(x,y){ return x>=0 && x<COLS && y>=0 && y<ROWS; }
function isWall(map, tx,ty){ if(!inside(tx,ty)) return true; return map[ty][tx] === '#'; }
function tileCenterX(tx){ return tx*TILE + TILE/2; }
function tileCenterY(ty){ return ty*TILE + TILE/2; }
function distanceSq(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

// BFS shortest path on tile grid, returns first step {x,y} tile or null
function bfsFirstStep(map, startTile, goalTile){
  if(startTile.x===goalTile.x && startTile.y===goalTile.y) return null;
  const q = [];
  const prev = Array.from({length:ROWS},()=>Array(COLS).fill(null));
  q.push(startTile);
  prev[startTile.y][startTile.x] = {x:-1,y:-1};
  const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
  while(q.length){
    const cur = q.shift();
    if(cur.x===goalTile.x && cur.y===goalTile.y) break;
    for(const d of dirs){
      const nx = cur.x + d.x, ny = cur.y + d.y;
      if(!inside(nx,ny)) continue;
      if(prev[ny][nx]) continue;
      if(isWall(map,nx,ny)) continue;
      prev[ny][nx] = cur;
      q.push({x:nx,y:ny});
    }
  }
  if(!prev[goalTile.y][goalTile.x]) return null;
  // retroceder hasta el primer paso
  let cur = {x:goalTile.x,y:goalTile.y};
  while(true){
    const p = prev[cur.y][cur.x];
    if(p.x===-1 && p.y===-1) return null; // goal == start
    if(p.x===startTile.x && p.y===startTile.y) return cur;
    cur = p;
  }
}

// ---------------- Game state / inicializaci√≥n ----------------
function initPacman(container){
  const map = cloneMap(RAW_MAP); // matriz mutable
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = COLS * TILE;
  canvas.height = ROWS * TILE;
  canvas.style.width = (canvas.width * 1.15) + 'px';
  canvas.style.height = (canvas.height * 1.15) + 'px';
  canvas.id = 'pacmanCanvas';
  container.appendChild(canvas);

  // Estados del juego
  let score = 0;
  let lives = 3;
  let running = true;

  // Pac-Man (pos en px)
  const pac = {
    x: tileCenterX(13),
    y: tileCenterY(23), // posici√≥n de inicio parecido al original
    dir: {x:0,y:0},     // direcci√≥n actual (unit tile dir)
    nextDir: {x:0,y:0},
    speed: 1.6,         // pixels por frame (ajustable)
    radius: 6,
    mouth: 0            // animaci√≥n boca
  };

  // Ghosts - estado por fantasma
  const ghosts = [
    {name:'blinky', color:'#ff0000',  tx:13, ty:11, x:tileCenterX(13), y:tileCenterY(11), mode:'scatter', state:'normal', speed:1.4, scatterTarget:{x:25,y:0}},
    {name:'pinky',  color:'#ffb8ff',  tx:14, ty:11, x:tileCenterX(14), y:tileCenterY(11), mode:'scatter', state:'normal', speed:1.3, scatterTarget:{x:2,y:0}},
    {name:'inky',   color:'#00ffff',  tx:12, ty:11, x:tileCenterX(12), y:tileCenterY(11), mode:'scatter', state:'normal', speed:1.3, scatterTarget:{x:27,y:35}},
    {name:'clyde',  color:'#ffb852',  tx:15, ty:11, x:tileCenterX(15), y:tileCenterY(11), mode:'scatter', state:'normal', speed:1.2, scatterTarget:{x:0,y:35}}
  ];

  // modos: cycle timers (simplificado)
  const MODE_SCHEDULE = [
    {mode:'scatter', time:7000},
    {mode:'chase',   time:20000},
    {mode:'scatter', time:7000},
    {mode:'chase',   time:20000},
    {mode:'scatter', time:5000},
    {mode:'chase',   time:20000}
  ];
  let modeIndex = 0;
  let modeTimer = MODE_SCHEDULE[0].time;
  function setGlobalMode(m){ ghosts.forEach(g=>{ if(g.state==='normal') g.mode = m; }); }

  // Power pellet
  let powerMode = false;
  let powerTimer = 0;

  // Scoreboard UI (usa el elemento que ya tienes si existe)
  const scoreBoardEl = document.getElementById('scoreBoard');
  function updateScoreBoard(){ if(scoreBoardEl) scoreBoardEl.innerText = `Puntuaci√≥n: ${score} | Vidas: ${lives}`; }

  // Input
  const keyMap = {'ArrowUp': {x:0,y:-1}, 'ArrowDown': {x:0,y:1}, 'ArrowLeft': {x:-1,y:0}, 'ArrowRight': {x:1,y:0}};
  document.addEventListener('keydown', onKey);
  function onKey(e){
    const k = keyMap[e.key];
    if(k){
      pac.nextDir = {...k};
      e.preventDefault();
    }
  }

  // ---------------- Logica de movimiento ----------------
  function tileFromPx(x,y){ return {x: Math.floor(x/TILE), y: Math.floor(y/TILE)}; }

  function canMoveToTile(map, tx,ty){
    if(!inside(tx,ty)) return false;
    return !isWall(map,tx,ty);
  }

  function tryApplyNextDir(){
    // solo cambiar si la tile en la direcci√≥n solicitada desde la posici√≥n actual es libre
    const center = {x: pac.x, y: pac.y};
    const nextTile = {
      x: Math.floor((center.x + pac.nextDir.x * (TILE/2)) / TILE),
      y: Math.floor((center.y + pac.nextDir.y * (TILE/2)) / TILE)
    };
    if(canMoveToTile(map,nextTile.x,nextTile.y)){
      pac.dir = {...pac.nextDir};
    }
  }

  function movePac(){
    tryApplyNextDir();
    // avance
    pac.x += pac.dir.x * pac.speed;
    pac.y += pac.dir.y * pac.speed;
    // t√∫neles laterales (wrap)
    if(pac.x < -pac.radius) pac.x = canvas.width + pac.radius;
    if(pac.x > canvas.width + pac.radius) pac.x = -pac.radius;
    // Adjust position if hits wall: basic correction to not enter walls
    const t = tileFromPx(pac.x,pac.y);
    if(isWall(map, t.x, t.y)){
      // retroceder
      pac.x -= pac.dir.x * pac.speed;
      pac.y -= pac.dir.y * pac.speed;
      pac.dir = {x:0,y:0};
    }
  }

  // ---------------- Pellets ----------------
  // '.' pellet, 'o' power pellet, ' ' empty, '#' wall, '-' puertas
  function checkPelletConsumption(){
    const t = tileFromPx(pac.x,pac.y);
    const c = map[t.y][t.x];
    if(c === '.' ){
      map[t.y][t.x] = ' ';
      score += 10;
    } else if(c === 'o'){
      map[t.y][t.x] = ' ';
      score += 50;
      powerMode = true;
      powerTimer = 600; // frames approx (ajustable)
      ghosts.forEach(g=>{
        if(g.state === 'normal') g.state = 'frightened';
      });
    }
  }

  // ---------------- Ghost AI & movimiento ----------------
  function getTileCenter(tile){ return {x: tileCenterX(tile.x), y: tileCenterY(tile.y)}; }

  function ghostTargetTile(ghost){
    // depending on mode/state return tile coord target
    if(ghost.state === 'eyes'){ // return to home (13,11)
      return {x:13, y:11};
    }
    if(ghost.state === 'frightened'){
      // random target in accessible area (choose random adjacent tile)
      // We'll return a random reachable tile near center
      return {x: Math.max(1, Math.floor(Math.random() * (COLS-2))), y: Math.max(1, Math.floor(Math.random() * (ROWS-2)))};
    }
    if(ghost.mode === 'scatter'){
      return ghost.scatterTarget;
    }
    // chase mode - individual behaviours
    const pacTile = tileFromPx(pac.x,pac.y);
    switch(ghost.name){
      case 'blinky':
        return pacTile;
      case 'pinky':
        // 4 tiles ahead of pac in direction pac.dir
        return {x: pacTile.x + (pac.dir.x * 4), y: pacTile.y + (pac.dir.y * 4)};
      case 'inky':
        // dbl vector from Blinky to a point two tiles ahead of Pac
        const blinky = ghosts.find(g=>g.name==='blinky');
        const blinkyTile = tileFromPx(blinky.x, blinky.y);
        const ahead = {x: pacTile.x + pac.dir.x * 2, y: pacTile.y + pac.dir.y * 2};
        return {x: ahead.x + (ahead.x - blinkyTile.x), y: ahead.y + (ahead.y - blinkyTile.y)};
      case 'clyde':
        // if distance > 8 tiles chase, else scatter (target corner)
        const gx = Math.floor(ghost.x / TILE), gy = Math.floor(ghost.y / TILE);
        const d2 = (pacTile.x - gx)*(pacTile.x - gx) + (pacTile.y - gy)*(pacTile.y - gy);
        if(d2 > (8*8)) return pacTile;
        return ghost.scatterTarget;
      default:
        return pacTile;
    }
  }

  // calculate movement for each ghost (tile-based pathfinding for first step)
  function moveGhosts(){
    for(const g of ghosts){
      // handle tunnel wrap
      if(g.x < -TILE) g.x = canvas.width + TILE;
      if(g.x > canvas.width + TILE) g.x = -TILE;

      // If eyes state and at home tile, return to normal
      const gTile = tileFromPx(g.x,g.y);
      if(g.state === 'eyes' && gTile.x===13 && gTile.y===11){
        g.state = 'normal';
        g.mode = 'scatter';
        // place exactly
        g.x = tileCenterX(13); g.y = tileCenterY(11);
      }

      // decide target tile
      let targetTile = ghostTargetTile(g);
      // clamp target inside map
      targetTile.x = Math.max(0, Math.min(COLS-1, Math.round(targetTile.x)));
      targetTile.y = Math.max(0, Math.min(ROWS-1, Math.round(targetTile.y)));

      const startTile = tileFromPx(g.x, g.y);
      // if ghost is between tiles, prefer not to query weirdness: if near center continue same direction
      // compute BFS first step to target
      const first = bfsFirstStep(map, startTile, targetTile);
      if(first){
        // desired center pixel of that tile
        const cx = tileCenterX(first.x), cy = tileCenterY(first.y);
        // compute unit vector to that center
        const dx = cx - g.x, dy = cy - g.y;
        const len = Math.sqrt(dx*dx + dy*dy) || 1;
        let speed = g.speed;
        if(g.state === 'frightened') speed *= 0.9;
        if(g.state === 'eyes') speed *= 1.6;
        g.x += (dx/len) * speed;
        g.y += (dy/len) * speed;
      } else {
        // if no path found (rare), do a small random walk
        if(!g._randDir || Math.random()<0.02) {
          const possible = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}].filter(d=>!isWall(map, startTile.x + d.x, startTile.y + d.y));
          g._randDir = possible[Math.floor(Math.random()*possible.length)] || {x:0,y:0};
        }
        g.x += (g._randDir.x || 0) * g.speed;
        g.y += (g._randDir.y || 0) * g.speed;
      }
    }
  }

  // ---------------- Colisiones Pac <-> Ghosts ----------------
  function checkCollisions(){
    for(const g of ghosts){
      const d2 = distanceSq({x:pac.x,y:pac.y},{x:g.x,y:g.y});
      const rad = (pac.radius + pac.radius) * 0.8;
      if(d2 < rad*rad){
        if(powerMode && g.state === 'frightened'){
          // comer fantasma -> pasar a estado 'eyes' (solo ojos) y mandar a casa
          score += 100;
          g.state = 'eyes';
          // colocar en "casa" (eyes) y dirigir a casa tile center
          // posici√≥n se mantiene, movement code en moveGhosts har√° return to home
        } else if(!powerMode && g.state !== 'eyes'){
          // pac muere
          lives--;
          if(lives <= 0){
            // game over
            running = false;
            updateScoreBoard();
            setTimeout(()=>{ alert("GAME OVER ‚Äî Puntuaci√≥n: "+score); location.reload(); }, 10);
            return;
          } else {
            // reset posiciones a inicio
            resetPositions();
            return;
          }
        }
      }
    }
  }

  // ---------------- Reset & Utils ----------------
  function resetPositions(){
    pac.x = tileCenterX(13); pac.y = tileCenterY(23);
    pac.dir = {x:0,y:0}; pac.nextDir = {x:0,y:0};
    ghosts.forEach((g,i)=>{
      g.x = tileCenterX(13 + i);
      g.y = tileCenterY(11);
      g.state = 'normal'; g.mode = 'scatter';
    });
    modeIndex = 0; modeTimer = MODE_SCHEDULE[0].time;
  }

  // ---------------- Dibujo ----------------
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // fondo
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // dibujar mapa: paredes y pellets
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const c = map[y][x];
        const px = x * TILE, py = y * TILE;
        if(c === '#'){
          // pared (simple rect para rendimiento)
          ctx.fillStyle = '#001f6f';
          ctx.fillRect(px,py,TILE,TILE);
        } else if(c === '.'){
          ctx.fillStyle = '#ffd54d';
          ctx.beginPath();
          ctx.arc(px + TILE/2, py + TILE/2, 2, 0, Math.PI*2);
          ctx.fill();
        } else if(c === 'o'){
          ctx.fillStyle = '#ffd54d';
          ctx.beginPath();
          ctx.arc(px + TILE/2, py + TILE/2, 5, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    // Pac-Man (con boca animada)
    const mouthAngle = 0.25 + 0.25 * Math.sin(pac.mouth);
    ctx.fillStyle = '#ffea00';
    const dirAngle = Math.atan2(pac.dir.y, pac.dir.x) || 0;
    // si sin direccion, animar abierta hacia derecha por defecto
    let a1 = -mouthAngle + dirAngle;
    let a2 = mouthAngle + dirAngle;
    // si pac.dir es 0,0 mostrar circular (sin boca)
    if(pac.dir.x===0 && pac.dir.y===0){
      ctx.beginPath();
      ctx.arc(pac.x, pac.y, pac.radius, 0, Math.PI*2);
      ctx.fill();
    } else {
      ctx.beginPath();
      ctx.moveTo(pac.x, pac.y);
      ctx.arc(pac.x, pac.y, pac.radius, a1, a2, false);
      ctx.closePath();
      ctx.fill();
    }
    pac.mouth += 0.3;

    // Ghosts
    for(const g of ghosts){
      // cuerpo simple c√≠rculo + "fondo ojos" cuando eyes/frightened
      if(g.state === 'frightened'){
        ctx.fillStyle = '#0000cc';
      } else if(g.state === 'eyes'){
        ctx.fillStyle = '#ffffff';
      } else {
        ctx.fillStyle = g.color;
      }
      ctx.beginPath();
      ctx.arc(g.x, g.y, pac.radius, Math.PI, 0, false);
      ctx.lineTo(g.x + pac.radius, g.y + pac.radius);
      ctx.lineTo(g.x - pac.radius, g.y + pac.radius);
      ctx.closePath();
      ctx.fill();

      // ojos / pupilas
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.ellipse(g.x - 4, g.y - 2, 3, 4, 0, 0, Math.PI*2);
      ctx.ellipse(g.x + 4, g.y - 2, 3, 4, 0, 0, Math.PI*2);
      ctx.fill();

      // pupilas (mirando a pac)
      const lookDx = pac.x - g.x, lookDy = pac.y - g.y;
      const lookLen = Math.sqrt(lookDx*lookDx + lookDy*lookDy) || 1;
      const pdx = (lookDx / lookLen) * 2;
      const pdy = (lookDy / lookLen) * 2;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(g.x - 4 + pdx, g.y - 2 + pdy, 1.5, 0, Math.PI*2);
      ctx.arc(g.x + 4 + pdx, g.y - 2 + pdy, 1.5, 0, Math.PI*2);
      ctx.fill();
    }

    updateScoreBoard();
  }

  // ---------------- Game loop ----------------
  function update(){
    if(!running) return;
    // modos globales (scatter/chase) por timer
    modeTimer--;
    if(modeTimer <= 0){
      modeIndex = (modeIndex + 1) % MODE_SCHEDULE.length;
      const next = MODE_SCHEDULE[modeIndex];
      modeTimer = next.time;
      setGlobalMode(next.mode);
    }

    // power mode timer
    if(powerMode){
      powerTimer--;
      if(powerTimer <= 0){
        powerMode = false;
        ghosts.forEach(g=>{ if(g.state === 'frightened') g.state = 'normal'; });
      }
    }

    movePac();
    checkPelletConsumption();
    moveGhosts();
    checkCollisions();
    draw();

    if(running) rafId = requestAnimationFrame(update);
  }

  let rafId = requestAnimationFrame(update);

  // stop function to detach events and stop loop
  function stop(){
    running = false;
    if(rafId) cancelAnimationFrame(rafId);
    document.removeEventListener('keydown', onKey);
    // limpiar canvas si quieres
    // container.removeChild(canvas);
  }

  // iniciar estado
  resetPositions();
  updateScoreBoard();

  // devolver control para parar desde UI
  return { stop };
}

// ---------------- Integraci√≥n con tu UI existente ----------------
// Tu c√≥digo anterior esperaba initPacman(document.getElementById('gameContainer')) 
// que devuelva una funci√≥n stopGame(). Para compatibilidad, exponemos globalmente:
window.initPacman = function(container){
  const inst = initPacman(container);
  // wrapper que devuelve stop como funci√≥n simple
  return function(){ inst.stop(); };
};

})(); // IIFE fin
</script>
</body>
</html>
