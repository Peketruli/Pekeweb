<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pac-Man â€” FÃ­sica mejorada</title>
<style>
  body{margin:0;background:#000;color:#fff;font-family:Arial;overflow:hidden}
  #menu,#playScreen,#gameArea{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column}
  #menu{background:radial-gradient(circle at center,#111,#000)}
  .card{background:#222;padding:18px;border-radius:10px;margin:8px;width:220px;text-align:center;cursor:pointer}
  .card:hover{transform:scale(1.03)}
  #playScreen{display:none;background:rgba(0,0,0,0.85)}
  #gameArea{display:none}
  button{padding:10px 18px;border-radius:8px;border:0;background:#0af;color:#001;cursor:pointer}
  #scoreBoard{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.5);padding:6px 10px;border-radius:6px}
  canvas{image-rendering:pixelated;border-radius:6px}
</style>
</head>
<body>

<div id="menu">
  <h1>ðŸŽ® Zona de Juegos</h1>
  <div class="card" onclick="loadGame('pacman')">Pac-Man (mejorado)</div>
  <div class="card" onclick="loadGame('buscaminas')">Buscaminas</div>
  <div class="card" onclick="loadGame('solitario')">Solitario</div>
  <div class="card" onclick="loadGame('flota')">Hundir la Flota</div>
</div>

<div id="playScreen">
  <h2 id="gameTitle">Pac-Man</h2>
  <div style="display:flex;gap:12px">
    <button onclick="startGame()">PLAY</button>
    <button onclick="backToMenu()">Volver</button>
  </div>
</div>

<div id="gameArea">
  <div id="scoreBoard">PuntuaciÃ³n: 0</div>
  <div id="gameContainer"></div>
  <button style="position:fixed;right:12px;bottom:12px" onclick="backToMenu()">Volver al menÃº</button>
</div>

<script>
/* -------------------------
   Vista / navegaciÃ³n bÃ¡sica
   ------------------------- */
let currentGame = null;
function loadGame(name){
  currentGame = name;
  document.getElementById('menu').style.display='none';
  document.getElementById('playScreen').style.display='flex';
  document.getElementById('gameTitle').innerText = (name==='pacman') ? 'Pac-Man' : name;
}
function startGame(){
  document.getElementById('playScreen').style.display='none';
  document.getElementById('gameArea').style.display='flex';
  document.getElementById('gameContainer').innerHTML='';
  document.getElementById('scoreBoard').innerText = 'PuntuaciÃ³n: 0';
  if(currentGame==='pacman') initPacmanImproved(document.getElementById('gameContainer'));
}
function backToMenu(){
  // stop any running loops by emptying container (games should clean themselves on unload)
  document.getElementById('menu').style.display='flex';
  document.getElementById('playScreen').style.display='none';
  document.getElementById('gameArea').style.display='none';
  document.getElementById('gameContainer').innerHTML='';
}

/* ------------------------------------
   Pac-Man â€” versiÃ³n con fÃ­sica mejorada
   ------------------------------------ */
function initPacmanImproved(container){
  // parameters
  const TILE = 16;                     // px per cell
  const COLS = 28, ROWS = 31;
  const CANVAS_W = COLS * TILE;
  const CANVAS_H = ROWS * TILE;
  const SPEED = 1.6;                   // pixels per frame (constant)
  const FRAME_MS = 1000/60;

  // create canvas
  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_W; canvas.height = CANVAS_H;
  canvas.style.width = (CANVAS_W*1.2)+'px'; // scale for visibility
  canvas.style.height = (CANVAS_H*1.2)+'px';
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // simplified map (28 x 31) - '#' wall, '.' pellet, 'o' power, ' ' empty, 'P' start
  const raw = [
"############################",
"#............##............#",
"#.####.#####.##.#####.####.#",
"#o####.#####.##.#####.####o#",
"#.####.#####.##.#####.####.#",
"#..........................#",
"#.####.##.########.##.####.#",
"#.####.##.########.##.####.#",
"#......##....##....##......#",
"######.##### ## #####.######",
"######.##### ## #####.######",
"######.##          ##.######",
"######.## ###--### ##.######",
"######.## #      # ##.######",
"       .  #      #  .       ",
"######.## #      # ##.######",
"######.## ######## ##.######",
"######.##          ##.######",
"######.## ######## ##.######",
"######.## ######## ##.######",
"#............##............#",
"#.####.#####.##.#####.####.#",
"#o####.#####.##.#####.####o#",
"#...##................##...#",
"###.##.##.########.##.##.###",
"###.##.##.########.##.##.###",
"#......##....##....##......#",
"#.##########.##.##########.#",
"#.##########.##.##########.#",
"#..........................#",
"############################"
  ];

  // normalize map to array of arrays
  const map = raw.map(r => r.split(''));

  // initial pac state (grid-based but pixel pos used for drawing)
  const pac = {
    px: 13 * TILE + TILE/2,   // pixel pos
    py: 23 * TILE + TILE/2,
    dir: {x:0,y:0},           // current movement direction (unit vector in grid terms)
    nextDir: {x:0,y:0},       // buffered desired direction
    speed: SPEED,
    radius: TILE/2 - 1
  };

  // helper: is a map cell walkable?
  function isWalkable(cellX, cellY){
    if(cellY < 0 || cellY >= ROWS || cellX < 0 || cellX >= COLS) return false;
    const ch = map[cellY][cellX];
    return ch !== '#';
  }

  // helper: cell center coordinates (pixels)
  function cellCenterX(cx){ return cx * TILE + TILE/2; }
  function cellCenterY(cy){ return cy * TILE + TILE/2; }

  // keyboard input buffering
  window.addEventListener('keydown', onKeyDown);
  function onKeyDown(e){
    let nx = 0, ny = 0;
    if(e.key === 'ArrowUp' || e.key === 'w') { nx = 0; ny = -1; }
    if(e.key === 'ArrowDown' || e.key === 's') { nx = 0; ny = 1; }
    if(e.key === 'ArrowLeft' || e.key === 'a') { nx = -1; ny = 0; }
    if(e.key === 'ArrowRight' || e.key === 'd') { nx = 1; ny = 0; }
    if(nx!==0 || ny!==0){
      // buffer desired direction; it will be applied when aligned or possible
      pac.nextDir.x = nx; pac.nextDir.y = ny;
      e.preventDefault();
    }
    if(e.key === 'r'){ // restart map
      reset();
    }
  }

  // pellet/power handling
  let score = 0;
  function eatAtCell(cx,cy){
    const ch = map[cy][cx];
    if(ch === '.' ){ map[cy][cx] = ' '; score += 10; updateScore(); }
    if(ch === 'o' ){ map[cy][cx] = ' '; score += 50; updateScore(); /* could trigger power mode */ }
  }
  function updateScore(){ document.getElementById('scoreBoard').innerText = 'PuntuaciÃ³n: ' + score; }

  // movement helper: returns true if pac is approximately at cell center
  function isAlignedToGrid(){
    const cx = (pac.px - TILE/2) / TILE;
    const cy = (pac.py - TILE/2) / TILE;
    const ax = Math.abs(cx - Math.round(cx));
    const ay = Math.abs(cy - Math.round(cy));
    // tolerance for considering "centered" (in cell fractions)
    return ax < 0.08 && ay < 0.08;
  }

  // try to apply buffered direction when possible
  function tryApplyBufferedDir(){
    if(pac.nextDir.x === pac.dir.x && pac.nextDir.y === pac.dir.y) return;
    // only change direction if aligned (or we allow immediate if next cell not blocked and no wall ahead)
    if(isAlignedToGrid()){
      const gridX = Math.round((pac.px - TILE/2) / TILE);
      const gridY = Math.round((pac.py - TILE/2) / TILE);
      const tx = gridX + pac.nextDir.x;
      const ty = gridY + pac.nextDir.y;
      if(isWalkable(tx, ty)){
        pac.dir.x = pac.nextDir.x;
        pac.dir.y = pac.nextDir.y;
        // snap perfectly to center to avoid drift
        pac.px = cellCenterX(gridX);
        pac.py = cellCenterY(gridY);
      }
    } else {
      // not aligned â€” also allow immediate apply if current dir is zero and the next cell in desired dir is walkable
      if(pac.dir.x === 0 && pac.dir.y === 0){
        const approxGridX = Math.round((pac.px - TILE/2) / TILE);
        const approxGridY = Math.round((pac.py - TILE/2) / TILE);
        const tx = approxGridX + pac.nextDir.x;
        const ty = approxGridY + pac.nextDir.y;
        if(isWalkable(tx, ty)){
          pac.dir.x = pac.nextDir.x; pac.dir.y = pac.nextDir.y;
        }
      }
    }
  }

  // safe move with collision prevention: check ahead for walls before moving full step
  function stepMove(){
    // if there's no direction, do nothing
    if(pac.dir.x === 0 && pac.dir.y === 0) return;

    // compute intended next pixel position
    const nextPx = pac.px + pac.dir.x * pac.speed;
    const nextPy = pac.py + pac.dir.y * pac.speed;

    // compute grid cells crossed (current center grid and target cell)
    const curGridX = Math.round((pac.px - TILE/2) / TILE);
    const curGridY = Math.round((pac.py - TILE/2) / TILE);
    const nextGridX = Math.round((nextPx - TILE/2) / TILE);
    const nextGridY = Math.round((nextPy - TILE/2) / TILE);

    // if intended next grid cell is walkable, move freely
    if(isWalkable(nextGridX, nextGridY)){
      pac.px = nextPx;
      pac.py = nextPy;
      return;
    }

    // if blocked: snap to nearest center of cur grid cell and zero velocity (prevent penetration)
    pac.px = cellCenterX(curGridX);
    pac.py = cellCenterY(curGridY);
    pac.dir.x = 0; pac.dir.y = 0;
  }

  // pellet eating check should happen when at/near center to avoid misses
  function tryEatPellet(){
    if(!isAlignedToGrid()) return;
    const gx = Math.round((pac.px - TILE/2) / TILE);
    const gy = Math.round((pac.py - TILE/2) / TILE);
    if(map[gy] && map[gy][gx] && (map[gy][gx] === '.' || map[gy][gx] === 'o')){
      eatAtCell(gx, gy);
    }
  }

  // drawing
  function draw(){
    // background
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,CANVAS_W,CANVAS_H);

    // draw map: walls and pellets
    for(let r=0;r<map.length;r++){
      for(let c=0;c<map[r].length;c++){
        const ch = map[r][c];
        const x = c * TILE, y = r * TILE;
        if(ch === '#'){
          ctx.fillStyle = '#001f3f';
          ctx.fillRect(x, y, TILE, TILE);
          // small inner shade
          ctx.fillStyle = 'rgba(255,255,255,0.03)';
          ctx.fillRect(x+2, y+2, TILE-4, TILE-4);
        } else if(ch === '.' ){
          ctx.fillStyle = '#ffd54d';
          ctx.beginPath(); ctx.arc(x + TILE/2, y + TILE/2, 2.2, 0, Math.PI*2); ctx.fill();
        } else if(ch === 'o'){
          ctx.fillStyle = '#ff6b6b';
          ctx.beginPath(); ctx.arc(x + TILE/2, y + TILE/2, 5, 0, Math.PI*2); ctx.fill();
        } else {
          // optional floor rendering skipped to keep contrast
        }
      }
    }

    // draw Pac: animated mouth based on frame/time and dir
    const mouthOpen = 0.2 + 0.15 * Math.sin(performance.now() / 80);
    const cx = pac.px, cy = pac.py;
    ctx.fillStyle = '#ffeb3b';
    let startAng = 0, endAng = Math.PI*2;
    if(pac.dir.x === 1){ startAng = mouthOpen * Math.PI; endAng = (2 - mouthOpen) * Math.PI; }
    else if(pac.dir.x === -1){ startAng = Math.PI + mouthOpen * Math.PI; endAng = Math.PI - mouthOpen * Math.PI; }
    else if(pac.dir.y === -1){ startAng = -Math.PI/2 + mouthOpen * Math.PI; endAng = -Math.PI/2 - mouthOpen * Math.PI; }
    else if(pac.dir.y === 1){ startAng = Math.PI/2 + mouthOpen * Math.PI; endAng = Math.PI/2 - mouthOpen * Math.PI; }
    else { startAng = 0; endAng = Math.PI*2; }

    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, pac.radius, startAng, endAng, false);
    ctx.closePath();
    ctx.fill();
  }

  // main loop (frame-timed)
  let running = true;
  function frame(){
    if(!running) return;
    // try to change direction using buffered input when possible
    tryApplyBufferedDir();
    // step movement with collision prevention
    stepMove();
    // eat pellet if aligned
    tryEatPellet();
    // draw everything
    draw();
    requestAnimationFrame(frame);
  }

  // reset function
  function reset(){
    // restore map from raw (deep copy)
    for(let r=0;r<raw.length;r++) map[r] = raw[r].split('');
    pac.px = 13 * TILE + TILE/2;
    pac.py = 23 * TILE + TILE/2;
    pac.dir.x = 0; pac.dir.y = 0;
    pac.nextDir.x = 0; pac.nextDir.y = 0;
    score = 0; updateScore();
  }

  // expose reset to outside (used by 'r' key)
  window.resetPacman = reset;

  // initialize
  reset();
  frame();

  // cleanup when leaving gameArea: when user clicks backToMenu, container is cleared â€” stop loop
  const observer = new MutationObserver((m)=>{
    m.forEach(rec=>{
      if(rec.removedNodes.length){
        // if canvas was removed, stop the loop
        if(!document.body.contains(canvas)){
          running = false;
          observer.disconnect();
          window.removeEventListener('keydown', onKeyDown);
        }
      }
    });
  });
  observer.observe(container, {childList:true});
}
</script>
</body>
</html>
