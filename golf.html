<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Pac-Man ‚Äî Mejorado (IA + F√≠sica)</title>
<style>
  :root{--bg:#000;--wall:#001f6f;--pellet:#ffd54d}
  body{margin:0;background:var(--bg);color:#fff;font-family:Arial,system-ui;overflow:hidden}
  #menu,#playScreen,#gameArea{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column}
  #menu{background:radial-gradient(circle at center,#111,#000)}
  .card{background:#222;padding:18px;border-radius:10px;margin:8px;width:220px;text-align:center;cursor:pointer}
  .card:hover{transform:scale(1.03);background:#333}
  #playScreen{display:none;background:rgba(0,0,0,.85)}
  #gameArea{display:none}
  button{padding:10px 16px;border-radius:8px;border:0;background:#0af;color:#001;font-weight:700;cursor:pointer}
  #scoreBoard{position:fixed;left:12px;top:12px;background:rgba(0,0,0,.45);padding:6px 10px;border-radius:6px}
  canvas{image-rendering:pixelated;border-radius:8px;box-shadow:0 8px 20px rgba(0,0,0,.6)}
</style>
</head>
<body>

<div id="menu">
  <h1>üéÆ Zona de Juegos</h1>
  <div class="card" onclick="loadGame('pacman')">Pac-Man</div>
</div>

<div id="playScreen">
  <h2 id="gameTitle">Pac-Man</h2>
  <div style="display:flex;gap:12px">
    <button id="btnPlay">Play</button>
    <button id="btnBackFromPlay">Volver</button>
  </div>
</div>

<div id="gameArea">
  <div id="scoreBoard">Puntuaci√≥n: 0 | Vidas: 3</div>
  <div id="gameContainer"></div>
  <button id="btnBack" style="position:fixed;right:12px;bottom:12px">Volver al men√∫</button>
</div>

<script>
/* ---------------- UI flow ---------------- */
let currentGame = null;
let stopGameFn = null;
function loadGame(name){
  currentGame = name;
  document.getElementById('menu').style.display='none';
  document.getElementById('playScreen').style.display='flex';
  document.getElementById('gameArea').style.display='none';
}
document.getElementById('btnPlay').addEventListener('click', ()=>{
  if(currentGame==='pacman'){
    if(typeof stopGameFn==='function'){ stopGameFn(); stopGameFn=null; }
    startPacman();
  }
});
document.getElementById('btnBackFromPlay').addEventListener('click', backToMenu);
document.getElementById('btnBack').addEventListener('click', backToMenu);
function backToMenu(){
  if(typeof stopGameFn==='function'){ stopGameFn(); stopGameFn=null; }
  currentGame=null;
  document.getElementById('menu').style.display='flex';
  document.getElementById('playScreen').style.display='none';
  document.getElementById('gameArea').style.display='none';
  document.getElementById('gameContainer').innerHTML='';
  document.getElementById('scoreBoard').innerText='';
}

/* ---------------- Pac-Man Improved ---------------- */
function startPacman(){
  document.getElementById('playScreen').style.display='none';
  document.getElementById('gameArea').style.display='flex';
  document.getElementById('gameContainer').innerHTML='';
  stopGameFn = initPacman(document.getElementById('gameContainer'));
}

/* BFS for ghosts pathfinding */
function bfsShortest(grid, cols, rows, start, goal){
  const q = [];
  const prev = Array.from({length:rows},()=>Array(cols).fill(null));
  q.push(start);
  prev[start.y][start.x] = {x:-1,y:-1};
  const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
  while(q.length){
    const cur = q.shift();
    if(cur.x===goal.x && cur.y===goal.y) break;
    for(const d of dirs){
      const nx = cur.x + d.x, ny = cur.y + d.y;
      if(nx<0||nx>=cols||ny<0||ny>=rows) continue;
      if(prev[ny][nx]) continue;
      if(grid[ny][nx]==='#') continue;
      prev[ny][nx] = cur;
      q.push({x:nx,y:ny});
    }
  }
  if(!prev[goal.y][goal.x]) return null;
  // walk back to find first step after start
  let cur = {x:goal.x,y:goal.y};
  while(true){
    const p = prev[cur.y][cur.x];
    if(p.x===-1 && p.y===-1) return null; // start==goal
    if(p.x===start.x && p.y===start.y) return cur;
    cur = p;
  }
}

/* main implementation */
function initPacman(container){
  const TILE = 16;
  const COLS = 28, ROWS = 31;
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = COLS * TILE;
  canvas.height = ROWS * TILE;
  canvas.style.width = (canvas.width * 1.15) + 'px';
  canvas.style.height = (canvas.height * 1.15) + 'px';
  container.appendChild(canvas);

  const raw = [
"############################",
"#............##............#",
"#.####.#####.##.#####.####.#",
"#o####.#####.##.#####.####o#",
"#.####.#####.##.#####.####.#",
"#..........................#",
"#.####.##.########.##.####.#",
"#.####.##.########.##.####.#",
"#......##....##....##......#",
"######.##### ## #####.######",
"######.##### ## #####.######",
"######.##          ##.######",
"######.## ###--### ##.######",
"######.## #      # ##.######",
"       .  #      #  .       ",
"######.## #      # ##.######",
"######.## ######## ##.######",
"######.##          ##.######",
"######.## ######## ##.######",
"######.## ######## ##.######",
"#............##............#",
"#.####.#####.##.#####.####.#",
"#o####.#####.##.#####.####o#",
"#...##................##...#",
"###.##.##.########.##.##.###",
"###.##.##.########.##.##.###",
"#......##....##....##......#",
"#.##########.##.##########.#",
"#.##########.##.##########.#",
"#..........................#",
"############################"
  ];

const mapWidth = map[0].length;
const mapHeight = map.length;
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = mapWidth * tileSize;
canvas.height = mapHeight * tileSize;

const pac = {
  x: 13 * tileSize + tileSize/2,
  y: 17 * tileSize + tileSize/2,
  dir: {x:0, y:0},
  nextDir: {x:0, y:0},
  speed: 1.2,
  radius: 6
};

let lives = 3;
let score = 0;
let powerMode = false;
let powerTimer = 0;

const ghosts = [
  {name:'blinky', color:'red', x:13*tileSize, y:11*tileSize, dir:{x:-1,y:0}, speed:1.1, mode:'chase'},
  {name:'pinky', color:'pink', x:14*tileSize, y:11*tileSize, dir:{x:1,y:0}, speed:1.1, mode:'chase'},
  {name:'inky', color:'cyan', x:12*tileSize, y:11*tileSize, dir:{x:0,y:-1}, speed:1.1, mode:'chase'},
  {name:'clyde', color:'orange', x:15*tileSize, y:11*tileSize, dir:{x:0,y:1}, speed:1.1, mode:'chase'}
];

function isWall(tx, ty) {
  return map[ty] && map[ty][tx] === '#';
}

function movePac() {
  let nextX = pac.x + pac.dir.x * pac.speed;
  let nextY = pac.y + pac.dir.y * pac.speed;

  // t√∫neles laterales
  if (nextX < -pac.radius) nextX = mapWidth * tileSize + pac.radius;
  if (nextX > mapWidth * tileSize + pac.radius) nextX = -pac.radius;

  let tileX = Math.floor(nextX / tileSize);
  let tileY = Math.floor(nextY / tileSize);

  if (!isWall(tileX, tileY)) {
    pac.x = nextX;
    pac.y = nextY;
  }

  // cambio de direcci√≥n
  const ndx = Math.floor((pac.x + pac.nextDir.x * tileSize/2)/tileSize);
  const ndy = Math.floor((pac.y + pac.nextDir.y * tileSize/2)/tileSize);
  if (!isWall(ndx, ndy)) pac.dir = {...pac.nextDir};
}

function checkPellets() {
  const tileX = Math.floor(pac.x / tileSize);
  const tileY = Math.floor(pac.y / tileSize);
  const c = map[tileY][tileX];
  if (c === 'o' || c === 'P') {
    if (c === 'P') { 
      powerMode = true;
      powerTimer = 600;
      ghosts.forEach(g => g.mode = 'frightened');
    }
    map[tileY] = map[tileY].substring(0,tileX)+' '+map[tileY].substring(tileX+1);
    score += (c==='P'?50:10);
  }
}

function distance(a,b) {
  const dx = a.x-b.x, dy=a.y-b.y;
  return Math.sqrt(dx*dx+dy*dy);
}

function moveGhosts() {
  ghosts.forEach(g => {
    // t√∫neles
    if (g.x < -tileSize) g.x = mapWidth*tileSize;
    if (g.x > mapWidth*tileSize) g.x = 0;

    const gx = Math.floor(g.x/tileSize);
    const gy = Math.floor(g.y/tileSize);
    const dirs = [
      {x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}
    ].filter(d=>!isWall(gx+d.x, gy+d.y));

    let target = {x:pac.x, y:pac.y};
    if (powerMode && g.mode==='frightened') {
      // huye
      const rand = dirs[Math.floor(Math.random()*dirs.length)];
      g.dir = rand || g.dir;
    } else {
      switch(g.name) {
        case 'blinky':
          target = {x:pac.x, y:pac.y};
          break;
        case 'pinky':
          target = {x:pac.x+pac.dir.x*tileSize*4, y:pac.y+pac.dir.y*tileSize*4};
          break;
        case 'inky':
          const blinky = ghosts.find(x=>x.name==='blinky');
          const midX = pac.x + pac.dir.x*tileSize*2;
          const midY = pac.y + pac.dir.y*tileSize*2;
          target = {
            x: midX + (midX - blinky.x),
            y: midY + (midY - blinky.y)
          };
          break;
        case 'clyde':
          if (distance(pac,g) < 8*tileSize)
            target = {x:1*tileSize, y:mapHeight*tileSize - 2*tileSize};
          else
            target = {x:pac.x, y:pac.y};
          break;
      }
      // buscar direcci√≥n m√°s cercana al target
      let bestDir = g.dir;
      let minDist = Infinity;
      dirs.forEach(d=>{
        const nx = g.x + d.x*tileSize;
        const ny = g.y + d.y*tileSize;
        const dist = (nx-target.x)**2+(ny-target.y)**2;
        if (dist < minDist && !(d.x===-g.dir.x && d.y===-g.dir.y)) {
          minDist = dist; bestDir = d;
        }
      });
      g.dir = bestDir;
    }
    g.x += g.dir.x * g.speed;
    g.y += g.dir.y * g.speed;
  });
}

function checkCollisions() {
  ghosts.forEach(g=>{
    const d = distance(pac,g);
    if (d < pac.radius*1.5) {
      if (powerMode && g.mode==='frightened') {
        score += 200;
        g.x = 13*tileSize; g.y = 11*tileSize; // volver al centro
        g.mode='chase';
      } else if (!powerMode) {
        lives--;
        if (lives <= 0) {
          alert("GAME OVER");
          location.reload();
        } else {
          resetPositions();
        }
      }
    }
  });
}

function resetPositions() {
  pac.x = 13 * tileSize + tileSize/2;
  pac.y = 17 * tileSize + tileSize/2;
  pac.dir = {x:0,y:0};
  pac.nextDir = {x:0,y:0};
  ghosts.forEach((g,i)=>{
    g.x = (13+i)*tileSize;
    g.y = 11*tileSize;
    g.dir = {x:0,y:1};
    g.mode = 'chase';
  });
}

function draw() {
  ctx.fillStyle='black';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  for (let y=0;y<mapHeight;y++){
    for (let x=0;x<mapWidth;x++){
      const c=map[y][x];
      if (c==='#') {
        ctx.fillStyle='blue';
        ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize);
      } else if (c==='o' || c==='P') {
        ctx.fillStyle = (c==='P'?'orange':'white');
        ctx.beginPath();
        ctx.arc(x*tileSize+tileSize/2, y*tileSize+tileSize/2, c==='P'?4:2, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }
  // Pac-Man
  ctx.fillStyle='yellow';
  ctx.beginPath();
  ctx.arc(pac.x, pac.y, pac.radius, 0, Math.PI*2);
  ctx.fill();
  // Ghosts
  ghosts.forEach(g=>{
    ctx.fillStyle=(powerMode && g.mode==='frightened')?'blue':g.color;
    ctx.beginPath();
    ctx.arc(g.x, g.y, pac.radius, 0, Math.PI*2);
    ctx.fill();
  });
  document.getElementById('scoreBoard').innerText=`Puntuaci√≥n: ${score} | Vidas: ${lives}`;
}

function loop() {
  movePac();
  moveGhosts();
  checkPellets();
  checkCollisions();
  if (powerMode) {
    powerTimer--;
    if (powerTimer <= 0) {
      powerMode = false;
      ghosts.forEach(g=>g.mode='chase');
    }
  }
  draw();
  requestAnimationFrame(loop);
}

document.addEventListener('keydown',e=>{
  if (e.key==='ArrowUp') pac.nextDir={x:0,y:-1};
  if (e.key==='ArrowDown') pac.nextDir={x:0,y:1};
  if (e.key==='ArrowLeft') pac.nextDir={x:-1,y:0};
  if (e.key==='ArrowRight') pac.nextDir={x:1,y:0};
});

resetPositions();
loop();
</script>
</body>
</html>
