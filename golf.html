<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Zona de Juegos - Pac-Man</title>
<style>
  body { margin:0; font-family:Arial,system-ui; background:#000; color:#fff; overflow:hidden; }
  #menu,#playScreen,#gameArea { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column; }
  #menu { background:radial-gradient(circle at center,#111,#000); }
  .card{ background:#222; padding:18px; margin:8px; border-radius:10px; cursor:pointer; width:220px; text-align:center; }
  .card:hover{ transform:scale(1.03); background:#333; }
  #playScreen{ display:none; background:rgba(0,0,0,0.9); }
  #gameArea{ display:none; }
  button{ padding:10px 18px; border-radius:8px; border:0; background:#0af; color:#001; font-weight:700; cursor:pointer; }
  button:hover{ filter:brightness(.95); }
  #scoreBoard{ position:fixed; left:12px; top:12px; background:rgba(0,0,0,0.45); padding:6px 10px; border-radius:6px; }
  canvas{ image-rendering:pixelated; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,.6); }
</style>
</head>
<body>

<!-- MENU -->
<div id="menu">
  <h1>ðŸŽ® Zona de Juegos</h1>
  <div class="card" onclick="loadGame('pacman')">Pac-Man</div>
</div>

<!-- PLAY SCREEN -->
<div id="playScreen">
  <h2 id="gameTitle">Pac-Man</h2>
  <div style="display:flex;gap:12px">
    <button id="btnPlay">Play</button>
    <button id="btnBackFromPlay">Volver</button>
  </div>
</div>

<!-- GAME AREA -->
<div id="gameArea">
  <div id="scoreBoard">PuntuaciÃ³n: 0 | Vidas: 3</div>
  <div id="gameContainer"></div>
  <button id="btnBack" style="position:fixed;right:12px;bottom:12px">Volver al menÃº</button>
</div>

<script>
/* ----------------------------
   Vista y control de pantallas
   ---------------------------- */
let currentGame = null;
let stopCurrentGame = null;

function loadGame(name){
  currentGame = name;
  document.getElementById('menu').style.display = 'none';
  document.getElementById('playScreen').style.display = 'flex';
  document.getElementById('gameArea').style.display = 'none';
  document.getElementById('gameTitle').innerText = name === 'pacman' ? 'Pac-Man' : name;
}

document.getElementById('btnPlay').addEventListener('click', () => {
  if (currentGame === 'pacman') startPacman();
});
document.getElementById('btnBackFromPlay').addEventListener('click', backToMenu);
document.getElementById('btnBack').addEventListener('click', backToMenu);

function startPacman(){
  // stop previous if any
  if (stopCurrentGame) { stopCurrentGame(); stopCurrentGame = null; }

  document.getElementById('playScreen').style.display = 'none';
  document.getElementById('gameArea').style.display = 'flex';
  document.getElementById('gameContainer').innerHTML = '';

  // start and capture stop function
  stopCurrentGame = initPacman(document.getElementById('gameContainer'));
}

function backToMenu(){
  // stop running game if any
  if (typeof stopCurrentGame === 'function') { stopCurrentGame(); stopCurrentGame = null; }
  currentGame = null;
  document.getElementById('menu').style.display = 'flex';
  document.getElementById('playScreen').style.display = 'none';
  document.getElementById('gameArea').style.display = 'none';
  document.getElementById('gameContainer').innerHTML = '';
  document.getElementById('scoreBoard').innerText = '';
}

/* ----------------------------
   Pac-Man (pixel smooth, fixed)
   Returns a stop() function
   ---------------------------- */
function initPacman(container){
  // Canvas & sizes
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const TILE = 16;
  const COLS = 28, ROWS = 31;
  canvas.width = COLS * TILE;
  canvas.height = ROWS * TILE;
  canvas.style.width = (canvas.width * 1.2) + 'px';
  canvas.style.height = (canvas.height * 1.2) + 'px';
  container.appendChild(canvas);

  // Map (classic-ish)
  const raw = [
"############################",
"#............##............#",
"#.####.#####.##.#####.####.#",
"#o####.#####.##.#####.####o#",
"#.####.#####.##.#####.####.#",
"#..........................#",
"#.####.##.########.##.####.#",
"#.####.##.########.##.####.#",
"#......##....##....##......#",
"######.##### ## #####.######",
"######.##### ## #####.######",
"######.##          ##.######",
"######.## ###--### ##.######",
"######.## #      # ##.######",
"       .  #      #  .       ",
"######.## #      # ##.######",
"######.## ######## ##.######",
"######.##          ##.######",
"######.## ######## ##.######",
"######.## ######## ##.######",
"#............##............#",
"#.####.#####.##.#####.####.#",
"#o####.#####.##.#####.####o#",
"#...##................##...#",
"###.##.##.########.##.##.###",
"###.##.##.########.##.##.###",
"#......##....##....##......#",
"#.##########.##.##########.#",
"#.##########.##.##########.#",
"#..........................#",
"############################"
  ];

  // deep copy map for play
  let map = raw.map(r => r.split(''));

  // State
  let score = 0;
  let lives = 3;
  const pac = {
    px: 13 * TILE + TILE/2,
    py: 23 * TILE + TILE/2,
    dir: {x:0,y:0},       // current normalized direction (-1,0,1)
    nextDir: {x:0,y:0},   // buffered dir
    speed: 1.6,           // px per frame (adjust here)
    radius: TILE*0.45
  };

  const ghosts = [
    { px:13*TILE+TILE/2, py:11*TILE+TILE/2, dir:{x:0,y:0}, color:'red', home:{px:13*TILE+TILE/2, py:11*TILE+TILE/2} },
    { px:14*TILE+TILE/2, py:11*TILE+TILE/2, dir:{x:0,y:0}, color:'pink', home:{px:14*TILE+TILE/2, py:11*TILE+TILE/2} },
    { px:12*TILE+TILE/2, py:11*TILE+TILE/2, dir:{x:0,y:0}, color:'cyan', home:{px:12*TILE+TILE/2, py:11*TILE+TILE/2} },
    { px:15*TILE+TILE/2, py:11*TILE+TILE/2, dir:{x:0,y:0}, color:'orange', home:{px:15*TILE+TILE/2, py:11*TILE+TILE/2} },
  ];

  let running = true;
  // input
  const keyMap = { ArrowUp:{x:0,y:-1}, ArrowDown:{x:0,y:1}, ArrowLeft:{x:-1,y:0}, ArrowRight:{x:1,y:0} };
  function onKey(e){
    if(keyMap[e.key]) {
      pac.nextDir = keyMap[e.key];
      e.preventDefault();
    }
    if(e.key.toLowerCase()==='r'){ // quick restart
      resetRound();
    }
  }
  window.addEventListener('keydown', onKey);

  // helpers: grid coord from pixel pos
  const pixelToGrid = (px,py) => ({ gx: Math.floor(px / TILE), gy: Math.floor(py / TILE) });
  const gridCenter = (gx,gy) => ({ cx: gx*TILE + TILE/2, cy: gy*TILE + TILE/2 });
  const isWallCell = (gx,gy) => {
    if(gy<0 || gy>=ROWS || gx<0 || gx>=COLS) return false;
    return map[gy][gx] === '#';
  };

  // allow moving from px,py towards dir if next cell walkable
  function canMoveFrom(px,py,dir){
    // project a tiny amount to decide next cell
    const testX = px + dir.x * TILE * 0.49;
    const testY = py + dir.y * TILE * 0.49;
    const { gx, gy } = pixelToGrid(testX, testY);
    return !isWallCell(gx, gy);
  }

  // teleport tunnel (if very left or very right)
  function handleTunnel(ent){
    if(ent.px < -TILE/2) ent.px = (COLS-0.5)*TILE;
    if(ent.px > (COLS-0.5)*TILE) ent.px = -TILE/2;
  }

  // eat pellet at pac center grid cell
  function eatPellet(){
    const { gx, gy } = pixelToGrid(pac.px, pac.py);
    const ch = map[gy] && map[gy][gx];
    if(!ch) return;
    if(ch === '.'){ score += 10; map[gy][gx] = ' '; updateHUD(); }
    if(ch === 'o'){ score += 50; map[gy][gx] = ' '; updateHUD(); /* power mode could be triggered here */ }
  }

  function updateHUD(){ document.getElementById('scoreBoard').innerText = `PuntuaciÃ³n: ${score} | Vidas: ${lives}`; }

  // move pac smoothly using pixel positions and buffered nextDir
  function updatePac(){
    // try to apply buffered direction when aligned enough to grid center
    const alignedX = Math.abs((pac.px - TILE/2) % TILE) < 1.0;
    const alignedY = Math.abs((pac.py - TILE/2) % TILE) < 1.0;
    if((alignedX && alignedY) && pac.nextDir){
      if(canMoveFrom(pac.px, pac.py, pac.nextDir)){
        pac.dir = { x: pac.nextDir.x, y: pac.nextDir.y };
      }
    }
    // if no dir or blocked ahead, don't move
    if(pac.dir.x === 0 && pac.dir.y === 0) return;
    if(!canMoveFrom(pac.px, pac.py, pac.dir)){
      // snap to center of cell to avoid hugging wall
      const { gx, gy } = pixelToGrid(pac.px, pac.py);
      const center = gridCenter(gx, gy);
      pac.px = center.cx; pac.py = center.cy;
      pac.dir = {x:0,y:0};
      return;
    }
    // move
    pac.px += pac.dir.x * pac.speed;
    pac.py += pac.dir.y * pac.speed;
    handleTunnel(pac);
  }

  // simple ghost AI (pixel movement but chooses direction on grid centers)
  function updateGhost(g){
    // if aligned to grid center, choose next dir based on simple logic
    const { gx, gy } = pixelToGrid(g.px, g.py);
    const center = gridCenter(gx, gy);
    const aligned = Math.hypot(g.px - center.cx, g.py - center.cy) < 1.2;
    if(aligned){
      // small decision: chase if close, else random
      const pg = pixelToGrid(pac.px, pac.py);
      const dist = Math.hypot(pg.gx - gx, pg.gy - gy);
      const options = [];
      [['left',-1,0],['right',1,0],['up',0,-1],['down',0,1]].forEach(([name,dx,dy])=>{
        if(!isWallCell(gx+dx, gy+dy)) options.push({name,dx,dy});
      });
      if(options.length===0) { g.dir = {x:0,y:0}; }
      else if(dist < 6){
        // greedy move towards pac
        options.sort((a,b) => {
          const da = Math.hypot((pg.gx - (gx+a.dx)), (pg.gy - (gy+a.dy)));
          const db = Math.hypot((pg.gx - (gx+b.dx)), (pg.gy - (gy+b.dy)));
          return da - db;
        });
        g.dir = { x: options[0].dx, y: options[0].dy };
      } else {
        // random choice (avoid reversing)
        const filtered = options.filter(o => !(g.dir.x === -o.dx && g.dir.y === -o.dy));
        const pick = filtered.length ? filtered[Math.floor(Math.random()*filtered.length)] : options[Math.floor(Math.random()*options.length)];
        g.dir = { x: pick.dx, y: pick.dy };
      }
      // snap exactly to center
      g.px = center.cx; g.py = center.cy;
    }
    // move pixelwise
    g.px += g.dir.x * g.speed;
    g.py += g.dir.y * g.speed;
    handleTunnel(g);
  }

  // collision check (pixel-distance)
  function checkGhostCollisions(){
    for(const g of ghosts){
      const d = Math.hypot(g.px - pac.px, g.py - pac.py);
      if(d < TILE*0.6){
        // pac death
        lives--;
        updateHUD();
        if(lives <= 0){
          // stop game and show game over
          alert(`Game Over\nPuntuaciÃ³n: ${score}`);
          stop(); // stop the game
          backToMenu();
          return;
        }
        // reset positions and pause briefly
        resetRound();
        return;
      }
    }
  }

  // draw everything
  let mouthTimer = 0;
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // map
    for(let y=0;y<map.length;y++){
      for(let x=0;x<map[y].length;x++){
        const ch = map[y][x];
        const sx = x * TILE, sy = y * TILE;
        if(ch === '#'){
          ctx.fillStyle = '#001f6f';
          ctx.fillRect(sx, sy, TILE, TILE);
          ctx.fillStyle = 'rgba(255,255,255,0.03)';
          ctx.fillRect(sx+2, sy+2, TILE-4, TILE-4);
        } else if(ch === '.' || ch === 'o'){
          ctx.fillStyle = '#ffd54d';
          ctx.beginPath();
          ctx.arc(sx + TILE/2, sy + TILE/2, (ch==='o'?4:2), 0, Math.PI*2);
          ctx.fill();
        }
      }
    }
    // pac mouth animation & draw
    mouthTimer += 0.12;
    const mouthOpen = 0.20 + Math.abs(Math.sin(mouthTimer)) * 0.25;
    let start = 0, end = Math.PI*2;
    if(pac.dir.x === 1){ start = mouthOpen * Math.PI; end = (2 - mouthOpen) * Math.PI; }
    else if(pac.dir.x === -1){ start = Math.PI + mouthOpen * Math.PI; end = Math.PI - mouthOpen * Math.PI; }
    else if(pac.dir.y === -1){ start = -Math.PI/2 + mouthOpen * Math.PI; end = -Math.PI/2 - mouthOpen * Math.PI; }
    else if(pac.dir.y === 1){ start = Math.PI/2 + mouthOpen * Math.PI; end = Math.PI/2 - mouthOpen * Math.PI; }

    ctx.fillStyle = '#ffeb3b';
    ctx.beginPath();
    ctx.moveTo(pac.px, pac.py);
    ctx.arc(pac.px, pac.py, pac.radius, start, end);
    ctx.closePath();
    ctx.fill();

    // ghosts
    for(const g of ghosts){
      ctx.fillStyle = g.color;
      ctx.beginPath();
      ctx.arc(g.px, g.py - 2, TILE*0.42, Math.PI, 0); // head
      ctx.lineTo(g.px + TILE*0.42, g.py + TILE*0.42);
      ctx.lineTo(g.px - TILE*0.42, g.py + TILE*0.42);
      ctx.closePath();
      ctx.fill();
      // eyes
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(g.px - 5, g.py - 6, 4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(g.px + 5, g.py - 6, 4, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath(); ctx.arc(g.px - 5 + g.dir.x*2, g.py - 6 + g.dir.y*2, 2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(g.px + 5 + g.dir.x*2, g.py - 6 + g.dir.y*2, 2, 0, Math.PI*2); ctx.fill();
    }
  }

  function resetRound(){
    // restore map from raw
    map = raw.map(r => r.split(''));
    // reset pac & ghosts pixel positions
    pac.px = 13*TILE + TILE/2; pac.py = 23*TILE + TILE/2;
    pac.dir = {x:0,y:0}; pac.nextDir = {x:0,y:0};
    ghosts.forEach((g,i) => { g.px = g.home.px; g.py = g.home.py; g.dir = {x:0,y:0}; g.speed = 0.9; });
    score = 0;
    updateHUD();
  }

  // initial setup
  updateHUD();
  resetRound();

  // main loop (delta timing, capped)
  let last = performance.now();

  function frame(now){
    if(!running) return;
    const dt = Math.min(40, now - last); // ms
    last = now;

    // update logic with smaller steps so movement consistent across dt
    // we treat speed as px per frame approx, but scale by dt/16 for smoothness
    const stepFactor = dt / 16;

    // update pac direction applying buffered input if possible
    // we attempt applying nextDir only when close to center of tile
    const centerGridX = Math.round((pac.px - TILE/2) / TILE);
    const centerGridY = Math.round((pac.py - TILE/2) / TILE);
    const center = gridCenter(centerGridX, centerGridY);
    const aligned = Math.hypot(pac.px - center.cx, pac.py - center.cy) < 6;
    if(aligned && (pac.nextDir.x !== pac.dir.x || pac.nextDir.y !== pac.dir.y)){
      if(canMoveFrom(pac.px, pac.py, pac.nextDir)){
        pac.dir = { x: pac.nextDir.x, y: pac.nextDir.y };
        // snap to center to avoid drift
        pac.px = center.cx; pac.py = center.cy;
      }
    }

    // update moves scaled by dt
    const oldPac = { px: pac.px, py: pac.py };
    pac.px += pac.dir.x * pac.speed * stepFactor;
    pac.py += pac.dir.y * pac.speed * stepFactor;
    handleTunnel(pac);

    // ghosts update (each uses its own speed)
    for(const g of ghosts){
      // updateGhost uses its own logic and uses pixel speed
      // determine center alignment for ghost
      const gg = pixelToGrid(g.px, g.py);
      const gcenter = gridCenter(gg.gx, gg.gy);
      const galigned = Math.hypot(g.px - gcenter.cx, g.py - gcenter.cy) < 6;
      if(galigned){
        // decide next direction
        const pg = pixelToGrid(pac.px, pac.py);
        const dist = Math.hypot(pg.gx - gg.gx, pg.gy - gg.gy);
        const options = [];
        [['left',-1,0],['right',1,0],['up',0,-1],['down',0,1]].forEach(([n,dx,dy])=>{
          if(!isWallCell(gg.gx+dx, gg.gy+dy)) options.push({dx,dy});
        });
        if(options.length === 0){ g.dir = {x:0,y:0}; } 
        else if(dist < 6){
          // greedy
          options.sort((a,b)=> {
            const da = Math.hypot(pg.gx - (gg.gx+a.dx), pg.gy - (gg.gy+a.dy));
            const db = Math.hypot(pg.gx - (gg.gx+b.dx), pg.gy - (gg.gy+b.dy));
            return da - db;
          });
          g.dir = { x: options[0].dx, y: options[0].dy };
        } else {
          // random (avoid immediate reverse)
          const filtered = options.filter(o => !(g.dir.x === -o.dx && g.dir.y === -o.dy));
          const pick = filtered.length ? filtered[Math.floor(Math.random()*filtered.length)] : options[Math.floor(Math.random()*options.length)];
          g.dir = { x: pick.dx, y: pick.dy };
        }
        // snap center
        g.px = gcenter.cx; g.py = gcenter.cy;
      }
      // move pixelwise scaled by dt
      const gSpeed = (g.speed || 0.9);
      g.px += g.dir.x * gSpeed * stepFactor;
      g.py += g.dir.y * gSpeed * stepFactor;
      handleTunnel(g);
    }

    // pellets / eat
    eatPellet();

    // collisions
    checkGhostCollisions();

    // draw
    draw();

    // schedule next
    requestAnimationFrame(frame);
  }

  // start loop
  requestAnimationFrame(frame);

  // stop function to cleanup listeners and stop loop
  function stop(){
    running = false;
    window.removeEventListener('keydown', onKey);
  }

  // expose stop
  return stop;
}
</script>
</body>
</html>
