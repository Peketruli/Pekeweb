<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>F1 3D Circuito</title>
<style>
body { margin:0; overflow:hidden; background:#87CEEB; }
#ui { position:absolute; top:10px; left:10px; color:white; font-family:sans-serif; font-size:16px; background:rgba(0,0,0,0.5); padding:8px; border-radius:6px;}
</style>
</head>
<body>
<div id="ui">Velocidad: <span id="speed">0</span></div>
<script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
<script>
// ===== ESCENA Y CÁMARA =====
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// ===== LUCES =====
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(20,40,20); scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

// ===== PISTA =====
// Pista central en S usando varias secciones rectas y curvas
const pistaMaterial = new THREE.MeshStandardMaterial({color:0x333333});
const pistas = [];

// Secciones rectas
for(let i=0;i<5;i++){
  const seg = new THREE.Mesh(new THREE.BoxGeometry(10,0.2,40), pistaMaterial);
  seg.position.set(i*8-16,0,0);
  pistas.push(seg);
  scene.add(seg);
}

// Curvas (simples, usando planos inclinados lateralmente)
for(let i=0;i<4;i++){
  const curve = new THREE.Mesh(new THREE.BoxGeometry(8,0.2,10), pistaMaterial);
  curve.rotation.y = (i%2===0?0.5:-0.5);
  curve.position.set(i*8-12,0,(i%2===0?15:-15));
  pistas.push(curve);
  scene.add(curve);
}

// Bordes (límite de pista)
const wallMaterial = new THREE.MeshStandardMaterial({color:0x228B22});
const walls = [];
for(let i=-100;i<100;i+=10){
  walls.push(new THREE.Mesh(new THREE.BoxGeometry(0.5,2,10), wallMaterial));
  walls[walls.length-1].position.set(-5,1,i);
  scene.add(walls[walls.length-1]);
  walls.push(new THREE.Mesh(new THREE.BoxGeometry(0.5,2,10), wallMaterial));
  walls[walls.length-1].position.set(5,1,i);
  scene.add(walls[walls.length-1]);
}

// ===== COCHE =====
const carGeom = new THREE.BoxGeometry(1,0.5,2);
const carMat = new THREE.MeshStandardMaterial({color:0xff0000});
const car = new THREE.Mesh(carGeom,carMat);
car.position.y = 0.25;
car.position.z = -80;
scene.add(car);

// ===== VARIABLES JUEGO =====
let speed = 0;
const maxSpeed = 2;
const accel = 0.05;
const brake = 0.07;
const friction = 0.96;

const keys = {};
document.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
document.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

const speedUI = document.getElementById("speed");

// ===== LOOP =====
function animate(){
  requestAnimationFrame(animate);

  // Controles
  if(keys['arrowup']) speed += accel;
  if(keys['arrowdown']) speed -= brake;
  speed *= friction;
  speed = Math.max(Math.min(speed,maxSpeed),-maxSpeed);

  // Giro
  if(keys['arrowleft']) car.rotation.y += 0.03 * (speed/maxSpeed);
  if(keys['arrowright']) car.rotation.y -= 0.03 * (speed/maxSpeed);

  // Movimiento
  car.position.x -= Math.sin(car.rotation.y)*speed;
  car.position.z -= Math.cos(car.rotation.y)*speed;

  // Cámara
  camera.position.x = car.position.x - Math.sin(car.rotation.y)*5;
  camera.position.y = car.position.y + 3;
  camera.position.z = car.position.z - Math.cos(car.rotation.y)*5;
  camera.lookAt(car.position);

  // Mantener dentro de los bordes
  car.position.x = Math.max(-4.5,Math.min(4.5,car.position.x));

  speedUI.textContent = speed.toFixed(2);
  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
