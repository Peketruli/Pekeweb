<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>CSGO 2D - Prototipo Multijugador Supabase</title>
    
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #game-container {
            border: 2px solid #555;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
        }
        #info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="game-container">
        </div>
    
    <div id="info-panel">
        <p>Mi ID: <span id="my-id"></span></p>
        <p>Jugadores: <span id="player-count">1</span></p>
        <p>Sala: <span id="room-name"></span></p>
        <p>Mueve: **WASD** | Apunta/Dispara: **Ratón**</p>
    </div>

    <script>
        //==============================================================
        // *** CONFIGURACIÓN SUPABASE (¡MODIFICA ESTO!) ***
        //==============================================================
        const SUPABASE_URL = 'https://jdvwlfogkzrzovepzjqa.supabase.co'; // Reemplaza
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpkdndsZm9na3pyem92ZXB6anFhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwMzY1MjEsImV4cCI6MjA3MzYxMjUyMX0.IwVFrvuluY0tfgE82XnqYSsRjFPsDYnlfyirHjKu1TI'; // Reemplaza
        
        const supabase = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        //==============================================================
        // CONSTANTES Y VARIABLES DE JUEGO
        //==============================================================
        const GAME_WIDTH = 1200;
        const GAME_HEIGHT = 800;
        const PLAYER_SPEED = 300;
        const BULLET_SPEED = 800;
        const FIRE_RATE = 150; // ms entre disparos
        const ROOM_NAME = 'csgo_2d_match_1';
        
        const BROADCAST_INTERVAL = 33; // 30 actualizaciones por segundo
        let lastMoveBroadcastTime = 0;

        // Variables de Juego
        let player; // Nuestro jugador local
        let keys;
        let bullets;
        let lastShotTime = 0;
        
        let playerID = `player_${Math.random().toString(36).substring(2, 9)}`; // ID único de este cliente
        let remotePlayers = {}; // Jugadores remotos (otros clientes)
        let roomChannel; // Canal de Supabase Realtime

        // Configuración de Phaser
        const config = {
            type: Phaser.AUTO,
            width: GAME_WIDTH,
            height: GAME_HEIGHT,
            physics: {
                default: 'arcade',
                arcade: {
                    // debug: true, 
                    gravity: { y: 0 } 
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update,
                shoot: shoot 
            },
            parent: 'game-container'
        };

        let game = new Phaser.Game(config);

        //==============================================================
        // PHASER FASES
        //==============================================================
        function preload () {
            // No cargamos assets aquí; usamos formas geométricas (más robusto para un prototipo)
        }

        function create () {
            // Actualizar panel de información
            document.getElementById('my-id').textContent = playerID;
            document.getElementById('room-name').textContent = ROOM_NAME;

            // 1. Crear el Jugador Local (Rectángulo Blanco)
            player = this.add.rectangle(400, 300, 32, 32, 0xFFFFFF);
            this.physics.add.existing(player); 
            player.body.setCollideWorldBounds(true);
            player.setOrigin(0.5, 0.5);
            player.body.setSize(30, 30); // Ajustar hitbox
            
            // Línea de mira (contenedor)
            let sightLine = this.add.graphics().lineStyle(2, 0x00FF00, 0.8).strokeLineShape(new Phaser.Geom.Line(0, 0, 30, 0));
            player.add(sightLine); 

            // 2. Control de Teclado (WASD)
            keys = this.input.keyboard.addKeys({
                up: Phaser.Input.Keyboard.KeyCodes.W,
                down: Phaser.Input.Keyboard.KeyCodes.S,
                left: Phaser.Input.Keyboard.KeyCodes.A,
                right: Phaser.Input.Keyboard.KeyCodes.D
            });

            // 3. Crear el Grupo de Balas
            bullets = this.physics.add.group({
                classType: Phaser.GameObjects.Arc,
                runChildUpdate: true,
                maxSize: 50, 
                createCallback: (bullet) => {
                    bullet.setOrigin(0.5, 0.5);
                    bullet.setRadius(4); 
                    bullet.setFillStyle(0xFF0000); 
                    bullet.body.allowGravity = false;
                }
            });

            // 4. Configurar Disparo con Ratón
            this.input.on('pointerdown', function (pointer) {
                if (pointer.primaryDown) {
                    this.scene.shoot(pointer); 
                }
            });

            // 5. Configurar la Cámara
            this.cameras.main.startFollow(player, true, 0.1, 0.1);
            this.cameras.main.setZoom(1.5);
            
            // 6. ¡Conexión a Supabase!
            joinOrCreateRoom.call(this);
        }

        function update (time, delta) {
            player.body.setVelocity(0);
            let moving = false;
            
            // Lógica de Movimiento WASD
            if (keys.up.isDown) { player.body.setVelocityY(-PLAYER_SPEED); moving = true; } 
            else if (keys.down.isDown) { player.body.setVelocityY(PLAYER_SPEED); moving = true; }
            if (keys.left.isDown) { player.body.setVelocityX(-PLAYER_SPEED); moving = true; } 
            else if (keys.right.isDown) { player.body.setVelocityX(PLAYER_SPEED); moving = true; }

            // Normalización de velocidad diagonal
            if (moving) { player.body.velocity.normalize().scale(PLAYER_SPEED); }

            // Lógica de Apuntado (Rotación)
            let pointer = this.input.activePointer;
            let angle = Phaser.Math.Angle.Between(player.x, player.y, pointer.worldX, pointer.worldY);
            player.rotation = angle;

            // -------------------------------------------------------------
            // LÓGICA MULTIJUGADOR: BROADCAST DE MOVIMIENTO
            // -------------------------------------------------------------
            if ((moving || player.rotation !== player.lastRotation) && roomChannel && time > lastMoveBroadcastTime + BROADCAST_INTERVAL) {
                lastMoveBroadcastTime = time;
                player.lastRotation = player.rotation; // Guardar la última rotación enviada
                
                roomChannel.send({
                    type: 'broadcast',
                    event: 'player_move',
                    payload: {
                        id: playerID, 
                        x: player.x, 
                        y: player.y, 
                        rot: player.rotation 
                    }
                });
            }
        }

        function shoot (pointer) {
            let currentTime = this.time.now;

            if (currentTime > lastShotTime + FIRE_RATE) {
                lastShotTime = currentTime;
                
                // 1. Crear bala localmente (Client-Side Prediction)
                let bullet = bullets.get(player.x, player.y);
                if (bullet) {
                    bullet.setActive(true).setVisible(true);

                    let direction = new Phaser.Math.Vector2().setToPolar(player.rotation, 1); 
                    bullet.body.setVelocity(direction.x * BULLET_SPEED, direction.y * BULLET_SPEED);
                    
                    // Lógica simple de reciclaje de balas
                    bullet.update = function () {
                        if (Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y) > 1200) {
                            this.setActive(false).setVisible(false).body.stop();
                        }
                    }

                    // 2. Enviar el Broadcast del disparo
                    if (roomChannel) {
                        roomChannel.send({
                            type: 'broadcast',
                            event: 'player_shoot',
                            payload: {
                                id: playerID, 
                                x_start: player.x, 
                                y_start: player.y,
                                rot: player.rotation
                            }
                        });
                    }
                }
            }
        }


       
        async function joinOrCreateRoom() {
            if (SUPABASE_URL.includes('https://jdvwlfogkzrzovepzjqa.supabase.co')) {
                console.error("ERROR: Debes reemplazar SUPABASE_URL y SUPABASE_ANON_KEY con tus propias credenciales.");
                document.getElementById('info-panel').style.border = '2px solid red';
                return;
            }

            roomChannel = supabase.channel(ROOM_NAME, {
                config: {
                    presence: { key: playerID } // Usar la presencia para saber quién está conectado
                }
            });

            // 1. Escuchar la Presencia (Conexión/Desconexión de otros)
            roomChannel.on('presence', { event: 'sync' }, () => {
                const presenceState = roomChannel.presenceState();
                const playerKeys = Object.keys(presenceState);
                
                document.getElementById('player-count').textContent = playerKeys.length;

                // Lógica para limpiar jugadores desconectados
                for (const id in remotePlayers) {
                    if (!playerKeys.includes(id)) {
                        remotePlayers[id].destroy();
                        remotePlayers[id].nameTag.destroy();
                        delete remotePlayers[id];
                    }
                }
            }).subscribe(async (status) => {
                if (status === 'SUBSCRIBED') {
                    await roomChannel.track({ key: playerID, x: player.x, y: player.y });
                    console.log('¡Conexión Supabase Realtime establecida!');
                }
            });

            // 2. Escuchar Broadcasts (Movimiento, disparos)
            roomChannel.on('broadcast', { event: 'player_move' }, (payload) => {
                handleRemoteMove.call(this, payload.payload);
            });

            roomChannel.on('broadcast', { event: 'player_shoot' }, (payload) => {
                handleRemoteShoot.call(this, payload.payload);
            });
        }
        
        /**
         * Crea/actualiza el sprite de un jugador remoto y suaviza su movimiento.
         */
        function handleRemoteMove(data) {
            if (data.id === playerID) return; // Ignorar mi propio broadcast

            let remotePlayer = remotePlayers[data.id];

            if (!remotePlayer) {
                // Crear sprite remoto (Azul)
                remotePlayer = this.add.rectangle(data.x, data.y, 32, 32, 0x0000FF);
                this.physics.add.existing(remotePlayer); 
                remotePlayer.setOrigin(0.5, 0.5);
                remotePlayer.body.setImmovable(true); // No se mueve por colisiones
                remotePlayers[data.id] = remotePlayer;
                
                // Etiqueta de nombre
                remotePlayer.nameTag = this.add.text(data.x, data.y - 20, data.id, { fontSize: '10px', fill: '#00BFFF' }).setOrigin(0.5);
                console.log(`Nuevo jugador unido: ${data.id}`);
            }

            // Interpolación (Tweening) para un movimiento suave
            this.tweens.add({
                targets: [remotePlayer, remotePlayer.nameTag],
                x: data.x,
                y: data.y,
                rotation: remotePlayer.rotation,
                duration: BROADCAST_INTERVAL * 2, 
                ease: 'Linear',
                onUpdate: () => {
                    // Mantener la etiqueta de nombre centrada sobre el jugador
                    remotePlayer.nameTag.setRotation(0); 
                }
            });
            
            // Actualizar rotación directamente
            remotePlayer.rotation = data.rot;
        }

        /**
         * Crea una bala localmente para un jugador remoto (simulación).
         */
        function handleRemoteShoot(data) {
            if (data.id === playerID) return;

            let bullet = this.scene.bullets.get(data.x_start, data.y_start);
            
            if (bullet) {
                bullet.setActive(true).setVisible(true);

                let direction = new Phaser.Math.Vector2().setToPolar(data.rot, 1); 
                bullet.body.setVelocity(direction.x * BULLET_SPEED, direction.y * BULLET_SPEED);
                
                // Lógica de reciclaje de balas remotas
                bullet.update = function () {
                    if (Phaser.Math.Distance.Between(this.x, this.y, data.x_start, data.y_start) > 1200) {
                        this.setActive(false).setVisible(false).body.stop();
                    }
                }
            }
        }
    </script>
</body>
</html>
