<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CSGO 2D â€” Ciudad 5v5</title>
<style>
  body { margin:0; overflow:hidden; background:#111; }
  canvas { display:block; background:#1a1a1a; }
  #hud {
    position:absolute; top:10px; left:10px;
    color:white; font-family:Arial; font-size:16px;
    background:rgba(0,0,0,0.5); padding:10px; border-radius:8px;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud"></div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const hud = document.getElementById("hud");

function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// ==== INPUT ====
const keys = {};
document.addEventListener("keydown", e=>keys[e.key]=true);
document.addEventListener("keyup", e=>keys[e.key]=false);
const mouse = {x:0,y:0,clicked:false};
canvas.addEventListener("mousemove", e=>{
  const r=canvas.getBoundingClientRect();
  mouse.x=e.clientX-r.left; mouse.y=e.clientY-r.top;
});
canvas.addEventListener("mousedown", ()=>mouse.clicked=true);
canvas.addEventListener("mouseup", ()=>mouse.clicked=false);

// ==== CONFIG ====
const TEAM_CT = "CT";
const TEAM_T = "T";

const weapons = [
  {name:"Pistola", damage:1, rate:15, speed:7},
  {name:"Rifle", damage:2, rate:8, speed:10}
];

// ==== ENTIDADES ====
class Entity {
  constructor(x,y,team,name){
    this.x=x; this.y=y;
    this.size=18;
    this.speed=2.5;
    this.hp=10;
    this.team=team;
    this.name=name;
    this.weapon=0;
    this.bullets=[];
    this.reload=0;
    this.target=null;
    this.isPlayer=false;
    this.alive=true;
  }
  shoot(tx,ty){
    const gun = weapons[this.weapon];
    const dx = tx - this.x;
    const dy = ty - this.y;
    const dist = Math.hypot(dx,dy);
    if(dist===0) return;
    this.bullets.push({
      x:this.x, y:this.y,
      vx:(dx/dist)*gun.speed,
      vy:(dy/dist)*gun.speed,
      size:4, damage:gun.damage
    });
  }
}

// ==== EQUIPOS ====
const allies = [];
const enemies = [];
let player = new Entity(300,300,TEAM_CT,"TÃº");
player.isPlayer=true;
allies.push(player);

const allyNames = ["Alex","Nico","Santi","Pablo"];
allyNames.forEach((n,i)=>{
  allies.push(new Entity(300+Math.random()*100, 300+Math.random()*100, TEAM_CT, n));
});

const enemyNames = ["Ivan","Diego","Leo","Marco","Tomas"];
enemyNames.forEach((n,i)=>{
  enemies.push(new Entity(800+Math.random()*100, 400+Math.random()*100, TEAM_T, n));
});

// ==== MAPA ====
const walls = [
  {x:100,y:100,w:600,h:20},
  {x:100,y:100,w:20,h:400},
  {x:100,y:480,w:600,h:20},
  {x:700,y:100,w:20,h:400},
  {x:350,y:250,w:100,h:20},
  {x:500,y:350,w:150,h:20}
];

// ==== FUNCIONES ====
function collideRectCircle(r,c){
  const cx=Math.max(r.x,Math.min(c.x,r.x+r.w));
  const cy=Math.max(r.y,Math.min(c.y,r.y+r.h));
  const dx=c.x-cx,dy=c.y-cy;
  return dx*dx+dy*dy < c.size*c.size;
}

function moveEntity(e,dx,dy){
  if(!e.alive) return;
  e.x+=dx;
  for(let w of walls) if(collideRectCircle(w,e)) e.x-=dx;
  e.y+=dy;
  for(let w of walls) if(collideRectCircle(w,e)) e.y-=dy;
}

function getClosestTarget(e,arr){
  let minDist=Infinity, target=null;
  arr.forEach(o=>{
    if(!o.alive) return;
    const d=Math.hypot(e.x-o.x,e.y-o.y);
    if(d<minDist){minDist=d;target=o;}
  });
  return target;
}

// ==== IA ====
function updateAI(){
  allies.forEach(a=>{
    if(a.isPlayer || !a.alive) return;
    // seguir al jugador
    const dx = player.x - a.x;
    const dy = player.y - a.y;
    const dist = Math.hypot(dx,dy);
    if(dist>100) moveEntity(a, (dx/dist)*a.speed, (dy/dist)*a.speed);

    // buscar enemigo y disparar
    const t = getClosestTarget(a,enemies);
    if(t && Math.hypot(a.x-t.x,a.y-t.y)<400){
      if(a.reload<=0){ a.shoot(t.x,t.y); a.reload=weapons[a.weapon].rate; }
    }
  });

  enemies.forEach(e=>{
    if(!e.alive) return;
    // patrullar o atacar
    const t = getClosestTarget(e,allies);
    if(t){
      const dx=t.x-e.x, dy=t.y-e.y, dist=Math.hypot(dx,dy);
      if(dist>150) moveEntity(e,(dx/dist)*e.speed,(dy/dist)*e.speed);
      if(e.reload<=0){ e.shoot(t.x,t.y); e.reload=weapons[e.weapon].rate; }
    }
  });
}

// ==== BALAS ====
function updateBullets(group,targetGroup){
  group.forEach(e=>{
    for(let i=e.bullets.length-1;i>=0;i--){
      const b=e.bullets[i];
      b.x+=b.vx; b.y+=b.vy;
      for(let w of walls) if(collideRectCircle(w,b)){ e.bullets.splice(i,1); return; }
      targetGroup.forEach(t=>{
        if(!t.alive) return;
        if(Math.hypot(b.x-t.x,b.y-t.y)<t.size){
          t.hp-=b.damage;
          e.bullets.splice(i,1);
          if(t.hp<=0){t.alive=false;}
        }
      });
    }
  });
}

// ==== DRAW ====
function drawEntity(e){
  if(!e.alive) return;
  ctx.beginPath();
  ctx.arc(e.x,e.y,e.size,0,Math.PI*2);
  ctx.fillStyle = e.team===TEAM_CT ? "#0af" : "#f33";
  ctx.fill();
  ctx.fillStyle="white";
  ctx.font="12px Arial";
  ctx.fillText(e.name, e.x-15, e.y-25);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="#2a2a2a";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  walls.forEach(w=>{
    ctx.fillStyle="#555";
    ctx.fillRect(w.x,w.y,w.w,w.h);
  });

  [...allies,...enemies].forEach(e=>drawEntity(e));

  // Balas
  [...allies,...enemies].forEach(e=>{
    e.bullets.forEach(b=>{
      ctx.beginPath();
      ctx.arc(b.x,b.y,b.size,0,Math.PI*2);
      ctx.fillStyle="yellow";
      ctx.fill();
    });
  });

  hud.innerHTML = `CT vivos: ${allies.filter(a=>a.alive).length} /5 | T vivos: ${enemies.filter(e=>e.alive).length} /5`;
}

// ==== UPDATE ====
function update(){
  if(!player.alive){
    hud.innerHTML = "ðŸ’€ Has muerto â€” Ronda perdida";
    return;
  }

  // movimiento jugador
  let dx=0,dy=0;
  if(keys["w"]) dy-=player.speed;
  if(keys["s"]) dy+=player.speed;
  if(keys["a"]) dx-=player.speed;
  if(keys["d"]) dx+=player.speed;
  moveEntity(player,dx,dy);

  if(mouse.clicked && player.reload<=0){
    player.shoot(mouse.x,mouse.y);
    player.reload=weapons[player.weapon].rate;
  }

  [...allies,...enemies].forEach(e=>{ if(e.reload>0) e.reload--; });

  updateAI();
  updateBullets(allies,enemies);
  updateBullets(enemies,allies);
  draw();

  // limpiar basura
  allies.forEach(a=>a.bullets=a.bullets.slice(-200));
  enemies.forEach(a=>a.bullets=a.bullets.slice(-200));

  requestAnimationFrame(update);
}

update();
</script>
</body>
</html>
