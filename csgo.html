<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Prototipo 2D con Mapa</title>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            overflow: hidden; 
        }
        canvas {
            display: block;
            background-color: #333; /* Un gris oscuro para el suelo */
            margin: 0 auto; 
        }
    </style>
</head>
<body>
    
    <canvas id="gameCanvas"></canvas>

    <script>
        // --- 1. CONFIGURACIÓN INICIAL ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- 2. EL MAPA ---
        // (0,0) es la esquina superior izquierda

        const walls = [
            // --- Paredes Exteriores ---
            { x: 0, y: 0, width: canvas.width, height: 20 }, // Arriba
            { x: 0, y: canvas.height - 20, width: canvas.width, height: 20 }, // Abajo
            { x: 0, y: 0, width: 20, height: canvas.height }, // Izquierda
            { x: canvas.width - 20, y: 0, width: 20, height: canvas.height }, // Derecha

            // --- Estructura Central (Pasillos) ---
            // Pared larga vertical (divide A y Mid)
            { x: 300, y: 100, width: 20, height: canvas.height - 200 }, 
            // Pared larga vertical (divide B y Mid)
            { x: canvas.width - 320, y: 100, width: 20, height: canvas.height - 200 },

            // --- Coberturas Sitio A ---
            { x: 120, y: 150, width: 80, height: 20 },
            { x: 120, y: 250, width: 80, height: 20 },
            
            // --- Coberturas Sitio B ---
            { x: canvas.width - 200, y: canvas.height - 170, width: 80, height: 20 },
            { x: canvas.width - 200, y: canvas.height - 270, width: 80, height: 20 }
        ];

        const zones = [
            // Zona de Spawn AT (Azul)
            { x: 40, y: canvas.height / 2 - 75, width: 150, height: 150, 
              color: 'rgba(0, 150, 255, 0.3)', name: 'Spawn AT' },
            
            // Zona de Spawn T (Roja)
            { x: canvas.width - 190, y: canvas.height / 2 - 75, width: 150, height: 150, 
              color: 'rgba(255, 100, 0, 0.3)', name: 'Spawn T' },
            
            // Sitio de Bomba A (Naranja)
            { x: 40, y: 40, width: 240, height: 200, 
              color: 'rgba(255, 69, 0, 0.3)', name: 'Sitio A' },
            
            // Sitio de Bomba B (Naranja)
            { x: canvas.width - 300, y: canvas.height - 240, width: 280, height: 200, 
              color: 'rgba(255, 69, 0, 0.3)', name: 'Sitio B' }
        ];

        // --- 3. EL JUGADOR ---
        // Lo ponemos dentro del Spawn AT
        let player = {
            x: 115,  // Centro del Spawn AT
            y: canvas.height / 2, // Centro del Spawn AT
            size: 20,
            color: 'cyan', // Color de AT
            speed: 4,
            angle: 0
        };

        // --- 4. ALMACENES Y ESTADO ---
        let bullets = [];
        let keys = {};
        let mouse = { x: 0, y: 0 };

        // --- 5. SEGUIMIENTO DE EVENTOS ---
        window.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('keydown', (e) => { keys[e.key] = true; });
        window.addEventListener('keyup', (e) => { delete keys[e.key]; });
        window.addEventListener('mousedown', (e) => {
            const bullet = {
                x: player.x,
                y: player.y,
                size: 5,
                color: 'yellow',
                speed: 10,
                angle: player.angle 
            };
            bullets.push(bullet);
        });

        // --- 6. FUNCIÓN DE COLISIÓN (NUEVO) ---
        /**
         * Comprueba si el jugador (rect1) choca con una pared (rect2)
         * El jugador se mide desde su CENTRO
         * La pared se mide desde su esquina SUPERIOR IZQUIERDA
         */
        function checkCollision(player, wall) {
            const playerLeft = player.x - player.size / 2;
            const playerRight = player.x + player.size / 2;
            const playerTop = player.y - player.size / 2;
            const playerBottom = player.y + player.size / 2;

            const wallLeft = wall.x;
            const wallRight = wall.x + wall.width;
            const wallTop = wall.y;
            const wallBottom = wall.y + wall.height;

            // Fórmula de colisión AABB (Axis-Aligned Bounding Box)
            return (
                playerRight > wallLeft &&
                playerLeft < wallRight &&
                playerBottom > wallTop &&
                playerTop < wallBottom
            );
        }

        // --- 7. FUNCIÓN DE ACTUALIZACIÓN (MODIFICADA) ---
        function update() {
            // Guardamos la posición anterior para revertirla si hay colisión
            const oldX = player.x;
            const oldY = player.y;

            // --- Mover jugador EJE X ---
            if (keys['a'] || keys['A']) {
                player.x -= player.speed;
            }
            if (keys['d'] || keys['D']) {
                player.x += player.speed;
            }

            // --- Comprobar colisiones en EJE X ---
            for (const wall of walls) {
                if (checkCollision(player, wall)) {
                    player.x = oldX; // Chocó, volvemos a la posición X anterior
                    break; 
                }
            }

            // --- Mover jugador EJE Y ---
            if (keys['w'] || keys['W']) {
                player.y -= player.speed;
            }
            if (keys['s'] || keys['S']) {
                player.y += player.speed;
            }

            // --- Comprobar colisiones en EJE Y ---
            for (const wall of walls) {
                if (checkCollision(player, wall)) {
                    player.y = oldY; // Chocó, volvemos a la posición Y anterior
                    break;
                }
            }
            // (Esta técnica de separar ejes X e Y permite "deslizarse" por las paredes)

            // --- Apuntar jugador ---
            player.angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);

            // --- Mover balas ---
            for (let i = bullets.length - 1; i >= 0; i--) {
                let bullet = bullets[i];
                bullet.x += Math.cos(bullet.angle) * bullet.speed;
                bullet.y += Math.sin(bullet.angle) * bullet.speed;

                // Borrar balas si salen de la pantalla
                if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                    bullets.splice(i, 1);
                }
                
                // (Opcional: Colisión de balas con paredes)
                // (Habría que hacer un bucle for (const wall of walls) y checkCollision)
            }
        }

        // --- 8. FUNCIÓN DE DIBUJADO (MODIFICADA) ---
        function draw() {
            // Limpiamos todo
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // --- Dibujar Zonas (primero, para que estén de fondo) ---
            for (const zone of zones) {
                ctx.fillStyle = zone.color;
                ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
                
                // Dibujar texto de la zona
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(zone.name, zone.x + zone.width / 2, zone.y + zone.height / 2);
            }

            // --- Dibujar Paredes ---
            ctx.fillStyle = '#999'; // Gris para las paredes
            for (const wall of walls) {
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            }

            // --- Dibujar Jugador ---
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            
            ctx.fillStyle = player.color;
            ctx.fillRect(-player.size / 2, -player.size / 2, player.size, player.size);
            
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(player.size, 0); // "Cañón" del arma
            ctx.stroke();
            
            ctx.restore();

            // --- Dibujar Balas ---
            for (const bullet of bullets) {
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size / 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- 9. EL BUCLE DEL JUEGO ---
        function gameLoop() {
            update(); // Lógica
            draw();   // Gráficos
            requestAnimationFrame(gameLoop);
        }

        gameLoop(); // ¡Empezar!
    </script>
</body>
</html>
